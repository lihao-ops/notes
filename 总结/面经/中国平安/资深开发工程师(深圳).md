资深开发工程师
===

岗位链接地址：https://talent.pingan.com/recruit/position.html?positionId=9A3EBA3F10634315AFE0BE2238067932

平安科技-系统运营部
---

城市：深圳市

经验要求：3年

招聘人数：1人



岗位职责
---

1. 负责集团自研中间件模块功能研发
2. 负责集团自研中间件定制化内容研发
3. 负责集团资源中间件版本迭代及维护
4. 协助处理集团自研中间件产品问题
5. 推广自研中间件产品在集团内使用



岗位要求
---

1. 计算机和软件相关专业，本科学历需具有相关研究经验5年以上。
2. 熟悉Java技术及JVM实现原理，包括内存模型、类加载机制、性能优化等。
3. 熟悉操作系统原理，掌握操作系统层面的性能问题分析。
4. 熟悉Java企业级规范及其实现原理，包括JSP规范、EJB规范、CDI规范等，掌握Corba、iiop等协议、ASM技术
5. 熟悉Tomcat，Jetty，Wildfly等java应用服务器，至少掌握其中一种产品的运行原理，阅读过相关源码，对底层架构有深入了解。
6. 掌握Spring、Hibernate等开源架构，熟悉实现原理。
7. 有大规模分布式系统开发、维护经验，有故障处理能力，源码级开发能力。





具体分析
---



### 一、熟悉Java技术及JVM实现原理，包括内存模型、类加载机制、性能优化等。





#### 1.内存模型

>Java将其运行时的内存分为以下几个区域

##### (1).堆(Heap)

**堆是用来存放所有对象实例的数组**的区域。JVM的垃圾回收器主要关注的就是堆区

- **堆区(Heap)**：

  - 新生代：用来存储刚创建的对象。
    - Eden区
    - 2个Survivor区
  - 老年代：存放长生命周期的对象。

  

##### (2).方法区(Method Area)

**这部分内存用来存储已被虚拟机加载的类信息**、常量、静态变量、即时编译器编译后的代码等。

这个区域在不同的JVM实现中可能有不同的名字(如：元空间“Metaspace”在JDK8之后代替了永久代“PermGen”)。



##### (3).栈(Stack)

**每个线程都有自己的栈，用于存放方法的局部变量、操作数栈、动态链接等信息**。每个方法被调用时，都会在栈中创建一个帧(Frame)，当方法结束时，这个帧也会被销毁。



##### (4).本地方法栈(Native Method Stack)

和Java栈类似，但用于处理本地方法(使用C或C++等编写)。



##### (5).程序计数器(PC Register)

**每一个线程都有一个独立的程序计数器**，用于记录当前执行的字节码指令的地址。





##### (6).常见面试点

- 堆和栈的区别：堆存放的是对象，栈存放的是局部变量和方法调用相关的信息。
- 垃圾回收如何处理堆内存：如Minor GC和Full GC的触发条件，以及它们如何作用于新生代和老年代。
- 内存泄露问题：虽然Java有垃圾回收机制，但某些情况下对象引用不会被回收，可能会造成内存泄露。



##### (7).疑问

>###### 这样的内存模型是基于JDK1.8吗？

是的，前面提到的JVM内存模型是基于**JDK 1.8**。JDK 1.8做了重要的调整，其中一个变化就是:

**永久代(PermGen)被元空间(Metaspace)取代。元空间不再使用JVM的堆空间，而是使用本地内存来存储类元数据信息，避免了永久代空间不足的问题。**

因此在JDK1.8中，内存模型基本如我之前所描述的，特别是**元空间和堆的分代回收机制依然是核心概念**。



> ###### 垃圾回收处理堆内存如何作用于新生代和老年代可以举典型的例子吗？

**JVM中的垃圾回收(Garbage Collection,GC)采用分代回收策略**分为:

- **新生代GC(Minor GC)**：
  - **当Eden区创建大量新对象时，Eden区内存填满后会触发Minor GC。**
  - Minor GC会清理Eden区的垃圾对象，并**将存活的对象移动到Survivor区**。
  - 每次Minor GC，**Survivor区中的对象如果经过多次GC仍未被回收，将提升(Promote)到老年代**。
  - 例：如果你的**应用程序持续创建大量短期对象，比如临时数组或局部变量对象，Eden区很快会满，Minor GC会频繁触发**。**常见的内存优化方案是减少Eden区对象创建频率或缩短对象的生命周期**。
- **老年代GC(Major/Full GC)**：
  - 当老年代内存不足时，触发Full GC。它会清理整个堆，包括新生代和老年代，耗时较长。
  - 例：在老年代存放了很多长生命周期的对象(如缓存、长时间存活的会话)，且这些对象很少被清理掉，当老年代空间耗尽时，Full GC将频繁发生，导致应用响应变慢，甚至出现“OutOfMemoryError”。



>###### 点击源码的源头很多时候会看到native，这个就是本地方法栈加载的部分吗？

在Java源码中，看到`native`关键字通常表示这个方法是**本地方法（native method）**，即该**方法的实现不是用Java编写，而是用C/C++等语言实现。**JVM通过**JNI（Java Native Interface）**调用这些本地方法。

这些**native方法**不会直接在JVM字节码中执行，它们的实现代码通常存在于系统库或其他外部库中，运行时会借助**本地方法栈**（Native Method Stack）。**本地方法栈专门用于管理这些非Java语言的方法调用**。

- **例子**：`System.gc()`是用`native`实现的，背后**调用了底层操作系统的内存管理机制**。



>###### 内存泄露的话例如使用ThreadLocal时，是怎么造成的呢?

`ThreadLocal`的确可能引发内存泄露，尤其是在**使用不当**的情况下。原因主要与**弱引用**和**线程池**有关。

**如何发生内存泄露**？

- **ThreadLocal的弱引用**：`ThreadLocal`的键（即`ThreadLocal`对象）是用弱引用（WeakReference）存储在每个线程的`Thread`对象中的。如果`ThreadLocal`对象本身被垃圾回收器回收了，但`ThreadLocal`变量关联的值（通常是线程私有数据）却没有及时清理，导致这个值还留在`Thread`对象的内存中。
  - **例子**：在线程池中，线程长期存在，但`ThreadLocal.remove()`方法没有被调用，导致`ThreadLocal`关联的对象虽然失去了`ThreadLocal`引用，但线程私有数据仍保留在堆内存，造成内存泄露。

**如何避免？**：

- 每次用完`ThreadLocal`后，显式调用`remove()`方法。
- 尽量在使用完`ThreadLocal`后确保其不再持有任何对大对象的引用。





#### 2.类加载机制

##### (1).基本流程

> Java的类加载机制采用双亲委派模型(Parent Delegation Model)，其基本流程是：

1. **加载(Loading)**：JVM通过类加载(ClassLoader)读取字节码文件(.class)，并把它们加载到内存中。
2. **链接(Linking)**：分为验证(Verify)、准备(Prepare)、解析(Resolve)三个步骤：
   - **验证**：确保类文件的字节码符合JVM规范。
   - **准备**：为类的静态变量分配内存并设置默认值。
   - **解析**：将符号引用转化为直接引用，如将方法调用转换为内存地址。
3. **初始化(Initialization)**：执行类的静态初始化块和静态变量的赋值操作。



##### (2).双亲委派模型

>###### 类加载器遵循一种层次结构

- **启动类加载器(Bootstrap ClassLoader)**：负责加载JDK核心类库(如`rt.jar`)。
- **扩展类加载器(Extension ClassLoader)**：负责加载`JAVA_HOME/lib/ext`目录下的类库。
- **应用程序类加载器(Application ClassLoader)**：负责加载用户类路径下的类(通常是项目中的`classpath`)。



>###### 双亲委派机制的规则

一个类加载请求会从当前类加载器开始，如果该加载器无法加载，它会将请求委派给它的父类加载器，直到顶层的启动类加载器。如果父类加载器也无法找到这个类，则返回到下层的加载器尝试加载。



>###### 破坏双亲委派模型的场景

在某些框架中，如Tomcat或OSGI，为了支持热加载、模块化等需求，类加载器体系可能会打破双亲委派模型，使用自己的类加载策略。



##### (3).常见面试点

1. **双亲委派模型的优点：防止类的重复加载，保证JVM核心类库的安全性。**
2. 如何**实现自定义类加载器**：继承`ClassLoader`，重新`findClass()`方法。





#### 3.JVM性能优化

JVM性能优化通常**围绕内存管理和垃圾回收机制展开**



##### (1).调整堆内存大小

- **-Xms**：设置堆的**初始大小**。

- **-Xmx**：设置堆的**最大大小**。

为了减少堆的动态扩展和收缩引起的性能开销，通常建议设置`-Xml`和`-Xmx`为相同的值。



##### (2).GC策略的选择

> JVM提供了多种GC算法，针对不同的应用场景可以选择不同的GC算法：

- Serial GC：单线程的GC，适合单核CPU的小型应用。
- Parallel GC(吞吐量优先)：多线程回收，适用于并发高、CPU密集型应用。
- CMS GC(响应时间优先)：并发标记-清除算法，适合需要低延迟的应用，但会有`浮动垃圾`的问题。
- G1 GC：适用于大内存、底暂停时间要求的应用，能同时适应响应时间和吞吐量的需求。



##### (3).堆分代的优化

- 增加新生代大小可以减少对象进入老年代的频率，但新生代过大可能导致频繁的Minor GC。
- 合理分配Survivor区的大小，减少对象在新生代中的复制次数。



##### (4). 避免频繁的Full GC

> Full GC是对**整个堆进行垃圾回收，耗时长且影响应用性能**。应尽量避免：

- 分析哪些对象频繁进入老年代。
- 优化代码，减少老年代对象的生成，使用软引用或弱引用管理缓存数据。



##### (5).JIT（即时编译器）优化

> JVM有两种运行模式：

- **解释执行**：逐行解释字节码，速度慢。
- **即时编译（JIT）**：**将热点代码编译为本地机器码，提高执行效率。**

JIT优化是通过持续监控代码执行频率，并针对热点代码进行优化。例如，内联方法调用、消除无用的同步块等。配置JIT的参数可以帮助进一步提升应用性能。



##### (6).JVM监控工具

- **jmap**：可以生成堆转储文件，分析内存使用情况。

- **jstat**：监控GC行为、内存状态等。

- **jvisualvm**：可视化工具，用于分析线程、GC和内存泄漏。





### 二、熟悉操作系统原理，掌握操作系统层面的性能问题分析。

特别是如何通过操作系统层面优化应用程序性能。可以从操作系统的一些核心概念及其与应用程序的交互说起

#### **1. 操作系统的核心原理**

##### **1.1 进程和线程管理**

- **进程**：是操作系统中资源分配的基本单位，每个进程拥有独立的内存空间。

- **线程**：是CPU调度的基本单位，一个进程可以包含多个线程，线程共享进程的内存资源。

  操作系统通过**进程调度器**来管理进程的执行，通过**线程调度器**来管理多线程的并发执行。通常有以下调度算法：

  - **时间片轮转（Round-Robin）**：将CPU时间分成多个时间片，轮流分配给各个进程。
  - **优先级调度**：根据进程或线程的优先级调度执行，优先级高的优先执行。

  **面试重点**：

  - 了解进程与线程的区别，以及Java如何通过`java.lang.Thread`和`java.util.concurrent`包管理线程。
  - 操作系统如何通过时间片或优先级算法进行线程调度，并理解它对Java应用程序并发性能的影响。

##### **1.2 内存管理**

- **虚拟内存**：操作系统通过虚拟内存将物理内存抽象化，给每个进程提供独立的地址空间。Java应用中使用的堆内存和栈内存都在虚拟内存中分配。

- **分页和分段**：操作系统使用分页或分段来管理物理内存的分配，防止内存碎片问题。

  **Java内存模型与操作系统的交互**：

  - JVM会通过**内存映射文件**（Memory Mapped File）和**直接内存（Direct Memory）**与操作系统交互。直接内存由操作系统分配，主要用于高性能IO操作，减少堆内存的使用。

##### **1.3 文件系统和IO管理**

- **文件系统**：操作系统提供的文件系统API用于管理文件的读写。不同的文件系统（如EXT4、NTFS等）在性能和可靠性方面存在差异。

- **IO管理**：Java的NIO（Non-blocking IO）提供了与操作系统底层的异步IO操作接口，通过Selector和Channel可以实现高并发、高性能的网络应用。

  **面试重点**：

  - 理解Java中的NIO如何与操作系统的异步IO模型交互，比如在Linux下使用`epoll`，在Windows下使用`IOCP`。
  - 知道如何选择适当的IO模型来优化大规模并发场景下的性能。

#### **2. 性能问题分析**

在实际生产环境中，很多性能问题与操作系统资源（如CPU、内存、IO）有关。我们需要掌握如何通过操作系统的工具分析和解决这些问题。

##### **2.1 CPU性能分析**

- 高CPU占用

  ：如果Java应用程序的线程数过多或频繁的上下文切换，会导致CPU占用过高。

  - 分析工具

    ：

    - **`top`**：显示系统整体CPU使用情况和进程的占用情况。
    - **`mpstat`**：分析多核CPU的使用率。
    - **`jstack`**：分析Java进程中哪些线程消耗了大量CPU。

  优化策略

  ：

  - 降低频繁的线程切换次数，合理调整线程池大小。
  - 使用Java的**ForkJoinPool**或**Executors**框架优化线程管理。

##### **2.2 内存性能分析**

- 内存泄漏

  ：如果Java进程中的对象没有及时被GC回收，可能导致内存泄漏。

  - 分析工具

    ：

    - **`jmap`**：可以生成内存快照（heap dump），分析堆内存的使用情况。
    - **`jhat`**：分析heap dump文件，找出泄漏的对象。
    - **`valgrind`**：用于分析C/C++程序中的内存泄漏问题。

  优化策略

  ：

  - 定期检查对象的生命周期，避免使用长生命周期对象持有短生命周期对象。
  - 对使用缓存的地方如`ThreadLocal`、`SoftReference`进行合理管理，确保它们不会导致内存泄漏。

##### **2.3 IO性能分析**

- IO瓶颈

  ：如果应用的磁盘或网络IO速度慢，会导致请求响应变慢。

  - 分析工具

    ：

    - **`iostat`**：监控系统的磁盘IO性能。
    - **`iotop`**：查看具体进程的IO占用情况。
    - **`netstat`**：查看网络连接和网络IO性能。

  优化策略

  ：

  - 使用Java的NIO或AIO优化IO操作，减少阻塞。
  - 对文件或网络操作引入批处理和缓存，减少频繁的IO操作。

##### **2.4 多线程和并发问题**

- 线程阻塞

  ：当多个线程争夺同一资源时，可能会出现锁竞争，导致线程阻塞。

  - 分析工具

    ：

    - **`jstack`**：查看线程的堆栈，分析死锁或线程阻塞情况。
    - **`strace`**：跟踪系统调用，分析系统级的阻塞点。

  优化策略

  ：

  - 使用合适的同步机制（如`ReentrantLock`、`StampedLock`）减少锁的竞争。
  - 使用无锁并发工具，如`ConcurrentHashMap`等。

#### **3. 面试重点问题**

1. 如何分析高CPU占用的问题？
   - 使用`top`、`mpstat`等工具查看CPU的使用情况，使用`jstack`查看Java进程中的线程状态。
2. 如何处理内存泄漏？
   - 使用`jmap`生成内存快照，使用`jhat`分析对象引用链，找出内存泄漏的根本原因。
3. Java NIO如何提升IO性能？
   - 通过Selector和Channel模型实现非阻塞IO，减少线程上下文切换和IO等待时间。
4. 如何优化Java应用的并发性能？
   - 合理使用线程池、分布式锁和无锁并发工具，避免过多的线程竞争和锁等待。



### 三、熟悉Java企业级规范及其实现原理，包括JSP规范、EJB规范、CDI规范等，掌握Corba、iiop等协议、ASM技术

在Java企业级应用开发中，熟悉相关规范及其实现原理是非常重要的。以下是对你提到的几个规范、协议及技术的详细说明：

#### **1. Java企业级规范**

##### **1.1 JSP（JavaServer Pages）规范**

- **定义**：JSP是一种用于创建动态网页的技术，它将HTML和Java代码结合在一起。JSP文件通常以`.jsp`后缀命名。

- 工作原理

  ：

  - JSP文件在第一次请求时会被转换为一个Servlet，并编译成Java字节码。
  - JSP使用JSP标签和表达式将Java代码嵌入HTML中。

- 核心特性

  ：

  - **EL（表达式语言）**：简化JSP页面中数据的访问，减少Java代码的使用。
  - **JSTL（JavaServer Pages Standard Tag Library）**：提供一组标准标签，使得JSP页面的开发更加便捷。

**面试重点**：

- 如何将业务逻辑与表现层分离。
- JSP生命周期及其与Servlet的关系。

##### **1.2 EJB（Enterprise JavaBeans）规范**

- **定义**：EJB是一种用于构建企业级应用的组件模型，提供了分布式事务、并发管理、持久性等功能。

- 工作原理

  ：

  - EJB组件分为三种类型：Session Beans（会话Bean）、Entity Beans（实体Bean）、Message-driven Beans（消息驱动Bean）。
  - EJB容器负责管理生命周期、事务、并发和安全等。

- 核心特性

  ：

  - **远程访问**：支持通过RMI（Remote Method Invocation）访问远程EJB。
  - **容器管理事务**：EJB容器自动处理事务，开发者只需指定事务属性。

**面试重点**：

- EJB与其他Java EE组件（如Servlet、JSP）的协作。
- EJB的生命周期及其容器管理的特性。

##### **1.3 CDI（Contexts and Dependency Injection）规范**

- **定义**：CDI是Java EE的一种上下文和依赖注入规范，提供了更灵活的依赖管理方式。

- 工作原理

  ：

  - CDI使用注解（如`@Inject`、`@Named`、`@Qualifier`）进行依赖注入。
  - 支持生命周期和上下文管理，使得开发者能够控制Bean的创建和销毁。

- 核心特性

  ：

  - **类型安全的依赖注入**：通过类型来注入依赖，支持更复杂的依赖管理。
  - **事件机制**：允许组件之间通过事件进行解耦。

**面试重点**：

- CDI的上下文管理如何影响Bean的生命周期。
- CDI与Spring等其他依赖注入框架的比较。

#### **2. 协议和技术**

##### **2.1 CORBA（Common Object Request Broker Architecture）**

- **定义**：CORBA是一种用于不同语言和平台间互操作的标准，允许程序调用远程对象。

- 工作原理

  ：

  - 通过ORB（Object Request Broker）实现客户端与服务器间的通信。
  - 支持IDL（Interface Definition Language）来定义接口，确保语言无关性。

##### **2.2 IIOP（Internet Inter-ORB Protocol）**

- **定义**：IIOP是CORBA的一个子集，支持通过互联网进行远程对象调用。

- 工作原理

  ：

  - 使用TCP/IP协议进行数据传输。
  - 允许Java EE应用在不同的服务器之间进行通信。

**面试重点**：

- CORBA和其他分布式通信框架（如RMI、SOAP）的比较。
- IIOP的应用场景及其在Java EE中的重要性。

##### **2.3 ASM技术**

- **定义**：ASM是一个Java字节码操作框架，允许在运行时动态生成和修改Java类。

- 工作原理

  ：

  - 提供低级API，用于字节码的分析和修改，能够在应用程序运行时动态生成新的类或方法。

- 核心特性

  ：

  - 高性能：ASM通过字节码操作，能够在加载时进行优化。
  - 应用广泛：在各种框架（如Spring、Hibernate）中用于字节码增强。

**面试重点**：

- ASM的基本使用方法和典型应用场景（如AOP）。
- 字节码操作对性能的影响以及如何通过ASM实现动态代理。

#### **总结**

掌握这些Java企业级规范及相关技术将有助于在面试中深入讨论如何设计和实现高效的企业级应用。





### 四、熟悉Tomcat，Jetty，Wildfly等java应用服务器，至少掌握其中一种产品的运行原理，阅读过相关源码，对底层架构有深入了解。



#### 1.Tomcat

我们可以从**Tomcat**开始，它是一个非常常见的Java应用服务器。如果你对Tomcat的运行原理和架构有较深的理解，面试中能有不错的发挥。

##### **Tomcat运行原理与架构**

###### 1. **整体架构**

Tomcat的核心架构围绕着以下几个组件：
- **Catalina**：Tomcat的Servlet容器，负责处理所有的Servlet请求。它实现了Servlet和JSP规范，管理Web应用的生命周期。
- **Coyote**：Tomcat的连接器组件，负责处理HTTP请求，将其转换为Java的`HttpServletRequest`和`HttpServletResponse`，并交由Catalina来处理。Coyote能够处理BIO（Blocking IO）、NIO（Non-blocking IO）、和APR（基于Native的Apache Portable Runtime）三种不同的请求处理方式。
- **Jasper**：Tomcat的JSP引擎，负责将JSP文件编译为Servlet。
- **Cluster**：支持在多个Tomcat节点之间进行会话复制，实现集群功能。
- **Server/Service/Connector**：这些是Tomcat的核心配置对象，Server包含Service，Service又包含多个Connector。Connector负责监听网络端口并接收请求，Service通过指定的Engine来处理这些请求。

###### 2. **请求处理流程**

Tomcat的请求处理可以分为以下几个主要步骤：
1. **请求到达Connector**：Coyote作为Connector监听客户端请求，并将这些请求封装成一个`Request`对象，传递给后续的处理流程。
2. **通过Pipeline和Valve**：Tomcat内部使用**Pipeline-Value机制**。每个请求在被处理之前，会通过一系列的`Valve`，这些Valve可以进行请求过滤、认证等操作。最关键的Valve是`StandardEngineValve`，它负责将请求交给相应的Web应用程序进行处理。
3. **Servlet处理**：请求最终到达具体的`Servlet`，通过`HttpServlet`接口来处理业务逻辑。
4. **响应返回**：Servlet处理完成后，生成`Response`对象，Tomcat将其发送回客户端。

###### 3. **类加载机制**

Tomcat使用了**自定义的类加载器**，以实现不同Web应用之间的类隔离。Tomcat有多个ClassLoader，重要的有：
- **Common ClassLoader**：加载共享库，供所有Web应用使用。
- **Webapp ClassLoader**：每个Web应用独立的类加载器，用于加载应用的`WEB-INF/classes`和`WEB-INF/lib`中的类，确保Web应用彼此隔离。
  

Tomcat在热部署和重新加载时，会通过卸载`Webapp ClassLoader`来释放内存，避免内存泄露。

##### 4. **Tomcat源码分析**

Tomcat的源码分析重点在于其组件的交互，尤其是**Catalina**和**Coyote**的配合：
- **Coyote的启动过程**：在启动Tomcat时，`CoyoteConnector`会初始化`ProtocolHandler`（NIO/NIO2/APR），并启动请求处理线程。
- **Servlet请求的处理**：从`CoyoteAdapter`接收到请求后，交由`Catalina`的`StandardEngineValve`，进一步通过一系列`Pipeline`处理到达对应的`Servlet`。

###### 5. **Tomcat性能优化**

- **线程池配置**：Tomcat的线程池通过`Executor`进行管理，合理设置`maxThreads`、`minSpareThreads`等参数可以提高并发性能。
- **连接器优化**：选择适合的`Connector`（如NIO/NIO2）并调整`acceptCount`、`connectionTimeout`等参数，确保Tomcat可以处理大量并发请求。
- **JVM调优**：结合Tomcat的GC行为，优化JVM的堆内存大小、垃圾回收参数。



#### **2.与Jetty的比较**

##### **Jetty**

- **轻量级**：Jetty比Tomcat更轻量化，适合嵌入式应用服务器。Jetty同样支持NIO，并且更专注于HTTP协议的处理。它的灵活性使其常被用于微服务架构中。
- **异步处理**：Jetty的异步处理和WebSocket支持较为突出，非常适合高并发场景。



#### **3.Tomcat面试中常见问题**

1. **Tomcat如何实现类隔离？**
   
   - 通过自定义的`WebappClassLoader`，实现每个Web应用的类独立加载。
2. **Tomcat如何处理HTTP请求？**
   
   - 通过Coyote组件接收请求，使用`Pipeline-Valve`机制将请求传递给Catalina容器，最后交由具体的Servlet处理。
3. **如何在生产环境中优化Tomcat性能？**
   
   - 合理设置线程池大小，选择合适的I/O模型（如NIO2），优化JVM的GC策略。
   
   







### 五、掌握SpringBoot、MyBatis等开源架构，熟悉实现原理。



#### **1.Spring Boot 实现原理**

##### (1). **核心特性**

> Spring Boot是基于Spring框架的快速开发工具，它的主要目的是简化Spring应用的开发过程。其核心特性包括：

- **自动配置（Auto-Configuration）**：Spring Boot通过自动配置类，基于类路径中的依赖项和定义的Bean自动配置应用程序的环境。它可以自动根据`@ConfigurationProperties`注解完成配置。
- **内嵌服务器**：支持内嵌Tomcat、Jetty或Undertow等容器，便于创建独立的可执行应用。
- **Spring Boot Starter**：提供了一系列的“起步依赖”来简化开发，开发者只需添加一个`starter`依赖，Spring Boot就会自动配置所需的组件。
- **Spring Boot Actuator**：用于监控和管理生产环境的应用，它提供了多种健康检查和监控端点。



##### (2). **自动配置原理**

Spring Boot通过`@EnableAutoConfiguration`和`spring.factories`文件来实现自动配置：

- `@EnableAutoConfiguration`会扫描`META-INF/spring.factories`中的自动配置类。

- 每个自动配置类使用`@ConditionalOnMissingBean`、`@ConditionalOnClass`等条件注解来判断是否需要加载对应的Bean。

  **例子**：当类路径中有`spring-boot-starter-data-jpa`时，Spring Boot会自动配置JPA的相关Bean。



##### (3). **Spring Boot的启动流程**

Spring Boot应用的启动过程围绕着`SpringApplication.run()`方法展开：

1. **SpringApplication初始化**：构建一个SpringApplication对象，设置应用类型、监听器等。
2. **准备环境**：加载并合并应用配置文件（如`application.properties`或`application.yml`），并准备运行环境。
3. **创建IOC容器**：通过Spring核心的IOC容器`ApplicationContext`加载所有的配置和Bean定义。
4. **自动配置**：根据项目中的依赖自动配置相应的Bean，完成Spring容器的初始化。
5. **运行应用**：启动内嵌服务器（如Tomcat），并运行整个Spring Boot应用。



##### (4). **常见面试点**

- Spring Boot如何实现自动配置？

  - 通过`spring.factories`文件及`@Conditional`系列注解动态加载Bean。

- Spring Boot如何启动内嵌Tomcat？

  - 通过`SpringApplication.run()`方法，加载Tomcat相关的Starter自动配置类，并启动内嵌容器。

  

#### **2.MyBatis 实现原理**

##### (1). **MyBatis简介**

> MyBatis是一个半自动化的ORM框架，与Hibernate这样的全自动ORM不同，MyBatis允许开发者编写SQL并将SQL语句映射到Java对象上。

它的核心特性包括：

- **SQL映射**：通过XML或注解配置SQL语句，并将其映射到相应的Java方法。

- **动态SQL**：MyBatis支持通过标签（如`<if>`, `<foreach>`）生成动态SQL语句。

- **缓存机制**：提供了一级缓存和二级缓存的支持，一级缓存是基于`SqlSession`的本地缓存，二级缓存可以配置为全局缓存。

  

##### (2). 核心组件

- **SqlSessionFactory**：用于创建`SqlSession`对象，管理MyBatis与数据库的交互。`SqlSessionFactory`是MyBatis的入口，通常由`MyBatisConfig.xml`或Java代码进行配置。
- **SqlSession**：是MyBatis执行SQL语句的接口，负责与数据库交互、执行查询和更新操作。
- **Mapper接口**：MyBatis的Mapper接口用于定义数据访问操作，Mapper接口中的每个方法都对应一条SQL语句，可以通过XML配置或者注解实现映射。



##### (3). 工作原理

1. **加载配置文件**：MyBatis通过`SqlSessionFactoryBuilder`读取`mybatis-config.xml`文件，加载数据库连接信息、Mapper映射配置等。
2. **创建SqlSession**：`SqlSessionFactory`负责创建`SqlSession`，`SqlSession`是线程不安全的，用于执行数据库操作。
3. **执行SQL映射**：MyBatis根据Mapper文件（或注解）中的SQL语句，执行相应的查询或更新操作。
4. **结果映射**：MyBatis会将查询结果映射到Java对象（POJO）中，支持一对一、一对多等复杂的关联关系。



##### (4). MyBatis的缓存机制

- **一级缓存**：默认开启，基于`SqlSession`的缓存，同一个`SqlSession`中执行相同的SQL时可以从缓存中获取数据。
- **二级缓存**：基于`Mapper`级别的缓存，可以跨`SqlSession`共享数据缓存，需要在`Mapper.xml`中配置`<cache>`标签启用。



##### (5). 常见面试点

> MyBatis和Hibernate的区别？

MyBatis更加灵活，开发者可以手写SQL，适合复杂查询；Hibernate是全自动的ORM框架，更适合简单的CRUD操作。

> 如何使用MyBatis的动态SQL？

通过`<if>`，`<choose>`，`<foreach>`等标签，可以根据传入的参数动态生成SQL。









### 六、有大规模分布式系统开发、维护经验，有故障处理能力，源码级开发能力。

在大规模分布式系统的开发和维护中，具备故障处理能力和源码级开发能力是非常重要的。我们可以从分布式系统的架构设计、常见的技术栈和如何处理系统故障等方面来进行分析。



#### 分布式CAP定理

CAP定理（也称为Brewer's定理）是分布式系统设计中的一个核心理论，它描述了在分布式计算环境中一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）之间的权衡。CAP定理的内容可以总结为以下几点：

##### **CAP定理的三个核心概念**

1. **一致性（Consistency）**
   - 所有节点在同一时间看到的数据是一致的。换句话说，当一个节点更新数据时，所有其他节点都会看到相同的数据。
   - 在一个强一致性的系统中，任何读操作都能返回最新的写入结果。
2. **可用性（Availability）**
   - 每个请求都能在有限的时间内得到响应，不论请求是否成功（即可能返回旧数据）。
   - 在可用性高的系统中，系统能够处理大部分请求，即使某些节点出现故障。
3. **分区容错性（Partition Tolerance）**
   - 系统在发生网络分区（即节点之间的通信中断）时，仍能继续操作。
   - 分区容错性意味着即使部分节点无法互相通信，系统也不会完全崩溃。

##### **CAP定理的核心观点**

根据CAP定理，在分布式系统中，不能同时满足这三项特性：

- **强一致性 + 高可用性 + 分区容错性**：在网络分区发生时，系统必须选择一致性或可用性之一。
- **选择的权衡**：在设计系统时，开发者需要根据具体业务需求，在一致性、可用性和分区容错性之间进行权衡。

##### **CAP定理的应用场景**

- **CP系统（Consistency + Partition Tolerance）**
  - 这些系统在网络分区发生时会放弃可用性，确保一致性。例如：Zookeeper、HBase。
  - 在写入操作时，系统可能会阻塞以确保所有节点都保持一致。
- **AP系统（Availability + Partition Tolerance）**
  - 这些系统在网络分区时保持可用性，而牺牲一致性。例如：Cassandra、DynamoDB。
  - 即使部分节点无法访问，系统仍然会响应请求，但返回的数据可能不是最新的。

##### **面试中常见的问题**

1. **你如何在分布式系统中实现CAP原则的权衡？**
   - 可以结合具体案例，描述在业务需求变化时，如何选择一致性或可用性。
2. **在分布式数据库设计中，如何处理一致性与可用性之间的平衡？**
   - 可以讨论使用的技术手段，如使用分布式锁、事务机制、优化数据副本策略等。
3. **在处理网络分区时，你会如何设计系统以减少对用户的影响？**
   - 讨论如何使用缓存、最终一致性模型和降级策略来降低用户体验的影响。

##### **总结**

CAP定理是分布式系统设计的基石，理解它将有助于在面试中讨论如何设计高效的分布式系统，并处理一致性、可用性与分区容错性之间的权衡。如果有更深入的问题或者具体应用场景需要讨论，随时可以问！



#### **1. 大规模分布式系统的核心要点**

##### **1.1 架构设计**

大规模分布式系统的架构设计通常围绕以下几个核心原则：

- **可扩展性**：系统能够根据业务增长线性扩展，支持动态添加服务节点。
- **高可用性**：系统具备冗余设计，确保在部分节点或服务出现故障时，系统整体依然可用。
- **一致性与CAP原则**：在分布式系统中，一致性、可用性和分区容错性不能同时完全满足，系统架构需要在CAP原则之间做出权衡。例如，选择最终一致性或强一致性。
- **负载均衡与弹性伸缩**：分布式系统通常使用负载均衡器来均匀分配请求，确保系统在高并发场景下不会过载。弹性伸缩允许系统根据流量动态调整资源。

**示例**：微服务架构中，每个服务通过独立部署，实现了系统的模块化和高可扩展性，配合API网关和服务注册发现机制（如Eureka、Consul）来管理服务间的通信和负载均衡。



##### **1.2 数据一致性与分布式事务**

- 分布式事务

  ：分布式系统中的多个服务节点之间需要事务管理，以保证数据一致性。常见的分布式事务模型有：

  - **两阶段提交（2PC）**：经典的分布式事务管理方案，但缺点是在网络延迟或协调器故障时可能造成阻塞。
  - **补偿事务（TCC）**：分布式事务的补偿机制，允许在事务失败时回滚或进行补救。
  - **最终一致性**：对于大规模分布式系统，很多时候选择弱一致性模型，允许短暂的不一致，最终通过消息队列等机制达到一致性。

**示例**：在电商平台中，订单处理涉及多个微服务（库存、支付、物流等），通过Saga模式来协调跨服务的事务，保证在订单失败时能够正确回滚。

#### **2. 分布式系统常用的技术栈**

##### **2.1 微服务框架**

- **Spring Cloud**：广泛使用的微服务框架，提供了服务发现、负载均衡、配置管理、断路器等功能。
- **Dubbo**：高性能的RPC框架，支持分布式服务治理，适合高并发的系统。

##### **2.2 分布式缓存**

- **Redis**：作为分布式缓存系统，Redis可以提高系统响应速度，并减少数据库的压力。支持数据持久化和主从复制，能够在集群模式下实现高可用性。

  **常见问题**：

  - **缓存击穿**：当大量并发请求同时访问缓存未命中的热点数据时，可能会导致数据库瞬间压力激增。通过加锁机制或提前预热缓存可以避免这一问题。
  - **缓存雪崩**：如果缓存大量数据同时失效，会引发大量请求直接打到数据库。解决方案是对缓存失效时间进行随机化，避免缓存同时失效。

##### **2.3 分布式消息队列**

- **Kafka**：高吞吐量的分布式消息系统，用于数据流处理、事件驱动架构，支持顺序消费和分区。

  **示例**：在订单处理系统中，通过Kafka将订单生成、支付、物流等服务解耦，确保系统各部分独立运行。

  

#### **3. 故障处理与监控**

##### **3.1 故障处理**

分布式系统故障处理的核心在于具备快速的检测、定位和恢复能力：

- **熔断与降级**：使用熔断机制（如Hystrix或Resilience4j），当某个服务出现故障时，自动触发降级策略，将流量引导到备用服务或返回默认值，避免整个系统的雪崩效应。
- **自动重试与限流**：在调用失败时，自动进行重试。限流机制可以防止过多的请求涌入导致系统崩溃。

##### **3.2 监控与日志**

监控和日志在故障处理时至关重要：

- **分布式追踪**：使用工具如Zipkin或Jaeger进行分布式追踪，记录每个请求经过的服务链路，帮助快速定位故障点。
- **日志聚合**：通过ELK（Elasticsearch, Logstash, Kibana）或Prometheus+Grafana等技术实现日志的收集、监控和分析，实时掌握系统的健康状态。

**示例**：在微服务系统中，部署Prometheus用于监控服务的CPU、内存使用情况，并结合Alertmanager设置告警策略。当某个微服务的响应时间过长或错误率飙升时，系统会自动发送告警。



#### **4. 源码级开发能力**

对于分布式系统的源码级开发能力，需要具备阅读和修改大型开源项目源码的能力，以及理解其底层实现。

- **Spring源码**：深入理解Spring的核心机制（如Bean的生命周期、依赖注入、AOP的实现原理）。
- **MyBatis源码**：了解MyBatis的SQL执行流程、缓存机制和插件机制，通过自定义插件扩展功能。
- **Netty源码**：如果系统涉及到高并发网络通信，理解Netty的NIO框架实现，特别是其事件驱动模型和高效的线程池管理机制。

#### **面试中的常见问题**

1. 如何处理分布式系统中的数据一致性问题？
   - 结合CAP定理，描述如何在实践中选择最终一致性或强一致性。
2. 在大规模分布式系统中如何应对服务宕机的情况？
   - 讨论熔断、自动重试、降级等策略，以及如何利用监控工具实现快速响应。
3. 如何优化分布式系统的性能？
   - 从缓存、数据库分片、负载均衡等角度讨论性能优化。









面经
---



### 一、主管+技术总监混合面

![image-20241023183144721](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202410231831829.png)





>先做个简单的自我介绍吧

面试官你们好：

​	我叫李浩，现就职于win.d的FTG-机构移动2部。从21年10月开始实习后来转正工作到现在。主要从事的是Java后端的岗位工作。



>有用过Linux比较高级的命令有哪些？

平时用到命令主要在于日志文件操作(例如grep筛选，tail查看等)、系统操作(例如查看内存、磁盘大小、进程占用空间，kill进程)等

比较高级的话主要有通过抓包的方式验证链路，排查网络传输异常等问题。



>JVM的类加载的流程？

JVM加载.class文件时先会有验证文件是否符合JVM规范、然后进行加载到方法区….



>主要说一下ClassLoad？

类加载器从上至下主要有三种：

- 启动类加载器
- 扩展类加载器
- 应用加载器

遵循双亲委派模型，主要加载流程为：

首先有最底层加载器进行加载，如果加载不了，则会交由父类加载器进行加载…



>双亲委派能被打破吗？

可以，例如Tomcat等





>客户端与服务端已经建立连接，此时客户端发送包之后，服务端并没有返回ACK，此时客户端会做什么？

会进行超时重传，之后会断开连接。



























