> 1.（单选）类应该如何暴露数据给外部使用（10分） 

A. 定义数据成员为public 

B. 定义数据成员为private,通过成员函数返回数据的拷贝 

C. 定义数据成员为private,通过成员函数返回数据的指针或引用



**B. 定义数据成员为private**，通过成员函数返回数据的拷贝。

这种方式允许类将数据成员设置为私有（private），通过成员函数（如 getter 函数）返回数据的副本，而不是直接暴露数据本身。这样做的好处是可以更好地控制对类内部数据的访问，确保数据的安全性和封装性，防止外部直接修改类的数据。



> 2.（单选）父类如何禁止子类直接访问父类的成员变量（10分） 

A. 定义成员变量为public 

B. 定义成员变量为protected 

C. 定义成员变量为private



**C. 定义成员变量为private。**

将成员变量定义为私有（private）可以限制子类直接访问父类的成员变量。私有成员只能在声明它们的类内部访问，子类无法直接访问私有成员变量，而只能通过父类提供的公共接口（例如公共方法或函数）来间接访问或修改这些私有成员变量的值。





> 3.（多选）多态通过什么来实现（10分） 

A. 继承 

B. 子类重写父类的方法 

C. 封装 

D. 父类方法定义为虚函数



多态实现的关键是：

**B. 子类重写父类的方法**：多态性允许子类覆盖（重写）继承自父类的方法，使得相同的方法可以在不同的子类中有不同的行为。子类可以对继承的方法进行重新定义，实现自己特定的行为。

**D. 父类方法定义为虚函数**：在 C++ 中，实现多态的一种常用方式是将父类中的方法声明为虚函数。通过在父类中声明虚函数，子类可以覆盖这些函数并提供特定于自己的实现。这样，程序在运行时可以根据对象的实际类型来调用相应的方法，实现多态性。





> 4. （多选）对于多态，理解正确的有（10分） 

A. 调用父类还是子类的方法是运行时确定的 

B. 调用父类还是子类的方法是编译时确定的 

C. 声明为父类的子类对象，运行时会自动调用子类的方法



**A. 调用父类还是子类的方法是运行时确定的。**

**C. 声明为父类的子类对象，运行时会自动调用子类的方法。**

在多态中，调用方法的具体实现是在运行时确定的。编译器在编译时无法确定调用的是父类还是子类的方法。当使用父类指针或引用指向子类对象时，实际调用的方法取决于指向的对象的实际类型，而不是指针或引用的类型。因此，会根据对象的实际类型来确定调用的是子类的方法。





> 6. （多选）对面向对象的理解正确的有（10分） 

A. 以对象为中心 

B. 提高开发工作的重用行 

C. 降低重复工作日量 

D. 建立在面向过程等其他编程技术之上



**A. 以对象为中心。**

**B. 提高开发工作的重用性。**

**C. 降低重复工作量。**

面向对象编程（OOP）以对象为中心，通过封装、继承和多态等概念，提高了代码的重用性和可维护性，降低了重复工作量。相对于面向过程等其他编程范式，面向对象编程更侧重于组织和管理数据、方法，并强调了数据和行为的统一性，有助于提高代码的可读性和扩展性。





> 7. （是非）程序给类分配分配内存空间。

A. 对

在大多数编程语言中，类是对象的模板，当实例化（创建）一个类的对象时，会分配内存空间给这个对象，以存储其成员变量和方法。这些成员变量和方法在类中被定义，但是只有在实例化对象时才会真正分配内存空间。





> 8. （是非）可以创建抽象类的实例

B. 错

抽象类是不能被直接实例化（即不能创建抽象类的对象）的。抽象类是用来作为其他类的父类，并且可能包含未实现的抽象方法。抽象类存在的主要目的是为了被子类继承和实现其抽象方法，而不是被实例化。若要使用抽象类中的方法，需要创建一个具体的子类并实现其中的抽象方法，然后可以创建该子类的对象。





> 9. （是非）类中的成员变量应该定义为public，方便外部使用

B. 错

类中的成员变量应该根据需要和设计的目的进行恰当的封装。通常情况下，最好将成员变量定义为私有（private），并通过公共的方法（如 getter 和 setter 方法）来控制对这些变量的访问和修改。这种做法遵循了封装的原则，可以隐藏类的内部实现细节，防止直接访问和意外修改成员变量，从而提高了代码的安全性和可维护性。





> 10. （是非）封装实现了信息隐藏。



A. 对

封装是面向对象编程中的一个重要概念，它通过将数据和方法封装在类的内部，对外部隐藏了对象的实现细节。这种隐藏细节的做法实现了信息隐藏，使得外部无法直接访问和修改对象的数据，而只能通过对象提供的公共接口（方法）来进行操作。这种方式有助于提高代码的安全性和可维护性，并降低了耦合度，使得程序更加健壮和易于理解。