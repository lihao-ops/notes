操作日志优化流程
===





一、增加角色信息实现详细流程
---

1. 在原有`tb_sys_user_operation`表中添加角色字段 `role`，考虑后续表数据量会比较大，这里将其字段类型定义成`tinyint`这种占空间小的类型。
2. 通过此`role`字段匹配到角色表`tb_sys_role`的`role_name`字段值返回。
3. 修改对应代码逻辑，准备增加`role`字段sql脚本，全部升级主站测试无误。







二、SQL层面优化实现详细流程：
---

##### 1.表结构

```sql
USE `wstock_crmservice_db`;

CREATE TABLE `tb_sys_user_operation` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键自增id',
  `account_id` varchar(15) NOT NULL COMMENT '用户名',
  `role` tinyint(4) NOT NULL DEFAULT '1' COMMENT '角色：0.管理员,1.用户(默认)',
  `start_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '请求开始时间,默认当前时间',
  `load_time` int(11) NOT NULL COMMENT '接口请求耗时(ms)',
  `method` tinyint(4) NOT NULL DEFAULT '0' COMMENT '请求方式：0.未知(默认),1.GET,2.POST,3.DELETE',
  `description` varchar(100) DEFAULT NULL COMMENT '动作描述',
  `url` varchar(100) DEFAULT NULL COMMENT '请求接口url',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `idx_account_start_time_role` (`account_id`,`start_time`,`role`),
  KEY `idx_start_time` (`start_time`)
) ENGINE=InnoDB AUTO_INCREMENT=1168030 DEFAULT CHARSET=utf8 COMMENT='用户操作记录表';
```



其中`tb_sys_role`表中数据量只有不超过100行



```sql
#创建联合索引(使用account_id筛选且常用,使用start_time排序(单独则建索引可以直接建start_time DESC),使用role进行left join)
CREATE INDEX idx_account_start_time_role ON `tb_sys_user_operation`(`account_id`,`start_time`,`role`);


#原始语句(子句嵌套)
SELECT * FROM( 
 SELECT ( 
  SELECT COUNT(1) FROM ( SELECT id FROM `tb_sys_user_operation` WHERE 1=1 LIMIT 1000 ) 
  AS t ) AS num, 
 `account_id`, `role`, `start_time`, `load_time`, `method`, `description`, `url`,r.`role_name` FROM `tb_sys_user_operation` u 
LEFT JOIN `tb_sys_role` r ON r.`role_id` = u.`role` 
WHERE 1=1 
ORDER BY start_time 
DESC LIMIT 1000) AS T 
LIMIT 0,20;

#优化后的sql语句
#1.增加区间查询替换limit 1000,尽量避免使用子句,以免查询不走索引
SELECT (
 SELECT COUNT(id) 
 FROM `tb_sys_user_operation` 
 WHERE 1=1 AND account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` &lt '2023-12-01' ) 
 AS num,`account_id`, `role`, `start_time`, `load_time`, `method`, `description`, `url`,r.`role_name` 
FROM `tb_sys_user_operation` u 
LEFT JOIN `tb_sys_role` r ON r.`role_id` = u.`role` 
WHERE 1=1 AND account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` &lt '2023-12-01' 
ORDER BY start_time DESC 
LIMIT 0,20;
```



##### 2.优化效果说明

在 MySQL 中，`EXPLAIN` 命令可以用来分析 SQL 查询语句的执行计划。在执行计划中，`type` 字段表示 MySQL 在查询过程中所使用的访问方式，常见的有以下几种：

- `const`：在查询过程中，MySQL 只需要读取一行数据就可以找到满足条件的记录，这通常是在使用主键或唯一索引进行查询时出现的访问方式。
- `eq_ref`：在查询过程中，MySQL 使用了连接操作（JOIN），并且在连接操作中使用了一个索引来匹配查询条件，这通常是在使用主键或唯一索引进行关联查询时出现的访问方式。
- `ref`：在查询过程中，MySQL 使用了连接操作，并且在连接操作中使用了一个非唯一索引来匹配查询条件，这通常是在使用普通索引进行关联查询时出现的访问方式。
- `fulltext`：在查询过程中，MySQL 使用了全文索引来匹配查询条件，这通常是在使用 `MATCH AGAINST` 关键字进行全文搜索时出现的访问方式。
- `all`：在查询过程中，MySQL 执行了全表扫描的操作，即需要遍历表中的每一行数据，这通常是在没有索引或者无法使用索引进行查询时出现的访问方式。
- `range`：在查询过程中，MySQL 使用了索引的范围扫描来匹配查询条件，这通常是在使用普通索引进行范围查询时出现的访问方式。

根据不同的访问方式，可以对查询语句进行优化，从而提高查询性能。





##### 2.原有效率

查询效率非常低，查询翻页达到3S以上。

全部为全表扫描效率极低！





##### 3.加了联合索引

只有其中一条子句走了index，其余全为ALL全表扫描，优化程度极低



因其中多重子句查询

```text
子查询并不一定会导致查询不走索引，但使用子查询时需要注意一些细节，否则可能会导致查询性能下降，例如：

1. 子查询返回的数据量过大。如果子查询返回的数据量过大，会导致 MySQL 无法使用索引来优化查询，从而导致查询性能下降。为了避免这种情况，建议尽可能缩小子查询返回的数据量，例如使用 LIMIT 子句限制子查询返回的行数。

2. 子查询使用了不同的索引。如果子查询使用了不同的索引，可能会导致 MySQL 无法使用父查询中的索引来优化查询，从而导致查询性能下降。为了避免这种情况，建议尽可能使用相同的索引来优化父查询和子查询。

3. 子查询使用了多个嵌套语句。如果子查询使用了多个嵌套语句，可能会导致查询性能下降。为了避免这种情况，建议尽可能简化查询语句，避免使用过多的嵌套语句。

总之，使用子查询时需要注意查询语句的复杂度，尽可能缩小子查询返回的数据量，使用相同的索引来优化父查询和子查询，以及简化查询语句，避免使用过多的嵌套语句。这样可以避免子查询导致查询性能下降的情况。
```





> 优化SQL语句后使用SQLyog中执行`explain`查看语句执行效率

1. table u对应语句查询type = ref且使用了idx_account_start_time_role
2. table r对应语句查询type = ALL，全表查，考虑此表共4条数据,且后续数据量并不大,无需创建索引
3. tb_sys_user_operation对应语句查询type = range且使用了idx_account_start_time_role



##### 4.优化效果并不佳

> 在实际环境发现执行查询还是超过了1s响应，优化效果并不佳

已为`account_id`, `role`, `start_time`创建了联合索引，其中 `tb_sys_role`整表数据只有4条，且`role`字段已创建索引，为何优化效果还是不佳？

```sql
SELECT (
   SELECT COUNT(id) 
   FROM `tb_sys_user_operation` 
   WHERE 1=1 AND account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` &lt '2023-12-01' ) 
   AS num,`account_id`, `role`, `start_time`, `load_time`, `method`, `description`, `url`,r.`role_name` 
FROM `tb_sys_user_operation` u 
LEFT JOIN `tb_sys_role` r ON r.`role_id` = u.`role` 
WHERE 1=1 AND account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` &lt '2023-12-01' 
ORDER BY start_time DESC 
LIMIT 0,20;
```



###### 原因

虽然已经为 `account_id`, `role`, `start_time` 创建了联合索引，但是在这个查询语句中，`tb_sys_user_operation` 表仍然需要进行全表扫描，而不是使用索引进行优化：

1. 这是因为**在查询条件中使用了 `LEFT JOIN` 操作，并且涉及了 `tb_sys_role` 表**。
2. 因为 `tb_sys_role` 表的数据只有 4 条，所以在这个查询中，MySQL 可以使用 `tb_sys_role` 的主键索引来快速定位到对应的记录，
3. 但是在 `tb_sys_user_operation` 表中，由于涉及到了多个列的查询条件，而这些列的索引并不是联合索引的前缀，所以需要进行全表扫描。









##### 5.怎么再优化呢?

为了优化这个查询：

1. 可以考虑将 `tb_sys_role` 表的数据与 `tb_sys_user_operation` 表进行关联查询，以避免使用 `LEFT JOIN` 操作，进而提高查询性能。

   1. 为什么要避免使用`LEFT JOIN`？

   2. 虽然 `LEFT JOIN` 操作可以返回左表中所有记录以及右表中匹配的记录，但是它也有一些缺点：

      1. **性能较差**：`LEFT JOIN` 操作需要对左表和右表进行全表扫描，并且需要进行大量的数据匹配操作，因此在数据量较大时，性能会受到较大影响。

      2. **可能导致数据重复**：由于 `LEFT JOIN` 操作会返回左表中所有记录，因此在右表中匹配到多条记录时，会导致左表中的记录重复出现，从而使查询结果产生冗余数据。

      3. **可能导致结果集不准确**：由于 `LEFT JOIN` 操作返回的结果集中包含了左表中所有记录，而不仅仅是匹配的记录，因此在统计数据时可能会导致结果集不准确。

      因此，在实际的开发中，应该尽量避免使用 `LEFT JOIN` 操作，而是尽可能使用 `INNER JOIN` 操作或者其他更合适的连接方式来进行数据查询。

      如果确实需要使用 `LEFT JOIN` 操作，可以考虑对查询条件和索引进行优化，以提高查询性能和准确性。

      

2. 同时，可以考虑调整查询条件，将较为复杂的查询条件放到联合索引的前面，这样可以更好地利用索引进行查询优化。

3. 另外，可以考虑对 `tb_sys_user_operation` 表中的其他查询条件进行索引优化，以进一步提高查询性能。



> 实际优化

`tb_sys_role` 表的主键为 `role_id`，可以将查询语句改写为：

```sql
SELECT (
   SELECT COUNT(id) 
   FROM `tb_sys_user_operation` 
   WHERE account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` < '2023-12-01' ) 
   AS num,`account_id`, `role`, `start_time`, `load_time`, `method`, `description`, `url`,r.`role_name` 
FROM `tb_sys_user_operation` u 
JOIN (SELECT `role_id`, `role_name` FROM `tb_sys_role`) r ON r.`role_id` = u.`role` 
WHERE account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` < '2023-12-01' 
ORDER BY start_time DESC 
LIMIT 0,20;
```

这个查询语句中：

1. 使用了子查询的方式来查询满足条件的记录数，并将其命名为 `num`。
2. 在主查询中，使用 `JOIN` 操作将 `tb_sys_user_operation` 表与 `tb_sys_role` 表进行关联，以避免使用 `LEFT JOIN` 操作。
3. 同时，在 `tb_sys_role` 表中只查询了 `role_id` 和 `role_name` 两个字段，以避免不必要的数据扫描。
4. 在查询条件中，将较为复杂的查询条件放到了联合索引的前面，以便更好地利用索引进行查询优化。
5. 最后，使用 `ORDER BY` 和 `LIMIT` 子句对查询结果进行排序并限制返回记录数。



>优化前后对比

改完之后在SQLyog对此语句执行explain后发现在`tb_sys_role`这条数据的filtered字段值，从100.00 ——> 25.00

说明：

`filtered` 字段表示查询时通过索引过滤掉的数据所占比例。值越小表示索引的过滤效果越好，也就是查询时需要扫描的数据量越小，性能越好。

在这个查询语句中，使用子查询的方式来查询 `tb_sys_role` 表的数据，从而能够更好地利用索引进行过滤。因此，**经过优化后，`tb_sys_role` 表中被过滤掉的数据占比减少了，`filtered` 字段的值也相应减小。这说明优化后的查询语句能够更好地利用索引**，从而提高了查询性能。







##### 6.再优化

**为什么优化后，请求耗时还是超过了1000ms？**

在业务上考虑：

1. 是实际环境中使用account_id,role,start_time三字段联合索引的情况还是少数(审查此日志记录时会用到，这样根据account_id再去查效果确实还不错)——查某个account_id在某个start_time对应的时间区间内的数据
2. 但只是指定时间区间筛选，不筛选account_id时候就特别慢了(3335ms)
3. 故此**还需要为`start_time`字段单独再建立索引**

单独为 `start_time` 字段创建索引之后，查询语句可以利用这个索引快速定位符合条件的数据，从而提高查询性能。**如果 `start_time` 字段的选择性较高，那么单独为它创建索引的效果往往比联合索引更好，因为联合索引可能会将 `start_time` 字段放在后面，导致索引的效率降低**。

在这个查询语句中，由于 `start_time` 字段的过滤条件非常频繁，因此单独为它创建索引可以提高查询效率。而在之前的索引设计中，虽然 `start_time` 字段参与了联合索引的设计，但是由于 `account_id` 和 `role_id` 的选择性较低，导致索引的效率并不高，无法快速定位符合条件的数据，从而影响了查询性能。



于是：由于 `start_time` 字段的选择性较高，因此可以为其单独建立索引，如下所示：

```sql
ALTER TABLE `tb_sys_user_operation` ADD INDEX `idx_start_time` (`start_time`);
```

优化后请求耗时：105ms





##### 7.再优化

使用窗口函数 `COUNT(*) OVER()` 可以避免使用子查询来计算 `num` 字段的值，从而提高查询效率。窗口函数可以在不破坏原有查询结果的情况下，对查询结果进行二次聚合计算

```sql
SELECT (
   SELECT COUNT(*) 
   FROM `tb_sys_user_operation` 
   WHERE account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` < '2023-12-01' ) 
   AS num,`account_id`, `role`, `start_time`, `load_time`, `method`, `description`, `url`,r.`role_name` 
FROM `tb_sys_user_operation` u 
JOIN (SELECT `role_id`, `role_name` FROM `tb_sys_role`) r ON r.`role_id` = u.`role` 
WHERE account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` < '2023-12-01' 
ORDER BY start_time DESC 
LIMIT 0,20;
```

count(id)改成了count(*)有什么变化吗？优化了什么地方?



在上述查询语句中，将 `COUNT(id)` 改为 `COUNT(*)` 不会对查询结果产生影响，因为 `COUNT(*)` 和 `COUNT(id)` 都会计算查询结果集中的行数。但是，使用 `COUNT(*)` 有几个优势：

1. 更简洁：`COUNT(*)` 比 `COUNT(id)` 更简洁，因为它不需要指定任何列名或表达式，而是直接计算整个结果集中的行数。
2. 更有效率：`COUNT(*)` 比 `COUNT(id)` 更有效率，因为它避免了在计数之前对每个行进行列值的检查。使用 `COUNT(id)` 时，数据库需要检查每个行的 `id` 列是否为 `NULL`，而使用 `COUNT(*)` 时，数据库只需要检查每个行是否存在即可。
3. 更通用：`COUNT(*)` 也比 `COUNT(id)` 更通用，因为它可以用于计算任何结果集的行数，而不需要指定任何列名或表达式。

总之，将 `COUNT(id)` 改为 `COUNT(*)` 可以使查询更简洁、更有效率、更通用。



>还可以将count(*) 改为count(1)常量

将 `COUNT(*)` 改为 `COUNT(1)` 对查询性能的影响非常小，因为在大多数数据库管理系统中，它们的执行方式是相同的。

虽然 `COUNT(*)` 和 `COUNT(1)` 都可以用来计算行数，但是在某些情况下，使用 `COUNT(*)` 可能会比 `COUNT(1)` 稍微慢一些。这是因为 `COUNT(*)` 不同于 `COUNT(1)`，它需要检查行是否存在，而 `COUNT(1)` 不需要检查任何列，只需要检查行是否存在。但是，这种性能差异通常非常小，只有在处理大量数据时才可能有所体现。

因此，将 `COUNT(*)` 改为 `COUNT(1)` 不会有很大的性能提升，但它可以使查询更加清晰明了，因为 `COUNT(1)` 可以看作是一种约定俗成的写法，表示计算行数时不需要考虑任何列的值。

```sql
SELECT (
   SELECT COUNT(1) 
   FROM `tb_sys_user_operation` 
   WHERE account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` < '2023-12-01' ) 
   AS num,`account_id`, `role`, `start_time`, `load_time`, `method`, `description`, `url`,r.`role_name` 
FROM `tb_sys_user_operation` u 
JOIN (SELECT `role_id`, `role_name` FROM `tb_sys_role`) r ON r.`role_id` = u.`role` 
WHERE account_id='wind1' AND `start_time` >= '2021-11-30 16:08:30' AND `start_time` < '2023-12-01' 
ORDER BY start_time DESC 
LIMIT 0,20;
```







##### 8.还能优化吗？

当然可以，在实际使用中仍然可能存在改进的空间。以下是一些可能的优化方向：

1. 分页查询优化：这个查询语句使用了 `LIMIT` 子句来限制返回记录数，但是如果数据量较大，分页查询仍然可能对性能产生影响。可以考虑使用游标或者其他方式进行分页查询，以提高查询性能。
2. 索引优化：这个查询语句使用了多列索引来加速查询，但是如果索引的覆盖度不够高，仍然可能导致性能问题。可以考虑使用单列索引或者调整索引顺序来优化查询效率。
3. 数据库结构优化：如果查询语句需要对大量数据进行聚合计算，那么可能需要对数据库结构进行优化。可以考虑使用冗余字段、汇总表或者其他方式来加速数据计算。
4. 缓存优化：如果这个查询语句需要频繁执行，那么可以考虑使用缓存来加速数据访问。可以使用 Memcached 或者 Redis 等缓存技术来缓存查询结果，以减少数据库访问次数。
5. 或者分库、分表等操作(涉及主键id迁移后新增不可重复等问题)

总之，在实际使用中，需要根据具体情况进行不同的优化，以提高查询性能和准确性。