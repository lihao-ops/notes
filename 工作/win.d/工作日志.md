 nuzar
===



21/12.20
---



### 需求

1. 完成公司内部 部门管理 功能已有用户表sys_users
2. 租户表 sys_tenants
3. 部门下设置 管理岗、普通岗和实习岗位
   1. 完成客户内部部门管理功能，对外接口提供树形结构
   2. 完成人员和部门的绑定，并分配岗位级别，默认普通岗



```yaml
spring:
  datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://10.166.0.37:5432/saasdb
    username: authorization
    password: auth0NZ  
数据库
```





> 表目录位置

![image-20211220104128070](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202112201041343.png)





>查询用户时，用户查询使用sql

```sql
默认为0,是普通岗
实习岗位为1;
管理岗位为2;

```



```sql
select * from sys_user_admin where enabled = (
    select * from sys_users where id = #{id}
);
```







思路：

1. 通过主键id关联查询sys_users + sys_tenants中的所有内容(sys_tenants.name = sys_users.name);
2. 创建对应的sys_user_admin表，表中有enabled中字段：
   1. 0：表示普通岗(默认)
   2. 1：表示实习岗
   3. 2：表示管理岗
3. 通过name字段来查询相关人名所代表的岗位的权限对应enabled字段所对应的内容为相应三个字段显示内容
4. 修改也是一样的

![image-20220521020441204](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/202205210204422.png)





department表

默认值是0





>需求：在实际工作中有外包，或者临时在其它部门任职的情况，也就是说存在一个人对应多个部门的情况。

解决方法：
设立中间表(sys_users_departments)表中添加出来id和name等几个字段对应出来的多出了部门的关系，业绩是说name字段允许重复



1. 两个主要字段：
   1. name则对应sys_users中的名称
   2. departmentId对应sys_department中的departmentId
   3. 此表中name可以重复，也就是说，在不同的departmentId允许重复出现一个name对应多个departmentId。
2. 为了规范表字段，后面剩余表字段也需要重新分配

```sql
alter table sys_departments
	add create_user varchar(128);

alter table sys_departments
	add update_time timestamp;

alter table sys_departments
	add update_user varchar(128);

alter table sys_departments
	add version numeric;

alter table sys_departments
	add account varchar(128);
```



















Win.d
===







工作日志
---







### 代码规范

组长建议：尽快安装阿里巴巴代码规约插件

![image-20220511161902852](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205111619226.png)

![image-20220521020441204](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/202205210204431.png)









### 系统





#### 概况图



##### 主要系统

> 公司主要系统服务

![image-20220421181046628](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204211810862.png)







##### 开发站与测试站cloud使用





###### cloud是什么？

内存型数据库，除了行情、新闻以外的金融数据(WFT)。



>入参

1. report
2. WSS
3. WSD







> 怎么用？

![image-20220421183511405](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204211835608.png)







###### pr

>是什么？

pr(power Report)是cloud的缓存(Redis)

![image-20220421183709950](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204211837195.png)











#### expo



###### expo构建过程

1. 服务端B接收由客户端A从expo传递过来的前端参数
2. 打开本地配置文件夹中的/etc/expoConfig.xml –> 查看此项目的编号
   1. APPClass Value=“专属编号”
3. 编写接口信息到apiDefine配置文件中
   1. 注：部署的时候还需要再svn对应目录中添加一遍
   2. 专属于方法对应方法的commandID
4. 定义Expo基础继承类`ExpoBaseService`
   1. 初始化一个key(定义的commadId),value(加了expo定义注解的类名和方法名)。
   2. 接下来就是验证的步骤：
      1. 验证方法是否加了`@commandDefinition`注解不是就不扫
      2. 验证方法是否有效，验证是否为空。无效也不添加
5. cmid注解定义
   1. 定义此注解用来表示是走expo协议的方法，标识要被上述基础继承类加载到map中
   2. 记得一定要在对应方法中加上此注解，并填写好注解值
6. 监听器：
   1. expo总线回调找到对应commandId中的集中对应方法
   2. 也就是你客户端发送消息(带有commandId)
   3. 然后到总线，总线负责帮你找到对应此id的方法。
   4. 去调用它，把它的返回结果集传输给你







###### 客户端

1. 服务端param参数处理完毕返回给客户端(resultCode自定义消息(例如code(判断是否成功) + massage(返回结果集)

1. 在另外一个项目中定义客户端连接expo，找到对应commandid的方法
2. 传入前端输入的处理完毕的参数
3. 调用对应服务端的接口方法
4. 通过expo传输拿到结果集



###### 服务端

1. 通过总线传来的前端参数
2. 正常定义相关的service、实现类、mapper
3. 此部分没有什么不同
4. 调用Servce返回出去结果集通过expo传输给客户端







































### 管理平台



#### 配置新加页面

登录管理平台

![image-20220512185300630](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121853920.png)



> 有提示框点击一下，再点击进入资源输入

![image-20220512185352891](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205210231146.png)



再添加子菜单

![image-20220521023103674](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205210231820.png)

![image-20220521023055603](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205210230772.png)



![image-20220512185621047](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121856309.png)



![image-20220512185902087](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121859322.png)

![](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121931771.png)

>有子菜单

![image-20220512190055768](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121900015.png)

![image-20220512190108692](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121901919.png)



点击保存

![image-20220512190157298](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121901501.png)



![image-20220512190708329](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121907542.png)





>权限授权

![image-20220512191310627](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121913883.png)



>刷新权限后退出再登录一下即可

















### 部署







#### 开发站部署





##### 具体流程

>1.登录xshell

- 10.102.17.238

- 账号：root
- 密码：abcd1234

>步骤

```bash
#1.进入目录
cd /wind/Wind.Wstock.DataShareService/webapps/

#2.查看是否已存在jar包
ll

#3.存在则删除当前jar包
rm 名称.jar

#4.也将项目打包的jar包移入到这里
rz

#5.运行jar包
/wind/Wind.Wstock.DataShareService/run.sh

#6.查看运行日志
tail -100f /wind/Wind.Wstock.DataShareService/logs/console.log


#查看历史输入
history

```







#### 主站部署



##### 明确

首先要明确一定，当需要在主站部署项目的代码的时候。

这一套流程一定是要**先在测试站**走完之后才可以进入到主站。



##### 具体流程



>准备工作

例如DataShare部署

1. 申请Fuse指标(熔断服务)——解耦作用
   1. 时间为1-2个工作日
2. share平台配置接口信息——获取配置文件等



>总流程

![image-20220421182828488](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204211828731.png)









###### 合并到release分支中

> 我们在修改代码的时候实际上是在dev分支中对代码进行修改的。

此时我们需要将修改后的代码合并的dev中。

1. 首先来到项目目录下
2. dev 和release目录都有的路径下
3. 点击svn-merage-command.bat进行迁移合并到release(需要权限)

![image-20220424153718828](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241537064.png)

注意：==一定要点开对应每个修改的文件，仔细**检查修改**的内容是否正确，然后**编写注释**并提交==

提交在此文件夹右键提交





>合并之后必须要在release分支再提交一遍代码到版本库



注意：检查代码并填好备注信息









###### 申请fuse指标



>在万得之家搜索FUSE备案申请

1. 点击下载模板

   <img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241540774.png" alt="image-20220424154020583" style="zoom:50%;" />

2. 在此申请表中填写相关信息(为了方便可直接打开接口文档对应数据填入)

输入说明：

| 接口类型                  | 指标类型                                   | 描述       | 类型  | 正式参数 | 适用产品类型   |
| ------------------------- | ------------------------------------------ | ---------- | ----- | -------- | -------------- |
| 服务端http/客户端则另一种 | 项目别名+大mapping+小mapping(注意都要大写) | 龙虎榜首页 | count | 500.24   | 设置为系统指标 |

![image-20220424161638260](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241616436.png)





注意：**能批量一起申请就一起申请**，后续人员所需工作量也会相应减少



































##### 软件仓库



###### 合并到release

> 1.当将项目中dev代码合并到release分支中，并且检查、备注、提交之后：



万得之家——>研发工具——>软件仓库

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241706978.png" alt="image-20220424170653753" style="zoom:50%;" />

此步骤相当于在本地打包项目成jar包形式。



###### 进入

> 进入:找到所需与所需部署项目相同的模块点击

![](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241709234.png)





###### 构建

>进入页面后点击构建

![image-20220424171216455](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241712668.png)





###### 沿用默认

>此是一般沿用默认的参数点击构建即可

![image-20220424162357324](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241623542.png)





###### 等待构建

等待过程一般为5-10分钟。

![image-20220424171507959](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241715173.png)

等待构建成功即可

![image-20220424171751843](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241717057.png)









###### 集成

>按需执行
>
>![image-20220512162702706](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121627961.png)





> 为什么需要集成呢？

因为程序进行部署除了主要的jar包以外，其他的一些配置文件也需要一起部署上去。

![image-20220424172325685](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241723942.png)



>在对应名称后面点击版本集成

![image-20220425094947826](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204250950151.png)

![image-20220424172648401](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241726642.png)

输入版本信息(可任意)：之后点击确定











>等待左上角刚刷出来的版本

![image-20220424172909777](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241729046.png)

注意：记住这个版本号



>在软件仓库配置















##### 测试站部署



###### 进入部署

>经过上述流程之后，再进入到测试站部署

点击进入部署系统

![image-20220424175323674](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241753883.png)

如果到此步，有未完成的测试站任务。会提示！

要先把任务结束。







###### 结束未完成任务

两种结束方式

>1.部署流程到此就希望结束了，无需再到主站

![image-20220424175800412](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241758652.png)



>2.部署流程希望到此终止，需要进入到主站再次此套流程部署。

![image-20220424175635576](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241756812.png)

主要这里要上传一个空文件，如果此代码为项目核心代码，此步骤就显得尤为重要！！！











###### 部署参数

>测试站部署



![image-20220424180300704](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241803927.png)

填入参数

![image-20220424180054362](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241800561.png)

![image-20220512163110110](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121631305.png)











###### 发起部署

>完成上述信息填写之后点击发起部署



然后对应项目点击查看实例

![image-20220424180557543](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241805776.png)









>勾选实例之后点击立即部署

![image-20220424180717444](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241807665.png)







> 输入部署

![image-20220424180803693](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241808877.png)













###### 判断部署状态

>等到显示状态为部署成功之后才判定部署成功

此过程中可以**按Enter键刷新**

![image-20220424180919538](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204241809755.png)











##### 主站部署

![image-20220505153039785](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051530016.png)







> share项目比较复杂，此次为share部署主要流程，其它项目只会更简单。





###### 登陆主站

![image-20220505171850327](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051718502.png)



>其它服务无需在此平台配置

此步骤开始前，请确认在测试站的对应位置已经填写过此信息和执行过此步骤

>1.添加接口信息

![image-20220505172042041](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051720266.png)





>2.填写列表值

![image-20220505175340737](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051753928.png)

点击提交：

![image-20220505175422418](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051754589.png)



显示保存成功即可



>3.再次检查相关信息是否有误

![image-20220505175549777](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051755974.png)



1. 注意：填写完成之后或者编辑修改之后一定要：
2. 勾选刚刚操作过的几个接口
3. 然后点击批量上架才能在接下来的发布网关生效

![image-20220512110553041](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121105262.png)





>4.测试

主站为https(443端口)，测试站为http(81端口)

![image-20220505180336784](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20220505180336784.png)











>5.主站

注：到此默认是在测试站已经部署成功了之后才可以

![image-20220505180909844](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051809027.png)







>6.提交测试

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051810764.png" alt="image-20220505181012581" style="zoom:50%;" />







>7.发邮件

要发邮件给测试人员，请求帮忙测试一下Fuse(**此时是已经在测试站验证发布并测试好了之后**)



将实例中的名称复制![image-20220505181359595](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051813867.png)





![image-20220505181707150](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051817391.png)





![image-20220505182207470](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051822736.png)



注意：

​		上述**主机IP**是项目对应默认的

​		**版本**是正在部署的版本，具体看提交部署后正在部署的版本





>8.主站部署

上述发邮件步骤完成之后(测试人员会帮忙测试fuse指标，有问题会找你)

结束此时把上述填入的代部署版本号会定为稳定的版本。

![image-20220505182500114](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051825307.png)





>9.发起部署

![image-20220505182847132](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051828346.png)



看一下部署步骤加载进来了再发起部署







>10.检查任务

![image-20220505182916449](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051829687.png)





查看是否到了主站部署阶段

![image-20220505183059059](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051830295.png)



>11.查看实例

![image-20220505183238442](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051832704.png)

>发邮件给运维

![image-20220513193818675](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131938954.png)

![image-20220505183413994](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051834224.png)







>11.立即部署

![image-20220505183555127](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051835416.png)











>12.检查

![image-20220505183839970](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051838245.png)



要查看两个站

![image-20220505184148305](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051841517.png)





点击项目名进去

![image-20220505184201520](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051842732.png)



如果都为绿色即部署完成

![image-20220505184207695](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051842025.png)

>刷新方法

![image-20220513195114929](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131951209.png)















>发布网关

![image-20220505175835244](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051758440.png)

![image-20220513195604373](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131956664.png)

注：想要在主站测试，一定是要最终通过发布之后才能访问到。





> 还需最终验证所有接口是否正常,通知后后续步骤的人员进行升级

验证完成通知客户端

- 我这里已经升级好了，你那边也可以升级了。
- 没有升级，就告知其已部署相关接口，可以继续开发。











### 细节问题







#### 魔法值



> 注意：修改魔法值之前一定要考虑并发问题





##### 值不可变

值不能被改变，将以下变量设置为全局变量

```java
static final 变量名 = 1;
```





##### 值可变

先将魔法值赋值为全局变量

```java
static 变量名 = 魔法值;
```

再到方法体内声明一个局部变量

如下所示全部步骤

![image-20220513183443722](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131834962.png)









#### 导入svn插件

安装了，再IDEA上导入插件



![image-20220513183818179](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131838410.png)



![image-20220513183917317](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131839501.png)





![image-20220513183922035](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131839225.png)





























### 申请







#### 申请主站网络服务



##### 进入申请

1. 内网进入万得之家首页
2. 点击IT支持
3. 服务器通信申请

![](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204281111813.png)





##### 实际步骤



###### 进入页面

>例：小课堂代码**要迁移到dataShare项目**中，此时**源地址IP就是实例中dataShare项目所有的IP地址 + 自己的IP地址**

![image-20220428111506955](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204281115252.png)









###### 具体步骤



> 1.填要写入的项目所有的IP地址 + 自己的IP地址

![image-20220428132908883](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204281329143.png)

注意：==测试站的IP地址无需加入==





>2.时间

填最长的2099年12月31日好了。默认填入此时间接口





>3.申请原因

详细说明一下申请的原由

![image-20220428112744497](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204281127671.png)



>4.HTTP+ HTTPS

==注意：HTTP和HTTPS这两个一定要按需添加开启，不断乱开，用了哪个开哪个！！！==



![image-20220428133748021](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204281337370.png)







>5.添加成功

![image-20220428134002974](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204281340194.png)







>6.提交申请

![image-20220428134047854](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204281340112.png)









>7.完成申请

![image-20220428135336108](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204281353308.png)

















### 延伸知识







#### 深入了解DTO及其使用



##### 是什么？



DTO就是数据传输对象(Data Transfer Object)的缩写。

DTO模式：是指将数据封装成普通的JavaBean**==s==**，在`J2EE`多个层次之间传输。

DTO**类似信使**：是同步系统中的Message。该JavaBeans可以是一个**数据模型Model**。







##### 用在哪？

**用在需要跨进程或远程传输时，它不应该包含业务逻辑。**
	比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO 内的数据来自多个表）。

​	但view层**==只需显示10个字段，没有必要把整个PO对象传递到client==**，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。

​	到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为V







##### 好处



###### 没有用DTO时





在传统的编程中，我们一般都是：

1. 前台请求数据，发送到Webservice
2. 然后WebService向数据库发出请求，获取数据
3. 然后一层层返回；模型如下：

![image-20220323142936954](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203231429130.png)

注：这种比较原始的请求方式带来的缺点很多：

1. 多次请求耗费一定的网络资源，降低效率
2. 如果一次性返回整个实体类，还可能造成数据表结构的泄露







###### 使用了DTO模型后

![image-20220323143340450](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203231433620.png)



这样带来的好处有：

1. **方便**：依据现有的类代码，即可方便的构造出DTO对象，无需重新进行分析
2. **减少请求次数**：大大提高了效率。
3. **按需组织DTO对象**：页面需要的字段我才组织，不需要的我不组织。可以避免传输整个表的字段







##### 总结

**一般使用DTO类来继承entity实体类**，**在DTO类里放一些业务字段**，**并提供get、set方法**。

当我们在业务逻辑层或者交互层用到一些数据库中不存在的字段时：

​	我们就需要在DTO类里放这些字段

​	这些字段的意义就相当于一些经处理过的数据库字段

​	**==实质意义：方便数据交互，提高效率==**

























#### VO/DTO/DO/PO/POJO/BO/DAO

> VO/DTO/DO/PO/POJO/BO/DAO概念及其区别



##### VO(Value Object) 值对象

通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已。但应是抽象出的业务对象 , 可以和表对应 , 也可以不 , 这根据业务的需要 。用 new 关键字创建，由 GC 回收的。





##### VO(View Object)视图对象

用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。





##### DTO(TO)(Data Transfer Object)数据传输对象

1 ．用在需要跨进程或远程传输时，它不应该包含业务逻辑。
2 ．比如一张表有100个字段，那么对应的PO就有100个属性（大多数情况下，DTO 内的数据来自多个表）。但view层只需显示10个字段，没有必要把整个PO对象传递到client，这时我们就可以用只有这10个属性的DTO来传输数据到client，这样也不会暴露server端表结构。到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO。





##### DO（Domain Object）领域对象

就是从现实世界中抽象出来的有形或无形的业务实体。





##### PO(persistant object) 持久对象

1 ．有时也被称为Data对象，对应数据库中的entity，可以简单认为一个PO对应数据库中的一条记录。
2 ．在hibernate持久化框架中与insert/delet操作密切相关。
3 ．PO中不应该包含任何对数据库的操作





##### [POJO](https://so.csdn.net/so/search?q=POJO&spm=1001.2101.3001.7020)(plain ordinary java object) 无规则简单java对象

实际就是普通JavaBeans,使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,有时可以作为value object或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。

POJO是Plain Ordinary Java Objects的缩写不错，但是它通指没有使用Entity Beans的普通java对象，可以把POJO作为支持业务逻辑的协助类。





##### BO(business object) 业务对象

从业务模型的角度看 , 见 UML 元件领域模型中的领域对象。封装业务逻辑的 java 对象 , 通过调用 DAO 方法 , 结合 PO,VO 进行业务操作。 business object: 业务对象 主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。 比如一个简历，有教育经历、工作经历、社会关系等等。 我们可以把教育经历对应一个 PO ，工作经历对应一个 PO ，社会关系对应一个 PO 。 建立一个对应简历的 BO 对象处理简历，每个 BO 包含这些 PO 。 这样处理业务逻辑时，我们就可以针对 BO 去处理。





##### DAO (data access object)数据访问对象

是一个 sun 的一个标准 j2ee 设计模式， 这个模式中有个接口就是 DAO ，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和 PO 结合使用， DAO 中包含了各种数据库的操作方法。通过它的方法 , 结合 PO 对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合 VO, 提供数据库的 CRUD 操作.







##### VO与DTO的区别

既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。

用一个例子来说明可能会比较容易理解：

例如Service层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于Service层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。
理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面我马上会分析应用中





##### VO与DTO的应用

当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来，这时候VO可以退隐，用一个DTO即可，为什么是VO退隐而不是DTO？回到设计层面，Service层的职责依然不应该与View层耦合，所以，对于前面的例子，你很容易理解，DTO对于“性别”来说，依然不能用“帅哥美女”，这个转换应该依赖于页面的脚本（如JavaScript）或其他机制（JSTL、EL、CSS）
即使客户端可以进行定制，或者存在多个不同的客户端，如果客户端能够用某种技术（脚本或其他机制）实现转换，同样可以让VO退隐

以下场景需要优先考虑VO、DTO并存:

因为某种技术原因，比如某个框架（如Flex）提供自动把POJO转换为UI中某些Field时，可以考虑在实现层面定义出VO，这个权衡完全取决于使用框架的自动转换能力带来的开发和维护效率提升与设计多一个VO所多做的事情带来的开发和维护效率的下降之间的比对。

如果页面出现一个“大视图”，而组成这个大视图的所有数据需要调用多个服务，返回多个DTO来组装（当然，这同样可以通过服务层提供一次性返回一个大视图的DTO来取代，但在服务层提供一个这样的方法是否合适，需要在设计层面进行权衡）。





##### DTO与DO的区别

首先是概念上的区别，DTO是View层和Service层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User（对于DTO和DO的命名规则，请参见笔者前面的一篇博文），对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。而在领域驱动设计中，正如第一篇系列文章所说，DO不是简单的POJO，它具有领域业务逻辑。







##### DTO与DO的应用

从上一节的例子中，细心的读者可能会发现问题：既然getUser方法返回的UserInfo不应该包含password，那么就不应该存在password这个属性定义，但如果同时有一个createUser的方法，传入的UserInfo需要包含用户的password，怎么办？在设计层面，View层向Service层传递的DTO与Service层返回给View层的DTO在概念上是不同的，但在实现层面，我们通常很少会这样做（定义两个UserInfo，甚至更多），因为这样做并不见得很明智，我们完全可以设计一个完全兼容的DTO，在服务层接收数据的时候，不该由View层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论View层是否设置，Service层都一概忽略，而在Service层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。

对于DO来说，还有一点需要说明：为什么不在Service层中直接返回DO呢？这样可以省去DTO的编码和转换工作，原因如下:

- 两者在本质上的区别可能导致彼此并不一一对应，一个DTO可能对应多个DO，反之亦然，甚至两者存在多对多的关系。
- DO具有一些不应该让View层知道的数据 DO具有业务方法，如果直接把DO传递给View层，View层的代码就可以绕过Service层直接调用它不应该访问的操作，对于基于AOP拦截Service层来进行访问控制的机制来说，这问题尤为突出，而在View层调用DO的业务方法也会因为事务的问题，让事务难以控制。
- 对于某些ORM框架（如hibernate）来说，通常会使用“延迟加载”技术，如果直接把DO暴露给View层，对于大部分情况，View层不在事务范围之内（Open session in view在大部分情况下不是一种值得推崇的设计），如果其尝试在Session关闭的情况下获取一个未加载的关联对象，会出现运行时异常（对于Hibernate来说，就是LazyInitiliaztionException）。
- 从设计层面来说，View层依赖于Service层，Service层依赖于领域层，如果把DO暴露出去，就会导致View层直接依赖于dao层，这虽然依然是单向依赖，但这种跨层依赖会导致不必要的耦合。
  对于DTO来说，也有一点必须进行说明，就是DTO应该是一个“扁平的二维对象”

举个例子来说明：如果User会关联若干个其他实体（例如Address、Account、Region等），那么getUser()返回的UserInfo，是否就需要把其关联的对象的DTO都一并返回呢？如果这样的话，必然导致数据传输量的大增，对于分布式应用来说，由于涉及数据在网络上的传输、序列化和反序列化，这种设计更不可接受。如果getUser除了要返回User的基本信息外，还需要返回一个AccountId、AccountName、RegionId、RegionName，那么，请把这些属性定义到UserInfo中，把一个“立体”的对象树“压扁”成一个“扁平的二维对象”，笔者目前参与的项目是一个分布式系统，该系统不管三七二十一，把一个对象的所有关联对象都转换为相同结构的DTO对象树并返回，导致性能非常的慢。







##### DO与PO的区别

DO和PO在绝大部分情况下是一一对应的，PO是只含有get/set方法的POJO，但某些场景还是能反映出两者在概念上存在本质的区别：

DO在某些场景下不需要进行显式的持久化，例如利用策略模式设计的商品折扣策略，会衍生出折扣策略的接口和不同折扣策略实现类，这些折扣策略实现类可以算是DO，但它们只驻留在静态内存，不需要持久化到持久层，因此，这类DO是不存在对应的PO的。

同样的道理，某些场景下，PO也没有对应的DO，例如老师Teacher和学生Student存在多对多的关系，在关系数据库中，这种关系需要表现为一个中间表，也就对应有一个TeacherAndStudentPO的PO，但这个PO在业务领域没有任何现实的意义，它完全不能与任何DO对应上。

这里要特别声明，并不是所有多对多关系都没有业务含义，这跟具体业务场景有关，例如：两个PO之间的关系会影响具体业务，并且这种关系存在多种类型，那么这种多对多关系也应该表现为一个DO，又如：“角色”与“资源”之间存在多对多关系，而这种关系很明显会表现为一个DO——“权限”。

某些情况下，为了某种持久化策略或者性能的考虑，一个PO可能对应多个DO，反之亦然。例如客户Customer有其联系信息Contacts，这里是两个一对一关系的DO，但可能出于性能的考虑（极端情况，权作举例），为了减少数据库的连接查询操作，把Customer和Contacts两个DO数据合并到一张数据表中。反过来，如果一本图书Book，有一个属性是封面cover，但该属性是一副图片的二进制数据，而某些查询操作不希望把cover一并加载，从而减轻磁盘IO开销，同时假设ORM框架不支持属性级别的延迟加载，那么就需要考虑把cover独立到一张数据表中去，这样就形成一个DO对应对个PO的情况。

PO的某些属性值对于DO没有任何意义，这些属性值可能是为了解决某些持久化策略而存在的数据，例如为了实现“乐观锁”，PO存在一个version的属性，这个version对于DO来说是没有任何业务意义的，它不应该在DO中存在。同理，DO中也可能存在不需要持久化的属性。







##### DO与PO的应用

由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations/hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意：

- 对于DO中不需要持久化的属性，需要通过ORM显式的声明，如：在JPA中，可以利用@Transient声明。
- 对于PO中为了某种持久化策略而存在的属性，例如version，由于DO、PO合并了，必须在DO中声明，但由于这个属性对DO是没有任何业务意义的，需要让该属性对外隐藏起来，最常见的做法是把该属性的get/set方法私有化，甚至不提供get/set方法，但对于Hibernate来说，这需要特别注意，由于Hibernate从数据库读取数据转换为DO时，是利用反射机制先调用DO的空参数构造函数构造DO实例，然后再利用JavaBean的规范反射出set方法来为每个属性设值，如果不显式声明set方法，或把set方法设置为private，都会导致Hibernate无法初始化DO，从而出现运行时异常，可行的做法是把属性的set方法设置为protected。
- 对于一个DO对应多个PO，或者一个PO对应多个DO的场景，以及属性级别的延迟加载，Hibernate都提供了很好的支持，请参考Hibernate的相关资料。





















#### CDN分布式缓存





##### 理论知识



###### 简介

​	CDN的全称是`Content Delivery Network`，即[内容分发网络](https://baike.baidu.com/item/内容分发网络/4034265)。

​	CDN是构建在**现有网络基础之上的智能虚拟网络**，**依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。**CDN的关键技术主要有==内容存储和分发技术==。 [1] 





###### 基本原理

CDN的基本原理是广泛采用各种缓存服务器，将这些**缓存服务器分布到用户访问相对集中的地区或网络**中。

​	在用户访问网站时，利用**全局负载技术**将用户的**访问指向距离最近**的工作正常的**缓存服务器**上，由**缓存服务器直接响应**用户请求。 [5] 

CDN的基本思路是

1. 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。
2. 通过在网络各处放置[节点服务器](https://baike.baidu.com/item/节点服务器/4576219)所构成的在现有的互联网基础之上的一层智能[虚拟网络](https://baike.baidu.com/item/虚拟网络/855117)，CDN系统能够实时地根据[网络流量](https://baike.baidu.com/item/网络流量/7489548)和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。
3. 其目的是使用户可**就近取得所需内容**，**解决 Internet网络拥挤**的状况，**提高**用户访问网站的**响应速度**。 [6] 











###### 特点

1. 本地Cache加速：提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性。 [8] 
2. 镜像服务：消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。 [8] 
3. 远程加速：[远程访问](https://baike.baidu.com/item/远程访问)用户根据DNS[负载均衡](https://baike.baidu.com/item/负载均衡)技术智能自动选择Cache[服务器](https://baike.baidu.com/item/服务器)，选择最快的Cache服务器，加快远程访问的速度。 [8] 
4. 带宽优化：自动生成[服务器](https://baike.baidu.com/item/服务器)的远程Mirror（[镜像](https://baike.baidu.com/item/镜像)）cache服务器，[远程用户](https://baike.baidu.com/item/远程用户)访问时从cache服务器上读取数据，减少[远程访问](https://baike.baidu.com/item/远程访问)的带宽、分担网络流量、减轻原站点[WEB服务器](https://baike.baidu.com/item/WEB服务器)负载等功能。 [8] 
5. 集群抗攻击：广泛分布的CDN节点加上节点之间的智能[冗余](https://baike.baidu.com/item/冗余)机制，可以有效地预防[黑客](https://baike.baidu.com/item/黑客)入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。 [8] 







###### 功能

归纳起来，CDN具有以下主要功能：

1. 节省骨干网带宽，减少带宽需求量； [4] 
2. 提供服务器端加速，解决由于用户访问量大造成的服务器过载问题； [4] 
3. 服务商能使用Web Cache技术在本地缓存用户访问过的Web页面和对象，实现相同对象的访问无须占用主干的出口带宽，并提高用户访问因特网页面的相应时间的需求； [4] 
4. 能克服网站分布不均的问题，并且能降低网站自身建设和维护成本； [4] 
5. 降低“通信风暴”的影响，提高网络访问的稳定性。 [4] 







###### 关键技术



> 内容发布

​	它借助于建立**索引、[缓存](https://baike.baidu.com/item/缓存)、流分裂、[组播](https://baike.baidu.com/item/组播)（Multicast）等技术，将内容发布或投递到距离用户最近的[远程服务](https://baike.baidu.com/item/远程服务)点（POP）处。** [9] 

**内容分发**包含**从内容源到CDN边缘的Cache的过程**。从实现上，有两种主流的内容分发技术：`PUSH`和`PULL`。 [10] 

**PUSH是一种主动分发的技术**:

1. 通常，PUSH由内容管理系统发起，将内容从源或者中心媒体资源库分发到各边缘的 Cache节点。分发的协议可以采用 Http/ftp等。
2. 通过PUSH分发的内容一般是比较热点的内容，这些内容通过PUSH方式预分发（ Preload）到边缘Cache，可以实现有针对的内容提供。
3. 对于PUSH分发需要考虑的主要问题是分发策略，即在什么时候分发什么内容。
4. 一般来说，内容分发可以由CP（内容提供商）或者CDN内容管理员人工确定，也可以通过智能的方式决定，即所谓的智能分发，它**根据用户访问的统计信息**，以及**预定义的内容分发的规则**，确定内容分发的过程.
5. **PULL是一种被动的分发技术**，PULL分发通常由用户请求驱动。当用户请求的内容在本地的边缘 Cache上不存在（未命中）时， Cache启动PUL方法从内容源或者其他CDN节点实时获取内容。在PULL方式下，内容的分发是按需的。 [10] 



>内容路由

它是整体性的[网络负载均衡](https://baike.baidu.com/item/网络负载均衡)技术，通过内容[路由器](https://baike.baidu.com/item/路由器)中的重定向（DNS）机制，在多个远程POP上均衡用户的请求，以使用户请求得到最近内容源的响应。 [9] 

CDN负载均衡系统实现CDN的内容路由功能。它的作用是将用户的请求导向整个CDN网络中的最佳节点。最佳节点的选定可以根据多种策略，例如距离最近、节点负载最轻等。负载均衡系统是整个CDN的核心，负载均衡的准确性和效率直接决定了整个CDN的效率和性能。通常负载均衡可以分为两个层次:全局负载均衡（GSLB）和本地负载均衡（SLB）。全局负载均衡主要的目的是在整个网络范围内将用户的请求定向到最近的节点（或者区域）。因此，就近性判断是全局负载均衡的主要功能。本地负载均衡一般局限于一定的区域范围内，其目标是在特定的区域范围内寻找一台最适合的节点提供服务，因此，CDN节点的健康性、负载情况、支持的媒体格式等运行状态是本地负载均衡进行决策的主要依据。 [10] 





>内容存储

对于CDN系统而言，需要考虑两个方面的内容存储问题。一个是内容源的存储，一个是内容在 Cache节点中的存储。 [10] 

对于内容源的存储，由于内容的规模比较大（通常可以达到几个甚至几十个TB），而且内容的吞吐量较大，因此，通常采用海量存储架构，如NAS和SON。对于在 Cache节点中的存储，是 Cache设计的一个关键问题。需要考虑的因素包括功能和性能两个方面:功能上包括对各种内容格式的支持，对部分缓存的支持;在性能上包括支持的容量、多文件吞吐率、可靠性、稳定性。 [10] 

其中，多种内容格式的支持要求存储系统根据不同文件格式的读写特点进行优化，以提高文件内容读写的效率。特别是对针对流媒体文件的读写。部分缓存能力指流媒体内容可以以不完整的方式存储和读取。部分缓存的需求来自用户访问行为的随机性，因为许多用户并不会完整地收看整个流媒体节目。事实上，许多用户访问单个流媒体节目的时间不超过10分钟。因此，部分缓存能力能够大大提高存储空间的利用率，并有效提高用户请求的响应时间。但是部分缓存可能导致内容的碎片问题，需要进行良好的设计和控制。 [10] 

Cache存储的另一个重要因素是存储的可靠性，目前，多数存储系统都采用了独立磁盘冗余阵列（RAID）技术进行可靠存储。但是不同设备使用的RAID方式各有不同。 [10] 





>内容管理

它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、[帧速率](https://baike.baidu.com/item/帧速率)等），保证网络处于最佳的运行状态。 [9] 

内容管理在广义上涵盖了从内容的发布、注入、分发、调整、传递等一系列过程。在这里，内容管理重点强调内容进人 Cache点后的内容管理，称其为本地内容管理。本地内容管理主要针对一个ODN节点（有多个 CDN Cache设备和一个SLB设备构成）进行。本地内容管理的主要目标是提高内容服务的效率，提高本地节点的存储利用率。通过本地内容管理，可以在CDN节点实现基于内容感知的调度，通过内容感知的调度，可以避免将用户重定向到没有该内容的 Cache设备上，从而提高负载均衡的效率。通过本地内容管理还可以有效实现在ODN节点内容的存储共享，提高存储空间的利用率。 [10] 





















### 22年3月











#### 22日

根据安排今日研究Activity项目





##### ActivityController

---



###### doActivety

post接口，活动服务统一API入口，不同活动详情可以

通过传入符合指定格式的参数：





1.通过传入的actvityId参数从数据库中查询获取活动的具体信息

2.根据传入的错误参数在数据库的查询结果来对应返回细分的不同自定义枚举的错误

3.传入正确参数并把获取的(总)数据赋给activity对象，再从activity获取活动的类型(int数值)   activityType。

4.再把activityType参数对比应获活动的详情，但为什么后面还需要获取.getType()方法？此方法遍历了所有的活动来一个一个比对，其实这个也想的通，但是后面为什么还要接else if 并且创建的对象都对应注入的不同的bean。？？？





cn.com.wind.activity - controller包下的ActivityController.class

基于All in one原则，**活动入口API只有一个，所有接口的入参**

![image-20220322135937070](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203221359308.png)

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203221400453.png" alt="image-20220322140029264" style="zoom:50%;" />



优点：便于统一传入处理管理，在这一个类中







根据返回参数或异常类型不同的细分前给前端显示的自定义枚举异常，在此类中就可以看成一个简单辨别错误的方法，后期也方便维护，



![image-20220322150013268](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203221500402.png)



























##### 今日问题





> 1.什么是All in one 原则，活动入口API只有一个，所有接口入参

并不属于24种常用设计模式。

方便统一管理，以及后期维护。







> 2.遍历比对，为什么还要else if

在ActivityController.java中把activityType参数对比应获活动的详情，但为什么后面还需要获取.getType()方法？此方法遍历了所有的活动来一个一个比对，其实这个也想的通，但是后面为什么还要接else if 并且创建的对象都对应注入的不同的bean。？？？

















##### 工作日志

1.解决vpn客户端连接异常



2.调试activity项目运行

3.熟悉activity项目结构:

主要熟悉关于主要熟悉活动服务统一API入口中的

具体方法，传递参数，以及返回内容，调用的其它类，doactivity()方法参数，以及对应活动处理，查询活动记录/中奖记录，验证资格，等内容



项目对应数据库中的表结构及数据

项目整体宏观分析总结。



























#### 23日



##### 今日晨会安排工作

1. 熟悉项目的其它部分代码
2. 熟悉项目对应数据库中的表结构及数据
3. 项目整体宏观分析总结









>核心代码



- ActivityController.java

  doActivity()方法中

1. 根据传入的activityId从数据库查询对应的活动具体信息
   1. if(activity == null) 返回对应的错误信息
2. 将查询返回的数据集视为一个对象，其中利用其中的属性activityType的属性值(int类型)，判断是否符合对应的类型。
3. 判断activityType == IActivityPartService.get(活动对应的编号)
   1. new SurveyRequest(activityId, userId, channelCode, param 其中的属性);赋值给request对象
4. 调用bean(activityPartService.partSurveyActivity(活动之一，已经判断进入表明activityType编号与此活动一致) (传入request对象))；
5. result 是将方法调用返回的值包装的调用，判断是否合法等。
6. bean(activityPartService)：是底层封装了mybatis-plus的增删改查等功能。



















##### 项目整体目录结构

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203231119491.png" alt="image-20220323111932335" style="zoom:50%;" />











###### log和logs

两个文件夹中保存项目的日志信息文件(包括项目运行过程中出现的实时错误信息)

![image-20220323112258996](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203231122121.png)









###### **cn.com.wind.activity**









###### common





###### aspect



@Aspect-Spring AOP注解

AOP切面环绕日志：方法；返回值，执行时间和参数等信息



LogAnnotationAspect.java

注解式日志记录器具体实现





LogRecordUtil.java

日志记录工具类









###### Config：配置信息



DataSourceConfig

数据库连接配置信息



MybatisPlusConfig

MybatisPlus插件配置类





###### constant

持续的

实体类：

1. ActivityConstant：活动的相关常量
2. CrmConstants：接口转化参数
3. ExtendFieldKeyConstant：扩展字段
4. ParamKeyConstants：活动服务统一请求入口param的参数定义
5. Result：返回封装类
6. ResultCodeEnum：枚举返回的各种异常编号及具体显示的错误信息。











###### enums枚举包



1. survey -> QuestionTypeEnum 问卷问题枚举
2. ActionSortEnum：动作排序枚举，参加活动
3. ActivityPrizeTypeEnum：问卷奖品类型枚举 0：无奖品，1：实物奖，2：虚拟奖
4. ActivityStatusEnum：活动状态枚举
   1. 待发布
   2. 进行中
   3. 暂停
   4. 中止
   5. 已过期
5. BusinessErrorCodeEnum：业务异常错误枚举
   1. 用户界面提示
   2. 渠道界面提示
   3. 渠道活动提示语
   4. 投票活动提示语
   5. 后台服务远程调用交互错误码
6. ChannelEnum：信息获取渠道枚举
7. FunctionCodeEnum：上下文对象
8. VotePositionEnum：位置类型，描述
9. VoteTypeEnum：投票类型







###### exception：自定义异常包





###### utils：工具类

- 加密MD5和Base64工具类
- Log工具类
- 时间日期以及JSON工具类
- Http请求工具类
- ResultUtil 返回封装类
- 验证器







##### controller 前端控制器









##### core 核心代码





###### annotation：注解



1. ActivityTypeMapper：活动属性注解
2. FunctionMapper ：函数映射器
3. LogAnnotation：日志记录注解，有该注解的方法将进行日志记录





###### base



1. IActivityDTOParser：活动数据传输对象解析器
2. IActivityHandler：活动处理器，对应不同的functionCode 可派生多个子类，子类内部可以抽象定义一套模板方法，具体交由各个活动自行实现
3. IActivityResponseParser：活动相应对象解析器









###### domain



1. ActivityDTO
2. ActivityTypeEnum：ActivityType数据对应的枚举信息
3. ContextParam
4. FunctionCodeEnum：同一个活动可能对应不同的FunctionCode







###### dto包

**数据传输对象(Data Transfer Object)**

在延伸知识中已大体知晓包中内容用意











###### handler 处理包





- AbstractActivityPartHandler：
  - 校验抽象方法
- BuyPresentationHandler
  - 获取用户信息加密参数
  - 获取奖励信息
- ChannelHandler：渠道处理handler
- CouponPartHandler：执行动作的抽象类
- LotteryPartHandler：彩票部
- NewCustomerPartHandler：新客户处理
  - 免费体验活动
- RenewPresentationPartHandler：续费赠送活动处理类
- SignlnPartHandler：签到活动handler
- SurveyHanler：问卷活动处理类
- VoteHandler：投票活动处理类











###### helper

1. BeanHelper：通过名称获取Bean
2. DateHelper：获取时间









###### parser大部分为DTO













###### remoterequest远程请求

1. 客户端
2. 服务端





###### rule规则

制定校验等相关规则













##### dal

##### integration

##### service









##### web



###### annotation 注解

- @BaseResponse基本相应注解









###### config配置

1. PropertyConfig：加载外部配置文件
2. Swagger2Config：利用swagger构建api文档
3. WebMvcConfig：前后端交互**跨域配置**











###### Controller 重点







1. ActivityController：活动对应处理(核心)
2. ActivityManagerController：活动管理
3. IndexController：首页





###### filter 筛选





###### handler 处理



- GlobalExceptionHandler：全局异常处理程序
- RestResponseHandlerAdivice：休息响应处理程序









###### interceptor 拦截器

SpringMvc定义拦截器





###### request





> base

1. ActivityRequest：活动服务请求接口
2. BaseActivityParRequest：活动请求抽象类







##### 问题



> 1.什么是All in one 原则，活动入口API只有一个，所有接口入参

并不属于24种常用设计模式。

方便统一管理，以及后期维护。

思想：接口定义





> 2.遍历比对，为什么还要else if

在ActivityController.java中把activityType参数对比应获活动的详情，但为什么后面还需要获取.getType()方法？此方法遍历了所有的活动来一个一个比对，其实这个也想的通，但是后面为什么还要接else if 并且创建的对象都对应注入的不同的bean。？？？







>3.web包代表的意思

其实上面其它的包中大致一个项目所有代码已经可以算是一个整体了，为什么还有有这个web包或者说是重新再开一个包







> 4.此项目在数据库中只有activity库中的所有表，没有其它的了吧？

![image-20220323145514896](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203231455069.png)































































#### 24日

熟悉datashareservice项目









##### 熟悉接口流程



接口：

1. 接口的入参
2. 实现功能
3. 依赖的哪几个服务



























1. 新建controller

搜索关键字

- 接口定义
- controller
- 热点题材数据导出接口
- 热点题材数据导出





- tb_tock_topic
- 实现对两表查询



- 写表的



ctrl + shift + T

生成测试用例







service 合并























#### 25日

> 完成热点数据导出接口



![image-20220325111337118](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203251113331.png)







- 完成mapper，并能测试出数据

1. 找出数据表中的字段，将所需的五个字段一一对应出来，放到





















##### 编写热点数据导出接口



###### 步骤







###### HotTopicDataExportController

1. 先查看hot_topic热点题材接口文档中传入的地址以及方式
2. 对应写出对应的接口自动生成API文档的参数类型
3. 将@RequestMapping(“”)中对应接口地址写好
4. 将对应方法实现，最后从service层返回的String转换为.csv——>.zip文件调用HttpServletResponse 中的方法返回以下载压缩包的方式

![image-20220330100844145](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301008360.png)

![image-20220330100907523](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301009701.png)







###### HotTopicDataExportVO

**注：由于查询的是两张表的整合，在mapper中使用需要一个实现类，在service中又需要一个实现类，所需两个实现类**

此为Service的实体类

![image-20220330102414108](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301024291.png)









###### HotTopicDataExportService

![image-20220330101310675](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301013806.png)





###### HotTopicDataExportServiceImpl





![image-20220330101416087](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301014263.png)

![image-20220330101437729](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301014893.png)

![image-20220330101455558](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301014707.png)













###### HotTopicDataExport

此实现类为mapper中的实现类

![image-20220330102252066](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301022227.png)













###### HotTopicDataExportMapper



![image-20220330101600402](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301016535.png)







###### HotTopicDataExportMapper.xml



注意：查询的是两张表的内容且**两张表的字段名id都是相同的**的所以要返回的resultMap中的熟悉要在sql中：

**为两表字段名id设置不同的别名并写入到resultMap中的property属性中**。否则mybatis识别不出来，**返回null值**

![image-20220330101628751](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301016951.png)

![image-20220330102146704](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301021871.png)











###### ZipUtil

另外在最后返回以下载压缩包的方式，此方式需要将拼接的.csv格式的字符串——>.zip调用 返回，用到了zip工具类。

![image-20220330102844517](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301028687.png)













###### test

最终用于测试的测试类

![image-20220330102742153](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301027334.png)





















#### 30日







##### 小课堂加载bug



检查IOS移动端万得股票APP中的万得小课堂，页面加载缓慢时常加载不出来









##### 重现步骤



打开**ios移动端**

万得股票APP ——> 机会 ——> 全部 ——> 投资课堂 ——> 万得小课堂

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301000976.png" alt="image-20220330100049823" style="zoom:50%;" />



















##### 分析

1. dyh-web项目，00年上线老项目，以springMVC为主要架构体系
2. 分析，主要查看理清万得小课堂相关接口代码
3. **理清楚内部逻辑思路**
4. **理解从客户端访问时候，一系列的响应流程。**

![image-20220330100321961](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301003113.png)

这些接口先实现公司总线，最后包装http无状态协议。





>代理模式

![image-20220330172236134](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301722310.png)













###### 项目启动类：



**StrategySiteRunner**

















###### 总体接口

![image-20220330103517853](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301035016.png)









###### COURSE_INFO(0900008，“课堂信息接口”)

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301036534.png" alt="image-20220330103644375" style="zoom:50%;" />



- 上述handle()方法中的switch - case类型效用  = java语言switch语句







> getCourseInfo(String inputParam)

**课堂信息接口调用方法**

![image-20220330103911189](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301039357.png)





>依赖WstockCourseManager接口



接口中的方法为：

1. **getCourseInfo(Integer currentPage, Integer pageSize)**                                    获取课程信息
2. **getMyCourse(Integer userId)**                                                                                   获取我的课程
3. **getPlayList(Integer courseId, Integer currentPage, Integer pageSize)**        获取课程播放列表
4. **getPlayAuth(String mediaId)**                                                                                   获取视频播放凭证
5. **getRecommandCourse(Integer currentPage, Integer pageSize)**                   获取推荐课程
6. **checkCoursePermiss(Integer userId, Integer courseId, String mediaId)**    验证课程权限           



- 在getCourseInfo(String inputParam) 中通过WstockCourseManager接口调用其中的getCourseInfo(pageInfo.get(0)

- pageInfo.get(1)); 并赋值给WStockCourse实体类





最后拼接结果集result



![image-20220330175408379](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203301754544.png)

```java
result = ExpoResult.createResult(
    COURSE_INFO.getCode(),
    ExpoResult.DEFAULT_SUCCESS_CODE,
    ExpoResult.DEFAULT_SUCCESS_MESSAGE,
    wStockCourse)
```









思路：

1. 首先在controller中传入参数inputParam 然后调用switch语句判断参数请求对应的是调用哪个接口来获取对应的数据。如若没有相应的方法响应，证明参数传入有误，返回ErrorCode
2. 假设inputParam参数传入的对应为枚举的COURSE_INFO接口
3. 则对应到COURSE_INFO中的方法getCourseInfo(inputParam)返回对应结果集，接下来就是具体此方法的实现。
4. 在WStockCourseHandler.java中的getCourseInfo(inputParam)方法中的具体实现中返回类型为ExpoResult<Object>自定义结果包装类型



具体实现：

1. 首先将传入的String类型参数inputParam，调用JSON工具类(JSONObject) 转换为 JSON格式 赋值给到

   //getpageInfo()方法为具体页面数检验转换方法

   List<Integer> pageInfo = getpageInfo(input);

2. 调用依赖wstockCourseManager中的getCourseInfo(传入转换的页面数参数)；

   1. 传入的pageInfo.get(0) = currentPage 

   2. pageInfo.get(1) = pageSize

   3. 具体的依赖中的相同方法getCourseInfo(pageInfo.get(0),pageInfo.get(1))

   4. 再次调用此方法中的依赖aliVodManager中的getPhotoInfoBatch(自定义的课程图片分类号)

   5. 调用courseDAO中getTotalCourse(currentPage ,pageSize)方法获取到的数据

   6. 使用lamda表达式.stream().map(t - > t.getGoodsId()).collect(Collectors.toList())

      将获取到的数据转换为List<Integer>类型

   7. 再用两个map装入数据
   
      1. goodsInfo用于调用rGoodsService.getGoodsById(goodsId)//根据商品id获取商品信息
      2. goodSal中的数据为，调用rOrderService.getGoodsSales(参数)获取商品销售数量
   
   8. 如果出现其它情况则对应输出日志信息，及错误码BUSINESSCHARGE_SYSTEM_ERROR收费服务异常
   
   9. 最后组装课程数据并返回





















#### 31日





###### 龙虎榜接口相关代码移植问题

思路：

1. 找到并调试相关所有接口(可参考旧文档)
2. 理清相关接口代码
3. 移植到datashare项目中











###### 接口整理

```java
//项目代码接口中定义中出现的

GET-NEWARNQRMAL-_RANK( code: "0101002", message:"新龙虎榜最新上榜"),
```

```java
//二者共同出现的
GET_ABNORMAL_HOMEPAGE( code: "0101001",message:"龙虎榜首页")，
GET_ABNORMAL_DETAILGRQUP( code: "0102001",message:"龙虎榜明细合计")，
GET_ABNORMAL_DETAILS( code: "0103001",message:"龙虎榜明细")，
GET_ABNORMAL_BYSEAT$( code: "0104001",message:"龙虎榜根据席位统计”)，
GET_ABNORMAL_BUY_BYSEATS( code: "0105001",message:"龙虎榜买入金额根据席位统计")，
GET_ABNORMAL_ORG_STRENGTH( code: "0141001",message："龙虎榜席位綜合实力")，
GET_ABNORMAL_ORG_PREFERENCE( code: "0142001",message:"龙虎榜席位风格偏好"),
GET_ABNORMAL_ORG_RANKINGLIST( code: "0143001",message:"龙虎榜席位排行榜")，
GET_ABNORMAL_HOMEPAGECQUNT ( code: "0144001",message:"龙虎榜首页上榜股票条数")，
GET_ABNORMAL_WINDCQDEBYDATE,(code: "0145001",message："龙虎榜上榜股票（指定时间段）")，
GET_NEWABNORMAL_ ACTIVERANK C code:"0103002",message:"新龙虎榜活跃榜")                       
GET_NEWABNORMAL_ SEATSRANK ( code: "0102002",message："新龙虎榜席位榜")                     
```

```java
//老接口文档中出现的，但在项目龙虎榜接口中并未出现
GET_INFLOW_FUNDS(code:"0150001",message:"超级盘口获取净资金流入")
GET_ORG_RATING(code:"0151001",message:"超级盘口获取机构评级")
新版龙虎榜明细页概览 code：01040010    
新版龙虎榜明细页概览记录 code：01040020      
```









测试成功接口，且有相关实现

```java
//strategy/view/datacenter String
GET-MELARNORMAL- HOMEPAGEC code: "0227001"，message:"新龙虎榜首页"),

```

















### 22年4月





















#### 1日



从network中查看具体访问参数，对应到具体接口的实现方法。完成接口测试



步骤：

1. 带着没有过期的sistionId 先进入到首页
2. 然后F12进入下拉框中——>Network
3. 然后点对应的位置，在左下角找到刚刚刷新出来的Name
4. 点开查看Headers 一个是端口号cmdCode 还有入参param中的具体参数
5. comCode可以对应到代码中的端口(可认为此端口就是实际正在运用的端口)
6. 将入参对应到端口的实体类中，写好入参的，每个参数的注释

![image-20220401110124899](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204011101160.png)













```java
//二者共同出现的

GET_ABNORMAL_DETAILGRQUP( code: "0102001",message:"龙虎榜明细合计")，
GET_ABNORMAL_DETAILS( code: "0103001",message:"龙虎榜明细")，

GET_ABNORMAL_HOMEPAGECQUNT ( code: "0144001",message:"龙虎榜首页上榜股票条数")，GET_NEWABNORMAL_ ACTIVERANK C code:"0103002",message:"新龙虎榜活跃榜")                       
GET_NEWABNORMAL_ SEATSRANK ( code: "0102002",message："新龙虎榜席位榜")
```























































```java
0101001
"cmdCode" = "0101001"——>"龙虎榜首页"
GET_ABNORMAL_HOMEPAGE( code: "0101001",message:"龙虎榜首页")
param:{"tradeDate":"20220331","sortCol":"3","orderType":"-1"}
"tradeDate":"交易日期"
"sortCol"："排序字段"
"orderType":"排序类型"
```





```java
0103001
GET_ABNORMAL_DETAILS( code: "0103001",message:"龙虎榜明细")，
"windCode(股票代码)":"002761.SZ"
"endDate(结束日期)":"20220331"
"abnormalType(异常类型)":"04"
```





```java
0140001
GET_ABNORMAL_ORG_DETAILS( code: "0140001",message:"龙虎榜席位投资明细”)，
"orgId(机构id)"
"pageNo(当前页码，默认为1)"
"pageSize(每页个数)"
               
```

![image-20220401142057145](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204011420336.png)









```java
0141001
GET_ABNORMAL_ORG_STRENGTH( code: "0141001",message："龙虎榜席位綜合实力")，
orgId(机构id)
periods(周期；30-近一月,90-近一季，365-近一年，以多个逗号分隔):"30,90,365"
```





```java
0143001
GET_ABNORMAL_ORG_RANKINGLIST( code: "0143001",message:"龙虎榜席位排行榜")，
"periods(周期；30-近一月,90-近一季，365-近一年，以多个逗号分隔)":"30"
"pageNo(当前页码，默认为1)"
"pageSize(每页个数)" 
```





```java
//暂时可以不用管
0202001
SAVE_ACTION_LOG("0202001","提交功能点日志")
"action":"922600840008"
"items":[]
```





```java
0142001
GET_ABNORMAL_ORG_PREFERENCE( code: "0142001",message:"龙虎榜席位风格偏好"),
orgId(机构id)
"periods(周期；30-近一月,90-近一季，365-近一年，以多个逗号分隔)":"30"
```









```java
//暂未
0171002
获取前n个和后n个交易日
"baseDate"(基准日期):"20220401"
"prepN"(前n个):5
"afterN"(后n个):0
"version"(接口版本):2
```







```java
0102001
GET_ABNORMAL_DETAILGRQUP( code: "0102001",message:"龙虎榜明细合计")，
"windCode(股票代码)":"002761.SZ"
"pageNo(当前页码，默认为1)"
"pageSize(每页个数)":50 
```





```java
1000010
GET_PRICE_AND_CHANGE_DATA("1000010","现价和涨跌幅")
"tradeDate"(交易日期):"20220331"
"sortCol"(排序字段):"3"
"orderType"(排序类型):"-1"
```







```java
0104001
GET_ABNORMAL_BYSEAT$( code: "0104001",message:"龙虎榜根据席位统计”)，
"windCode"(股票代码):"002761.SZ"
"type":"3d"
```







```java
0105001
GET_ABNORMAL_BUY_BYSEATS( code: "0105001",message:"龙虎榜买入金额根据席位统计")，
"windCode"(股票代码):"002761.SZ"
"type":"3d"
```















```java
0102002
"cmdCode" = "0102002"——>"新龙虎榜席位榜"
GET_NEWABNORMAL_ SEATSRANK ( code: "0102002",message："新龙虎榜席位榜")
请求参数：

period(时间周期类型):0
seatType(席位类型):0
pageNo(当前页码，默认为1):1
sortCol(排序字段):0
sortFlag(排序标记):0
```

```java
0103002
GET_NEWABNORMAL_ ACTIVERANK C code:"0103002",message:"新龙虎榜活跃榜") 

period(时间周期类型):0
pageNo(当前页码，默认为1):1
sortCol(排序字段):0
sortFlag(排序标记):0
```



```java
0101000 新龙虎榜首页
"tradeDate":"交易日期"
"sortCol"："排序字段"
"orderType":"排序类型"
```









































#### 2日





搭建龙虎榜移植框架





1. 定义龙虎榜controller
2. 定义主mappeng——nomo
3. 入参api文档写清楚——看看是不是必须的，入参值代表什么
4. 看一下VO搞清楚返回的VO所有
5. 移植VO
6. 依次将所有的接口在下面按照此流程写出来







注意事项：

1. 路径参数为path要改为{参数}
2. vo中添加api文档生成注解
3. Do改为Vo





未完成任务：

1. 将VO对应老文档一个API及注释写出来，写到controller中的龙虎榜风格偏好
2. 对应浏览器看返回的集合名称包含哪些整体来一个API注释，对照项目其他别人VO写好的





































#### 7日



>龙虎榜代码移植问题







>后续需处理的细节



1. service添加传入参数注释，VO需要注释
2. 返回类型为包装类怎么改
3. 旧项目代码依赖在新项目中存在，则需要的就添加进去就好了，多考虑代码的复用
4. @PathVariable实际作用，还有参数的产生





>问题

1. 内嵌依赖AbnormalTradeService
2. StockMessageService
3. 返回包装类ExpoResult<Object> result问题
4. 最终测试返回数据

















#### 8日

确定龙虎榜移植大方向

1. 接口名称开头带新肯定是要直接沿用其逻辑
2. 接口返回类型还是为旧包装类型(沿用旧包装类)
3. 龙虎榜接口
   1. 从公司报表获取数据。
   2. 将数据保存到数据库。
   3. 再将数据从数据库中提取到内存有设置定时任务(0 - 24点每3分钟获取一次数据到内存)。
   4. 再从内存中获取对应数据返回。



>新龙虎榜首页如何改呢？

1. 省去中间环节
2. 直接从公司报表获取数据



注意：主要获取数据的逻辑还是可以沿用，也需要理清楚前端调用接口，再到接口返回数据的一系列流程还是要搞清楚，才能懂得如何改。











#### 13日

继续龙虎榜接口迁移任务



>将带“新”字的接口沿用老的项目先迁移



```java
0102002
"cmdCode" = "0102002"——>"新龙虎榜席位榜"
GET_NEWABNORMAL_ SEATSRANK ( code: "0102002",message："新龙虎榜席位榜")
请求参数：

period(时间周期类型):0
seatType(席位类型):0
pageNo(当前页码，默认为1):1
sortCol(排序字段):0
sortFlag(排序标记):0
```

```java
0103002
GET_NEWABNORMAL_ ACTIVERANK C code:"0103002",message:"新龙虎榜活跃榜") 

period(时间周期类型):0
pageNo(当前页码，默认为1):1
sortCol(排序字段):0
sortFlag(排序标记):0
```



```java
0101000 新龙虎榜首页
"tradeDate":"交易日期"
"sortCol"："排序字段"
"orderType":"排序类型"
```

















#### 14日





将接口文档整理

完成剩下的部分



>@关于@Pathvariable的参数允许为空（required = false）无法实现的问题

原文链接：https://blog.csdn.net/qq_37210826/article/details/88291087

![@Pathvariable](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204141040418.png)

按照上面的代码:

是希望如果不传id，

Integer id的id就为null，

可以查询所有学生信息。

但是发现，/student这个请求是过不来的，而且会报错。
首先**@PathVariable不能为空，不能设置默认值，因为null对于url是无意义的。**
此时有两种方法解决：
       

1. 方式一：将@Pathvariable换成@RequestParams，但是这种方法和预期效果有些差别。
2. 方式二：不能允许为空，但是可以变通。试了n次，发现/student和/student/{id}是两个不同的url，肯定是不能走同一个请求的。但是@RequestMapping是可以处理多个url的。于是将上面的@RequestMapping改成下面这样：![在这里插入图片描述](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204141040161.png)
   这样就是可以的，此时的required = false就可以起作用了。





















#### 15日



>新旧首页合并

1. conterller层调用同名不同参的service接口，和接口实现类
2. 将其整合为不同





>接口文档

- ```
  url最好是名词
  龙虎榜买入金额根据席位统计中type参数的注释
  
  pageSize全解释
  明细合计
  ```



到主站测试上传接口文档







>解决问题



需要解决三个问题

1. abnormalServicelmpl中方法传入参数转换can not cast to JSONObject问题
2. 解决传入参数从cloud报表问题，流程大致熟悉，主要去了解怎么去检查，个人觉得可能是cloud传入此方法出现了问题，会是传入参数这一块问题或者处理的问题
3. 关于新旧龙虎榜合并的问题：
   1. 考虑将参数一并传入(可能前端也需要改)
   2. 返回一个合并的结果集合,VO合并

0102002新龙虎榜席位榜

新龙虎榜活跃榜

0141001龙虎榜席位综合实力

0143001龙虎榜席位排行榜

0142001龙虎榜席位风格偏好

0102001龙虎榜明细合计

0104001龙虎榜根据席位统计



>今日完成

- 解决旧项目中对应到新项目中的相同方法，对应依赖的不一致的实现
- 和参数传递类型改变问题，获取userId之类的问题
- 测试接口所出现的bug
- 找出测试参数来测试接口
- 测试站访问不了，只是改了ip为那个域名http也访问不了
- 获取数据来调试。



>解决活跃榜

![image-20220415192519235](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204151925499.png)





>测试思路 测试首页->接口->传入参数->返回参数

>接口测试并未出现其它问题，返回值为null将相当于问题在cloud里拿数据的过程出问题

>改为就一个serveice和实现类









问题:

>为什么@Autoware下不能+static

















#### 18日



调试接口：

由于走缓存获取数据的接口内嵌依赖太过繁杂，贸然去分开获取数据，很可能会导致性能下降严重等问题





> 将接口分为两大类：

1. 数据没有经过缓存到cloud报表这样的复杂流程获取数据T
2. 一种就是经过缓存到cloud报表这样的复杂流程获取数据F







#### T类



##### 已正常使用



###### 0102002

```bash
"cmdCode" = "0102002"——>"新龙虎榜席位榜"
GET_NEWABNORMAL_ SEATSRANK ( code: "0102002",message："新龙虎榜席位榜")
请求参数：
period(时间周期类型):0
seatType(席位类型):0
pageNo(当前页码，默认为1):1
sortCol(排序字段):0
sortFlag(排序标记):0

```

###### 0103002

```bash
GET_NEWABNORMAL_ ACTIVERANK C code:"0103002",message:"新龙虎榜活跃榜") 

period(时间周期类型):0
pageNo(当前页码，默认为1):1
sortCol(排序字段):0
sortFlag(排序标记):0
```

















##### 未正常使用





















#### F类







##### 未通过





###### 0101001

```bash
0101001
"cmdCode" = "0101001"——>"龙虎榜首页"
GET_ABNORMAL_HOMEPAGE( code: "0101001",message:"龙虎榜首页")
param:{"tradeDate":"20220331","sortCol":"3","orderType":"-1"}
"tradeDate":"交易日期"
"sortCol"："排序字段"
"orderType":"排序类型"
```



###### 0141001

```bash
0141001
GET_ABNORMAL_ORG_STRENGTH( code: "0141001",message："龙虎榜席位綜合实力")，
orgId(机构id)
periods(周期；30-近一月,90-近一季，365-近一年，以多个逗号分隔):"30,90,365"
```

###### 0143001

```bash
0143001
GET_ABNORMAL_ORG_RANKINGLIST( code: "0143001",message:"龙虎榜席位排行榜")，
"periods(周期；30-近一月,90-近一季，365-近一年，以多个逗号分隔)":"30"
"pageNo(当前页码，默认为1)"
"pageSize(每页个数)" 
```

###### 0102001

```bash
0102001
GET_ABNORMAL_DETAILGRQUP( code: "0102001",message:"龙虎榜明细合计")，
"windCode(股票代码)":"002761.SZ"
"pageNo(当前页码，默认为1)"
"pageSize(每页个数)":50 
```

###### 0104001

```java
0104001
GET_ABNORMAL_BYSEAT$( code: "0104001",message:"龙虎榜根据席位统计”)，
"windCode"(股票代码):"002761.SZ"
"type":"3d"
```

###### 0105001

```java
0105001
GET_ABNORMAL_BUY_BYSEATS( code: "0105001",message:"龙虎榜买入金额根据席位统计")，
"windCode"(股票代码):"002761.SZ"
"type":"3d"
```























#### 19日



1. 继续迁移龙虎榜F类接口
2. 迁移加密孔雀开会用户信息接口。
   1. 主要功能是做session信息的加解密
   2. 把原来的接口调通
   3. 把逻辑理一遍
   4. 定义接口
   5. 迁移代码
   6. 测试接口
3. 小课堂bug

















#### 21日



龙虎榜F类接口移植



主站上线流程：

1. 



![image-20220421155241535](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204211552026.png)



![image-20220421155903319](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204211559735.png)



















#### 24日

测试站部署 + 申请fuse指标





























#### 25日

测试站部署de项目

了解CDN分布式缓存相关知识

http://180.96.8.44/activity/manager/wstockactivity.api.url=http://10.100.4.144:9090/activity/manager/

















#### 26日

升级服务

接入cdn服务的接口和前端页面编写



根据cdn金山云文档中编写

1. https://docs.ksyun.com/documents/203
2. API文档中
3. 域名基础配置
4. 添加加速域名







##### 类似AccountReviewAction



###### 此类注册功能实现步骤



> 1.jumpRegisterPag()

![image-20220426184240320](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204261842565.png)

1. 传入cellphone对应url和ModelMap model
   1. ModelMap对象主要用于传递方法处理数据到结果页面
      1. 结果页面上需要的数据放到ModelMap对象中即可
      2. 联系到对应接口就是需要将返回的RefreshTaskId
      3. model.set(“方法名”,RefreshTaskId)；





> registerTerminalUserDo()

![image-20220426184454868](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202204261844133.png)

1. 传入cellphone参数(对应url),HttpServletResponse response（http响应头）
   1. Web服务器收到客户端的http请求，**会针对每一次请求，分别创建一个用于代表请求的`request`对象、和代表响应的`response`对 象。**
      request和response对象即然代表请求和响应，那我们要获取客户机提交过来的数据，只需要找request对象就行了。要向客户机输出数据，只需要找response对象就行了。
   2. 调用依赖的accountReviewManager中的registerCrmUser()方法处理之后返回对应的结果码









总结思路：

1. 传入ModelMap对象用于传递方法处理的数据到结果页面，最终将加密后的RefreshTaskId返回
2. 传入url用于处理
   1. 校验：
   2. 截取url字符串头对应是否以http或者https开头
   3. 每个 Url 最大长度 1000 字符
   4. 每个 Url 所在的域名必须是该用户在金山云加速的域名。
   5. Url 如果包含中文字符，请使用urlencode方式提交。
   6. 单次调用文件类刷新 Url上限为1000条，目录类刷新 Url 上限为30条
   7. 支持Url及目录精确匹配，不支持正则匹配
   8. 接口仅支持POST请求格式
3. 请求访问cdn服务
4. 将返回的RefreshTaskId返回给结果视图。









#### 27日

客户端 -> 服务端，此时为服务端

但是在刷新缓存接口中要去请求cdn的服务，此时操作的服务端，则当成是客户端去请求cdn的服务端

>需要了解http结构

Http协议的组成
https://www.jianshu.com/p/866f33bdbb58

















#### 29日签名算法 + unicode转码

> CDN服务加密签名机制实现

##### AWS签名算法版本4

支持`GET`和`POST`两种HTTP方法，GET方法所有请求参数包括**signature放置在url中**，

POST方法则将signature**以名为Authorization header的形式放置在header中**

其主要区别在于**GET方式处理的请求url长度不能过长**。







###### 创建一个正规化请求

在签名前，首先将请求进行正规化格式化，目的是让签名计算过程无二意，其主要过程伪代码如下：

```
CanonicalRequest = HTTPRequestMethod + '\n' + CanonicalURI + '\n' + CanonicalQueryString + '\n' + CanonicalHeaders + '\n' + SignedHeaders + '\n' + HexEncode(Hash(RequestPayload))
```

Hash指代计算哈希的算法，目前使用SHA-256，HexEncode是对哈希值进行用16进制编码（使用小写字母）。



![image-20220429192436740](https://pic.836184425.xyz/note/master/202205211957492.png)



https://pic.836184425.xyz/note/master/202204291924097.png

>中文字符识别并转unicode编码



![image-20220506150747751](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061510746.png)

![image-20220506150737456](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061510985.png)





### 22年5月





#### 5日移植cdn的sdk



##### 移植刷新缓存服务核心



###### 加密



###### HTTP请求





![image-20220505185805136](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205051858303.png)









#### 6日密码获取 + Java魔法值

在配置文件中写入配置信息，利用@value注解获取写入的信息。



##### @value{配置信息名}



###### 写入配置文件

将公司对应的dbSource和userID参数写入到配置文件并自定义名称格式参照下图中配置文件写入的格式

![image-20220506105052674](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061050889.png)

![image-20220506105023684](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061050918.png)





###### 读取信息

![image-20220506105320833](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061053026.png)

在类中定义一个变量，利用@Value注解{自定义名称}读取到写入到配置文件的相关信息







###### 密码读取

如果是读取密码服务的话还需要调用上述passwordServiceUtil中的getPassword方法

获取返回的值。





###### 记录日志

注：密码相关打印日志时，考虑到**安全性**的问题，**记录密码长度**即可，无需将密码打印出来

![image-20220506114327164](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061143348.png)

![image-20220506113126243](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061131453.png)



![image-20220506112452336](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061124586.png)

![image-20220506114257090](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061142356.png)

















###### 魔法值问题

> 什么是JAVA魔法值?

JAVA魔法值又叫做：魔法数值、魔法数字、魔法值；

其实就是一句话：指在代码中==**直接出现的数值**==



>看一段代码

```java
public static List<String> getRangeDayOfWeek() {
        List<String> list = new ArrayList<>();
        // 日期格式转换
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
        // 时间调整到本周一
        Calendar instance = Calendar.getInstance();
        instance.set(instance.get(Calendar.YEAR), instance.get(Calendar.MONDAY), instance.get(Calendar.DAY_OF_MONTH), 0, 0, 0);
        instance.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY);
        //循环打印
        for (int i = 1; i <= 7; i++) {
            list.add(sdf.format(instance.getTime()));
            instance.add(Calendar.DAY_OF_WEEK, 1);
        }
        return list;
    }
```



![image-20220506152700868](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061527066.png)







>再看一段代码

（以下代码不叫魔法值，只是会降低代码阅读理解效率，所以我们可以知道魔法值主要针对那种经常使用且具有特殊含义的数值）

![image-20220506152745924](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061527153.png)





>**代码1解决办法**

使用static final 定义常量或使用enum值

```java
static final int WEEK_DAYS= 7;
```

注：使用static final 声明常量，可以方便以后维护更新。修改变量的值时只用修改一处，还不用担心修改了其他不该修改的常量。











###### **总结**

魔法值的问题对于代码逻辑来说，并不是什么要命的事情，即使不修改也基本不影响代码的正常运行，我以前没有安装阿里代码检查规范时，一样这么使用，也没出现过啥问题。好吧，应该说但是了。但是，遵循公认的代码规范，可以有效的避免开发过程的一些小问题（最让人头疼的往往都是一些小问题引起的），提升开发的效率和代码的可阅读性，老老实实按照规范来，自然就会受益良多，继续加油！







>范例

![image-20220506160301508](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061603756.png)



解决方法：
![image-20220506160316820](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061603991.png)

注意：由于在方法中marketValue的值不固定，这里不能使用`final`











![image-20220506191330508](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205061913724.png)











#### 7日完善接口+主站部署



> 前端页面输入框显示默认值

![image-20220507133716169](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071337375.png)

注：**输入的value不能超过输入框长度**，否则不显示



>输入框显示提示信息，输入则消除

![image-20220507134841289](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071348481.png)



![image-20220507134924895](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071349103.png)

输入信息后提示信息消除



>提示弹窗

![image-20220507140028317](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071400504.png)



显示结果

![image-20220507140102320](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071401495.png)





>调用BaseResult中的相关方法显示弹窗



![image-20220507153815034](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071538362.png)









>前端代码进行断点调试

![image-20220507180021523](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071800748.png)



>@Value注解常用用法

```java
//常量
@Value("#{1}")
private int constant;
//从属性源取值
@Value("${test.name}")
private String name;

//从属性源取值
@Value("${test.name2: defaultname}")
private String namedefault;

//从容器中获取bean的的属性值
@Value("#{developerProperty.name}")
private String dname;

//从指定属性源获取属性值(jvm属性)
@Value("#{systemProperties['spring.application.json']}")
private String systemPropertiesjson;

//从指定属性源获取属性值（系统环境属性源）
@Value("#{systemEnvironment['HOME']}")
private String systemEnvironmentHOME;

//从指定属性源获取属性值 默认值
@Value("#{systemEnvironment['HOME22']?:'default'}")
private String systemEnvironmentHOMEdefault;

//获取随机值
@Value("${random.int.5,100;}")
private Integer randomint;
```







![image-20220507173150344](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071731575.png)







![image-20220507190348697](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205071903876.png)













#### 10日总结cloud + 走读接口代码

![image-20220510145330675](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101453096.png)



![image-20220510153358140](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101533364.png)





![image-20220510191403227](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101914489.png)





![image-20220510195959154](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101959417.png)







#### 11日修改代码规范 + 密码服务 + 主站申请Fuse指标接口地址问题



![image-20220511182225317](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205111822503.png)







#### 12移植一图透视接口

1. shar服务测试站部署
2. 移植接口















#### 申请fuse指标



申请一图透视fuse指标











#### 16日 抓包+跨域请求

![image-20220516211315025](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205162113237.png)

```http
https://docs.spring.io/spring-framework/docs/3.0.x/javadoc-api/org/springframework/web/client/RestTemplate.html#getForObject(String,%20Class,%20String...)
```



```java
The map variant expands the template based on variable name, and is therefore more useful when using many variables, or when a single variable is used multiple times. For example: Map<String, String> vars = Collections.singletonMap("hotel", "42");
 String result = restTemplate.getForObject("http://example.com/hotels/{hotel}/rooms/{hotel}", String.class, vars);
```

















#### 17日

1. 跟进cdn刷新缓存服务测试进度
2. 删除dyh-web项目冗余字段
   1. cmdCode = 0195001 <!--adLastUpdateName,adLastUpdateId-->
   2. cmdCode = 0146001 <!--operatior,updateTime-->

![image-20220517180510742](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205171805942.png)



  



#### 18日

1. 测试删除冗余字段后接口返回数据
2. Intelligent测试站部署
3. cloud代码拉取及基本运行环境搭建



![image-20220520194419757](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205201944173.png)











#### 23日单元测试作业+













#### 25日移植涨停接力接口

![image-20220526192810204](https://pic.836184425.xyz/note/master/202205261928447.png)



1. 排序字段参数总共是0-6对应6个字段进行排序
   1. 总结测试问题：测试只测了前三个字段就返回数据没有问题就认为没有问题
   2. 不要怕麻烦测试数据要尽量测试到所有的情况
2. 更换share项目中的请求报表数据方法获取不到值
   1. req + “sourceappid=1521”;
   2. 也有可能传入的时间有问题在测试站中的报表并没有对应时间的值
3. mybatis-plus根据传入limit_num字段值作为条件查询对应的所有值







#### 27日

![image-20220527191601557](https://pic.836184425.xyz/note/master/202205271916899.png)











#### 31日shar和in



![image-20220531175247354](https://pic.836184425.xyz/note/master/202205311752599.png)





发送接口邮件需要详细说明

1. 接口名称及API
2. 是否有参数改动等信息















### 22年6月





#### 01日cloud测试tool

> 要求：

1. 前端传入command和excel文件，写入到数据库
2. 前端传入command，按提取按钮获取的Json格式的数据



>获取excel文件

![image-20220602160431927](https://pic.836184425.xyz/note/master/202206021604143.png)



从wind老客户端中获取excel文件

![image-20220602160322430](https://pic.836184425.xyz/note/master/202206021603707.png)





#### 02日tool

>先写后端代码

1. controller编写完成
2. service和实现类框架初步搭建
3. mapper
4. 设计数据表command + data





>注意：

接收到前端传入的excel文件先使用工具类转换为Json格式的数据再传入保存到数据库中





>mapper

1. 传入命令读取：select data from tb_cloud_test where command = #{command};
2. 传入命令插入数据：insert into tb_cloud_test 
   1. 经典插入：insert into 表名(列名,…)values(值1…);



Excel工具类地址：

https://stackoverflow.com/questions/52474086/converting-excel-file-xlsx-into-json

https://www.freesion.com/article/1629881017/















#### 15日反向equals



##### 反向equals

反向equals，杜绝空指针的存在

正确使用 equals 方法避免产生空指针异常

https://www.jianshu.com/p/306de20dd228

1. Object的equals方法**容易抛空指针异常**，**应使用常量或确定有值的对象来调用 equals**。

2. ```rust
   // 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常
   String str = null;
   if (str.equals("SnailClimb"))
   ```



>`java.util.Objects#equals`的源码

```java
public static boolean equals(Object a, Object b) {
        // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。
        return (a == b) || (a != null && a.equals(b));
    }
```



>异常解决方案

Reference:[Java中equals方法造成空指针异常的原因及解决方案](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Ftick_tock97%2Farticle%2Fdetails%2F72824894)

- 每种原始类型都有默认值一样，如int默认值为 0，boolean 的默认值为 false，**null 是任何引用类型的默认值**，不严格的说是所有 Object 类型的默认值。
- **可以使用 == 或者 != 操作来比较null值**，但是不能使用其他算法或者逻辑操作。在Java中`null == null`将返回true。
- **不能使用一个值为null的引用类型变量来调用非静态方法**，否则会抛出异常



 







#### 24日

> 平台二维码 + 更换枚举类bug + 涨停接力两接口测试提交



##### 更换枚举类bug

不使用直接暴力的数值，而使用枚举类型get对应的值



#####  涨停接力两接口测试提交

判断是否为本地dev方法被注释，导致直接走expo获取数据。

解除注释走dev情况请求测试工具中的数值即可



##### 二维码问题



###### 需求

> Input框中输入的url，将此url生成一个二维码

当url过长，生成的二维码越密集，达到一定值之后二维码被定义为固定的大小是扫不出来的。

需要将其设定为一个弹窗，每次生成二维码内容为一个可以根据url的长度生成不同大小的二维码弹窗用于正常扫描。



###### 思路

点击生成二维码按钮即可触发 function showQRCode()方法

1. 理清代码实际运作和每行代码的用意
2. 点击生成二维码按钮时，触发此showQRCode()方法想办法控制二维码大小
3. 点击(生成二维码)按钮触发弹窗
4. 取到jumpUrl.length() * 自定义倍数，并设置最大倍数和最小为80 * 80



###### 理清代码层级以及意义

>jumpUrl为输入的需要生成url的二维码

```javascript
//变量jumpUrl的值是用input框(#jumpUrl)中输入的去除前后多余空格的值
var jumpUrl = $("#jumpUrl").val.trim();
//
$('#qrCode').html("")
//
var qrcode = new QRCode(document.getElementById("qrCode")), {
    width:80,
    height:80
});
//
qrcode.makeCode(jumpUrl);
```

当点击生成二维码按钮触发以上内容



>待解决问题

> 问题：底部div也根据变量自由变换

![image-20220627140228061](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202206271402251.png)

通过`$(‘#id名称’).方法(变量值)`的显示定义变量为长和宽即可





> 问题：关闭按钮不显示

原因：是生成二维码插件生成二维码直接将此按钮填充挤出去

解决：

1. 将此按钮与二维码对应的容器拉出为同级容器
2. 并在二者外层再定义容器







> 扩展

![image-20220627141557055](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202206271415210.png)

transform：https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform-function/translateX

解释上述关于div居中的语句

```css
//这两个可以理解一个没有大小的原点
//上下左右现在都是居中的(没有包含div的大小计算)
top: 50% + left 50%

//而transform是针对这个div元素来作用的
//对应div的50%也就是x轴-50%个div,y轴-50%个div
transform: translateX(-50%) translateY(-50%)

总结：刚好这两句在页面居中此div!!!
```

![image-20220627141820097](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202206271418254.png)











>查看java进程

[***java项目启动\*、\*查看\*、关闭 \*linux\*命令**](https://blog.csdn.net/weixin_43956692/article/details/123021833)

2022-02-19 18:13:17

##### 启动

```
 nohub java -jar   xxx.jar 或
 java -jar xxx.jar --server.port=8080 
```

###### 查看

```
 ps -ef "java -jar"
```

##### 杀进程

```
kill -9 [pid]
```

注：nohub 为后台启动
{–server.port=8080 为启动时添加临时属性，【上面为临时修改端口】多个属性用空格分隔}
pid 为java进程号





例如

```java
java -jar XXX.jar(执行jar具体名称) --server.port=8113(项目端口号)
```











#### 28日新测试站配置测试

新测试站配置文件配置与部署环境检测



##### 修改完配置文件部署回滚失败

>1.查看部署日志

1. 直接搜error查看具体相关
2. 由于stop脚本中的命令并不是`kill -9 进程号`强制杀死进程
3. 此进程一直存在占用，所以导致回滚失败



```bash
#1.最上面才是进程号
ps -ef|grep DataShareService

#2.强制杀死进程
kill -9 进程号

#3.软件仓库重试
```



>linux测试本机服务端口

```bash
curl "测试地址"
```













#### 29日配置项目新测试站环境

```bash
#进入文档
man 指令

#关键字搜索
/关键字

#按n即为搜索的下一个

#按q退出界面
```



```bash
#默认get请求 
curl -X GET "请求url"
curl -X POST "请求url"
```









#### 30日新测试站任务







### 22年7月



#### 4日

> 出现问题

["Data truncated for column"错误](https://www.cnblogs.com/KingStar/archive/2011/03/10/1979801.html)

遇到Data truncated for column这个错误，按照网上的方法，从两个方面去解决

一、添加字符长度（我的字段类型为text），所以不存在这个问题。

二、更改字符类型为utf8（已经是UTF8）

最后终于发现mysql还有一种字段类型为longtext，设置字段为longtext后，问题解决了。原来我插入的字符串太长了，连text都接受不了，要设置为longtext.

cloudtest工具中插入数据时提示字段过长

解决：将表中字段改为longtxt类型即可



longtxt类型大字段可能引发的性能问题:https://www.modb.pro/db/62476



#### 5日



> 1 查看CPU个数

```bash
#uniq命令：删除重复行;wc –l命令：统计行数
cat /proc/cpuinfo |grep “physical id” | uniq | wc -l
```

2

> 2 查看CPU核数

```bash
cat /proc/cpuinfo | grep “cpu cores” | uniq
```

cpu cores : 4

> 3 查看CPU型号

```bash
#查看CPU型号
cat /proc/cpuinfo | grep ‘model name’ |uniq
```

model name : Intel® Xeon® CPU E5630 @ 2.53GHz

总结：该服务器有2个4核CPU，型号Intel® Xeon® CPU E5630 @ 2.53GHz



>4 查看内存总数

```bash
#查看内存总数
cat /proc/meminfo | grep MemTotal
```

MemTotal: 32941268 kB //内存32G



>5.查看硬盘

```bash
lsblk
```

SIZE 600G 

![image-20220705174721177](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202207051747382.png)







#### 6日实例运行内存占用过高

实际上在公司实例上重启实例并重启自动化部署程序即可解决

还有就是：原文链接：https://blog.csdn.net/weixin_51003946/article/details/117285031

```bash
[root@localhost ~]# sync   #将缓存数据写入到磁盘中  ##多执行几次
#以下三条需要权限
[root@localhost ~]# echo 1 > /proc/sys/vm/drop_caches   #清空页缓存
[root@localhost ~]# echo 2 > /proc/sys/vm/drop_caches   #清空inode和目录树缓存
[root@localhost ~]# echo 3 > /proc/sys/vm/drop_caches	#清空所有缓存。
```



```bash
#查看内存使用情况
free -g
```













#### 7日分析接口获取不到数据原因

>java中的NIO

https://docs.oracle.com/javase/8/docs/api/java/nio/package-summary.html



#### 8日

>发邮件任务

统计昨天[18:00-18:00]中购买产品的用户id和购买的商品类型





#### 12日订单管理任务



##### 思路

1. 将所需查询的所有数据表，大致搞懂所有字段的意思

2. 理清表与表之间关联的字段相关关系

3. 整合所有的筛选条件，编写一条总的sql

4. 利用mybatis的动态sql进行编写

5. ```xml
   <if test="变量 != null">
       and D.字段=#{变量}
   </if>
   ```



##### 注

https://mybatis.org/mybatis-3/zh/sqlmap-xml.html



类型处理器的配置元素上增加一个 `jdbcType` 属性（比如：`jdbcType="VARCHAR"`）；

| 属性          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| `property`    | 映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。 无论是哪一种情形，你都可以使用常见的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 |
| `column`      | 数据库中的列名，或者是列的别名。一般情况下，这和传递给 `resultSet.getString(columnName)` 方法的参数一样。 |
| `javaType`    | 一个 Java 类的全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 |
| `jdbcType`    | JDBC 类型，所支持的 JDBC 类型参见这个表格之后的“支持的 JDBC 类型”。 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。 |
| `typeHandler` | 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。 |



>mybatis支持的jdbcType类型有：

#### 支持的 JDBC 类型

为了以后可能的使用场景，MyBatis 通过内置的 jdbcType 枚举类型支持下面的 JDBC 类型。

| `BIT`      | `FLOAT`   | `CHAR`        | `TIMESTAMP`     | `OTHER`   | `UNDEFINED` |
| ---------- | --------- | ------------- | --------------- | --------- | ----------- |
| `TINYINT`  | `REAL`    | `VARCHAR`     | `BINARY`        | `BLOB`    | `NVARCHAR`  |
| `SMALLINT` | `DOUBLE`  | `LONGVARCHAR` | `VARBINARY`     | `CLOB`    | `NCHAR`     |
| `INTEGER`  | `NUMERIC` | `DATE`        | `LONGVARBINARY` | `BOOLEAN` | `NCLOB`     |
| `BIGINT`   | `DECIMAL` | `TIME`        | `NULL`          | `CURSOR`  | `ARRAY`     |











#### expo



###### expo构建过程

1. 服务端B接收由客户端A从expo传递过来的前端参数
2. 打开本地配置文件夹中的/etc/expoConfig.xml –> 查看此项目的编号
   1. APPClass Value=“专属编号”
3. 编写接口信息到apiDefine配置文件中
   1. 注：部署的时候还需要再svn对应目录中添加一遍
   2. 专属于方法对应方法的commandID
4. 定义Expo基础继承类`ExpoBaseService`
   1. 初始化一个key(定义的commadId),value(加了expo定义注解的类名和方法名)。
   2. 接下来就是验证的步骤：
      1. 验证方法是否加了`@commandDefinition`注解不是就不扫
      2. 验证方法是否有效，验证是否为空。无效也不添加
5. cmid注解定义
   1. 定义此注解用来表示是走expo协议的方法，标识要被上述基础继承类加载到map中
   2. 记得一定要在对应方法中加上此注解，并填写好注解值
6. 监听器：
   1. expo总线回调找到对应commandId中的集中对应方法
   2. 也就是你客户端发送消息(带有commandId)
   3. 然后到总线，总线负责帮你找到对应此id的方法。
   4. 去调用它，把它的返回结果集传输给你







###### 客户端

1. 服务端param参数处理完毕返回给客户端(resultCode自定义消息(例如code(判断是否成功) + massage(返回结果集)

1. 在另外一个项目中定义客户端连接expo，找到对应commandid的方法
2. 传入前端输入的处理完毕的参数
3. 调用对应服务端的接口方法
4. 通过expo传输拿到结果集



###### 服务端

1. 通过总线传来的前端参数
2. 正常定义相关的service、实现类、mapper
3. 此部分没有什么不同
4. 调用Servce返回出去结果集通过expo传输给客户端







19日完善管理平台任务









> 启动调用方法报错 :java.lang.UnsupportedOperationException
>
> 错误原因为:resultType是直接表示返回类型的


应该改为： 注意:   这里的resultType="String"

<select id="getStudentScore" parameterType="String" resultType="String">
      select score from student_score where student_id=#{stuent_id,jdbcType=VARCHAR}
</select>

原因就在于resultType代表的是List中的元素类型，而不应该是List本身,不要对于dao接口生命的List<String> 就误以为返回的是list,返回的应该是元素本身的类型


注意:resultType返回的是集合中的元素类型，而不是集合本身

注意:如果是集合情形,那应该是集合可以包含的类型,而不能是集合本身
原文链接：https://blog.csdn.net/sunshinezx8023/article/details/78403011





>mybatis中不存在else，只能通过等效代换来实现

**是MyBatis中的if....else...表示方法**

[![复制代码](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202207191703692.gif)](javascript:void(0);)

```
<choose>
    <when test="">
        //...
    </when>
    <otherwise>
        //...
    </otherwise>
</choose>
```

[![复制代码](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202207191703692.gif)](javascript:void(0);)

注意：当你传入的值例如select #{a}这个a又需要<if>判断才能确定值的时候

也就是并没有一个明确的值则，最好用这样的等效替换确定给到一个值，select null自然会报错。











[**mybatis 查询中使用变量作为列名**](https://blog.csdn.net/qq_34707456/article/details/106711926)*千次阅读*

2020-06-12 11:16:27

1.操作方式：

  在mybatis xml中使用 ${列名/表名} 而不是 #{列名/表名}

 说明：${} 只是简单的字符串替换，#{}则是预编译。

 

2.产生问题：

 问题：${}会产生sql注入问题。

 解决方式：

​       1.如果只是select 语句 ，可以在service方法中添加 @Transactional(readOnly = true) (只读事务），也可以在service方法中限制列名和表名的范围。

​       2.如果是insert update delete语句，只能在service方法中限制列名和表名的范围。











#### 25日



>1.合并出错

1. 新建合并代码脚本,复制其它项目合成脚本
2. 修改其中的项目名为此对应项目吗和地址
3. 尝试合并出错



解决

第一次执行脚本前，需要创建的分支才可

1. 执行创建分支脚本

2. ```bat
   svn copy 下载地址/dev/ 下载地址/release/ -m "Creating a private branch"
   ```

3. 执行完毕



再次创建出现代码冲突，合并失败

1. 删除release分支的代码重新拉取代码
2. 解决代码冲突
3. 再次合并成功



>项目接入eagle服务

1. 迁移datashare中关于eagle服务的代码，并添加相关maven
2. 修改配置文件并添加到release分支中
3. 将配置文件中定义获取项目变量@value{值}
4. 部署测试站打开Eagle-S 新测试站进行访问，发现有一个实例的eagle插件并未安装
5. 发运维邮件，完成安装
6. 晚上要升级主站并结束相关工单



>operation项目构建失败

查看日志——>查看详细邮件

是JSON版本的漏洞,对应升级到没有漏洞的版本即可

重新构建，构建成功



>再次部署测试站(新增订单管理)

1. 请求得到，但是发现显示后台服务异常
2. 预测是businesscharge由于部署构建两个地址项目名称不太同导致部署错误
3. 对应集成版本找对项目部署正确地点
4. 应该再部署的时候项目名为—business_charge
5. 在构建集成的时候是对的



>主站升级

1. BusinessService + CrmService (接入Eagle监控系统)
2. operation + BusinessCharge (增加订单详情管理功能)



>应用实例申请

1. 软件仓库
2. 各项申请
3. 应用实例申请
4. 对应对应申请主站和测试站的实例，如果搜不到则查看一下是否已经和应用绑定
   1. 绑定校验
   2. 在软件仓库—应用管理—对应项目点击中间的查看即可看到的实例都是已绑定实例
5. 最好选择当天值班运维，并发起工单









#### 26日数据库相关申请

>学习Win.d只是管理系统数据库脚本升级规范注意事项

为了配合数据库脚本自动升级,部署需要满足以下规范

1. 目录规范
   1. 部署文件必须在当前目录下
   2. 例如：/wind/wind.share.db/update_20211026.sql
2. 项目命名规范(一般全为小写并且单词之间以下划线_分隔)
   1. 例如：wind_share_db
   2. 注：项目名不允许用点分隔
3. readme.txt 文件部署规范
   1. 在当前目录必须有/wind/wind.share.db/readme.txt
   2. 注：不允许放在项目中的子文件下
   3. 格式：数据库名,文件名,端口号
   4. 每次升级必须更新readme.txt
4. 如果部署在根目录下必须带有时间戳.例如update_20211026.sql
   1. 如果在子目录下则无此要求



>梳理具体申请流程步骤已经注意事项

1. 申请mysql数据库实例(主读写，从读)
   1. 跟进申请工单
   2. 与应用绑定实例
   3.  软件仓库查看项目对应实例状态为停用–发送运维邮件启用应用实例
2. 创建数据库实例
   1. 找王锐在绑定的数据库实例上建库配置数据库账号
   2. 库名就是IP地址
3. 申请密码服务
   1. 主站找陆敏(2)，新测试站找南京运维
4. 开通堡垒机访问权限
   1. 找王锐开通堡垒机访问权限
   2. 注意：数数据库都需要走主站堡垒机访问



>修复显示数据时间下拉框重置bug,并完善相关提示

下拉框搜索后被重置，将对应前端中增加id，让名称修改为小驼峰命名即修复

原因分析：

​	应该是ftl框架在表单提交做了一些内置的处理，暂无深究



>管理平台和收费服务主站升级





>处理迭代bug，日志打印用{}包含变量，精致使用+拼接

修改为{}参数化形式







#### 27日生成sessionid任务

>任务概述

- 当用户注册登录之后进入(此时能够获取到用户信息)
- 然后生成一个sessionId返回给前端，在规定时间内访问通过校验此sessionId
- 即可通过校验

注意：

1. 需要在接口实现类中定义一个线程安全hashMap利用static声明为全局变量
2. 只要进程不崩溃，则一直存在
3. 返回给前端一个String类型的sessionId
4. 下次携带则通过校验map中的value部分的用户信息则可以验证
5. key为sessionId，而value部分存储一个DTO类型对象存储相关用户信息





>具体步骤

在登录校验完成之后，传入用户信息对象类，进入创建的service中







#### 27日mysql查询近一个月的数据
https://blog.csdn.net/AlbenXie/article/details/108117155

```sql

//包含当天
SELECT * FROM 表名 WHERE DATEDIFF(字段,NOW()) <= 0 AND DATEDIFF(字段,NOW()) > -n;
//不包含当天
SELECT * FROM 表名 WHERE DATEDIFF(字段,NOW()) < 0 AND DATEDIFF(字段,NOW()) > -n;
https://blog.csdn.net/AlbenXie/article/details/108117155
```

>思考mysql不走索引的七大注意事项

1. 需要加入函数处理，只能加到数值上，不要加载对应数据库字段中
   1. 否则索引失效





>在linux脚本中打印日志

[(159条消息) 如何在shell脚本中优雅的打印日志_阿胜4K的博客-CSDN博客_sh脚本打印日志](https://blog.csdn.net/xys2015/article/details/114105281)





>思路优化

1. 考虑给时间字段建立非聚簇索引
2. 查询时间语句字段不能加上函数处理，否则不走索引
3. 导出拼接语句优化
4. 导出直接为excel文件格式
5. 日志打印到位
6. 删除多余注释，完善代码格式







#### 28日申请184网段服务器

1. 沟通184特殊网段申请材料的具体内容，以及虚拟机分布情况
2. 填写并提交crm项目特殊网段服务器工单
3. 排查business项目测试站与主站nginx不通的原因并与运维沟通
4. business主站升级并测试是否为代码未合并导致nginx访问不通
5. 完善优化订单管理任务相关代码 – 30%
   1. 剩余导出excel文件问题
   2. 优化查询时间范围sql
   3. 时间字段创建索引
   4. 利用索引优化
   5. 达到主站查询22w以上数据时间为1s以内







### 22年8月



#### 1日(继承Swagger3) + 接入3C直播信息接口





##### 集成swagger2接口文档自动生成增强版本

>1.版本

首先springboot版本不能超过6.0否则将引发版本冲突！

示例为2.5.1

```xml
            <!--Swagger2接口文档自动生成增强版-->
            <dependency>
                <groupId>com.qcloud</groupId>
                <artifactId>cos_api</artifactId>
                <version>5.6.54</version>
                <exclusions>
                	<exclusion>
                    	<artifactId>swagger-annotations</artifactId>
                        <groupId>io.swagger</groupId>
                    </exclusion>
                </exclusions>
            </dependency>
            <!--解决版本冲突,统一引入版本-->
            <dependency>
                <groupId>io.swagger</groupId>
                <artifactId>swagger-annotations</artifactId>
                <version>1.5.22</version>
            </dependency>

```



>2.配置

1. 建立Swagger3Config的配置文件对应进行配置
   1. 是否开启
   2. 设置名称
   3. 设置api元信息设置
   4. 选择哪些接口可作为doc发布内容
   5. 加载接口存放目录
   6. …
2. 构建api文档的详细信息
3. 在yml中定义相关配置

```xml
#.yml文档配置
knife4j
	markdowns: classpath:markdown/*
	#是否开启swagger
	enable: true
	#是否需要登录账号密码
	basic:
		enable:true
		username:自定义
		password:自定义
```





>3.登录主站数据库确认用户是否有相关购买记录

```bash
/usr/local/mysql/bin/mysql -h 10.20.165.27 -uwindin -pjimchen
```









>4.枚举返回类型

1. 返回基础的即可
2. 请求成功(有没有数据都返回ok)
3. 请求异常枚举
4. 获取session失败
5. 客户端参数错误







#### 2日排查触发数据库连接且异常原因 + 试用期自评



>主站数据库异常原因

1. 配置问题——删除密码，希望触发密码服务打印相关添加的日志
   1. 进入方法前
   2. 执行方法加入try捕获异常
   3. 排除密码服务获取不到密码
   4. 排除网络端口不通
2. 之前未触发，很可能是springboot版本2.7测试接口不涉及数据库获取数据就不会触发连接
3. 而更改2.5后，项目启动时便会自动触发连接





>编写试用期自评

按部就班



##### 总结主站触发异常原因

1. 总线的IP地址不对
2. 数据库连接库名不对
3. 之前没有发现是因为2.7的boot版本可能与数据库连接是分离的















#### 3日接入3c分析师栏目数据



>1.试用期第一次自评

1. 编写工作成果
2. 修改排版格式
3. 检查提交为工单附件



>2.禅道任务

1. 整理接口文档发送swager测试站地址及主站地址等发送邮件任务
2. 接口实现类添加注释任务
3. 

>3.服务器申请工单跟进

目前工单进度为——服务器上架申请(至IT部门)



>4.3C分析师栏目直播数据接入

1. 询问3C相关人员并确认接入分析师栏目数据
2. 确认接入HTTP接口(expo接口南京站点可能获取不到数据)
3. 使用ASC加密算法



接口实现：

1. POST请求接口
2. 将请求体参数放到body(参数类型为json)
   1. appid为3C提供固定id
      1. 使用3C提供的seckey加密
      2. 将接口参数使用ASC加密算法进行加密
   2. 放入到paramSign字段中
   3. Java版本必须在1.8_200以上
   4. requestMethod请求方法参数为固定值
   5. 请求协议版本为2.2.0
   6. 传入任意UUID
3. 最后将所有参数拼接成一个JSON参数完成请求
4. 再将请求返回的字符串利用转换方法转换获取data数据(以下`map.get(“data”))`获取放入到`resultVO.setdata()`中
   1. Map<String,String> map = `JSON.parseObject(value,new TypeReference<Map<String,String>>)`
5. resultVO的data字段















#### 8日新服务器环境测试











