入职培训
===

```xml
    <repositories>
        <repository>
            <snapshots>
                <enabled>true</enabled>
            </snapshots>
            <id>central</id>
            <name>Central Repository</name>
            <url>http://10.100.1.27:8688/repository/maven-public/</url>
        </repository>
    </repositories>
    <pluginRepositories>
        <pluginRepository>
            <id>central</id>
            <name>Central Repository</name>
            <url>http://10.100.1.27:8688/repository/maven-public/</url>
        </pluginRepository>
    </pluginRepositories>
```







入职培训2.28

#### 今日心得



心得

工作中只有用心做事，才能学到更多，学到的任何技能和知识都可能成为自己未来的生存工具，工作是-个人生存的手段，是幸福人生的保障，没有工作生活会变得怎样用心工作，过好每一天，干好每一件事，总有天会有所收获，对自己没有坏处。

中午睡了一下，但是脑海中还是对上午培训的老师说到万得的万得价值观：要正、要严、要爱、要美，这句话记忆深刻。从刚向万得提交简历的时候，我对万得的感受仅仅是公司比较大等等，但是到后来才发现，一个企业要想做大不但需要的是竞争力，还有自己的核心价值观。一个人在工作中，除了对自己的事业有着严格的标准要求，还需要对自己的价值观也同样有着高标准的要求，万得的价值观，深深的感染了我，其实有时候人就是这样，可能不经意的一件事，会让人感触良多。要以万得的价值观影响自己的价值观，向高标准严要求看齐。

工作不仅是为了拿份薪水，还为了成长和快乐。不要仅仅为了薪水而工作，还应该为梦想而工作，为自己的前途而工作，在以后的工作中只有踏踏实实的干，用心去干，有责任感，才能把工作做得更好

 

2022年2月28日星期一

李浩  









#### 第一堂课

万得(金融大数据)

超过40座主要城市设立办事处







> 万得产品线

1. 金融数据——金融终端，云端资管系统…
2. 商业数据——数字政府，企业库…
3. C端产品——万得股票，万得理财…









>理想，使命与价值观

理想：做一家让数据垂手可得的全球企业

使命：

价值观：要正、要严、要爱、要美





>品牌Logo

Win.d，2018启用









>全面薪资

综合薪资(固定 + 浮动)

预评职级(面试表现等)  +  所在部门在上一年综合价值 + 绩效考核(每季度)  +　工作时间(不满一年则按照入职时间比例计算)  = 在职激励奖金(年终奖)





>接班人计划

从入职到试用期结束都可以咨询或寻求辅导帮助





>福利活动

1. Wind特别关怀假：生日当天若为工作日可带薪放假
2. 直系亲属住院，可陪护2天
3. 年度体检2年依次
4. 弹性半小时8:30 - 9:00    5:30 - 6:00
5. 伯乐之路：介绍新人面试成功后可以得相应奖金 







>评级

1级为应届

2级为工作年限一般为两年

- 6级18档

可通过登录万得之家查看评级。







>转岗计划和轮岗计划

可申请面试通过后可转至异地







>一楼人脸识别

万得之家——福——录入人脸一小时后生效







>银行卡号提供

银行卡填入对应工单中



>仔细阅读员工手册

万得之家PC端







>域账号与密码

默认登录密码：wind2010











中午休息时间

11:40 - 1: 00







员工手册2018年8月版

2020年度总经理办公室第004号文件——个人目录规范及日常备份要求

2020年度总经理办公室第002号文件——全体员工完成个人数据备份及SVN项目库搭建的通知

001号文件——正气铸就伟业

001用美丽雪花

















> 6楼培训











### 金融知识





#### 证券

> 了解证券

除了股票属于证券，实际上在日常生活中充值卡，还有邮票，法律认可的,并且存有自身交换价值的都可以称之为证券。



证券是指各类

**证券**，是多种经济权益凭证的统称，也指专门的种类产品，是用来证明券票持有人享有的某种特定权益的法律凭证。**证券**主要包括资本*证券*、货币*证券*和商品*证券*等。





##### 证券市场

证券市场是股票、债券等有价证券发行和交易的场所



证券市场分为：

1. 次序：(一级市场和二级市场，也就是发行市场和交易市场)
2. 品种：股票、债券、货币市场
3. 形式：场内交易市场和场外交易市场

银行和一些其他都是场外市场







##### 作用



**证券市场的三大作用**



> 一、融资和投资

从资金剩余这流向资金需求者，提供收益和风险相对较高的投资渠道



>二、市场定价

通过证券需求和供给的竞争关系，形成资本的合理定价机制



>三、资源配置

引导资本流向高收益的企业或行业，使资本产生更高的效率。











##### 证券市场参与者



>1.投资者

个人投资者、机构投资者(证券公司、保险公司、基金公司)



>2.中介机构

证券公司、专业服务机构(会计事务所、评级机构)



>3.发行人

政府、企业、金融机构

 

>4.监管机构

证券监管机构、自律性组织















#### 股票基础知识



##### 股票的特征



1. 不可偿还性：所以买卖的时间点很重要
2. 流动性：是去流动性，持有的股票将无法套现，指在不同投资者之间的可交易性。
3. 参与性：股东都有权参加股东大会
   1. 参与难度高。
   2. 网络投票机制
   3. 持股比例决定影响力











##### 股票的种类

我国金融市场特殊



>A股

人民普通股票。由我国境内的公司发行，境内投资者人民买卖(贵州茅台 600519.SH)







>B股

人民币特种股票。由我国境内公司发行，以人民币表明面值，以外币认购和买卖，境内外投资者都可以买

老凤祥B( 900905.SH)以USD交易

古井贡B( 200596.SZ)以HKD交易





>H股

是以港币计价在香港发行并上市的境内企业的股票(农夫山泉 9633.HK)







>更多

S股、N股、L股







##### 股票的代码



>深圳证券交易所





>上海证券交易所











##### 股票的评价

> 绩优股

业绩优良公司的股票 —>每股收益(EPS)&净资产(ROE).





> 垃圾股

连续多久持续下跌，或者濒临退市的股票











##### 发行价格



  **红涨灰跌**



































#### 股票基本面分析



##### 一、由上而在的分析方法：

宏观经济 ——＞ 行业状况 ——> 公司状况

1. 从宏观到微观，能把握大趋势，避免大风险
2. 可能会遗漏某个个股的机会









##### 二、由下而上的分析方法

寻找单个证券没有反映整体行业公司水平而产生的机会

1. 适合个股机会的把握，特别是被低估、转机型的个股
2. 可能无法规避市场风险和行业整体风险。















宏观分析

股市是宏观经济的晴雨表    X            它是片面的



例如：
利率政策——> 企业成本——> 盈利水平 ——> 股价

















#### 常用指标









##### PMI指数

> 采购经理人指数(PMI)

以50为荣枯线，一般PMI指数在50之上，可以认为经济在向好发展和扩张。

一般小于50一下就认为经济在衰退和萧条



















#### 行业分析



行业的兴衰，将关系这个行业大部分企业的兴衰。

通常，每个行业都要经历一个由成长到衰退的发展演变过程中，这个过程称为**行业的生命周期**。









按照行业波动特征来区分



>增长型

与经济活动总水平的周期及其振幅并不密切相关，依靠技术的进步，新产品推出及更优质的服务，使其经常呈现出增长形态(芯片行业)







>周期型

与经济周期紧密相关











>防守型

需求弹性小，行业的产品需求相对稳定。



















##### 总结



需求  >  利润  > 竞争  >  意外















#### 财务报表









###### 资产负债表

表明企业在特定日期所拥有或控制的经济资源，所承担的义务和所有者对净资产的索取权

```java
/**
思路：
    设置一个二维表W用于存储Z型序列，高为numRows,长设置为最大值s的长度
    1.开始时,w[0][0] ~ w[0][numRows - 1];不断添加z字中的第一笔
    2.接下来z字要斜右下。高不断 - 1，行就不断 + 1 形成z字第二笔
    3.此时已经达到w[0][i]了,重复1,2,直到s中的字符都已经遍历一遍为止
    4.此时两个for,从第一行开始，从左到右只要不是默认的“0”字符就添加到StringBuilder中。
    return sb.toString();

 */
class Solution {
    public String convert(String s, int numRows) {
        //z型数组
        char[][] W = [numRows][s.length()];
        boolean is = false;
        int i = 0;
        //Z的第一笔
        //目标方向直线下降
        int sIndex = 0;
        while(sIndex < s.length && !is){
            for(int j = 0;j < numRows && !is;j++){
            //防止s越界
            if(sIndex ==  s.length){
                is = true;
            }
            W[i][j] = s.charAt(j);
            sIndex = j;
        }

        //Z的第二笔,此时已经到了最后一行的0号位
        //目标方向为右上角行++，高--
        for(int j = numRows - 1;j >= 0 && !is; j--){
            //防止s越界
            if(sIndex ==  s.length){
                is = true;
            }

            i++;
            W[i][j] = s.charAt(sIndex++);
        }
        //Z的第三笔实际上就是第一笔，重复
        }


        //最后结算
        Stringbuilder sb = new Stringbuilder();
        for(int i = 0;i < W.length;i++){
            for(int j = 0;j < w[0].length;j++){
                //不是有效值就跳过
                if(w[i][j] == '0') continue;
                sb.append(w[i][j]);
            }
        }

        return sb.toString();
    }
}
```















###### 利润表

表明企业在一定期间内运用所拥有的资产的获利能力。



1. 营业总收入
2. 营业总成本
   1. 营业成本
   2. 销售/管理/财务的费用
3. 其它经营收益
   1. 投资收益
4. 营业利润
   1. 营业外收入/支出
5. 利润总额









###### 现金流入表

反映企业一定期间现金的流入和流出。

1. 经营活动现金流
2. 投资活动现金流
3. 筹资活动现金流











###### 毛利率

**毛利率  =  (营业收入 - 营业成本) / 营业收入 * 100%**

同业对比可分析公司的盈利能力













###### 净资产收益率(ROE)











###### 每股收益(EPS)

每股收益 = 年末净利润 / 年末总股本

一定程度代表了公司的盈利能力。









###### 每股净资产(BPS)

每股净资产 = 年末净资产 / 年末总股本

一定程度代表了公司股价的下限。













###### 市净率(PB)



股票市价  / 每股净资产  =  市净率













###### 市盈率(PE)

股票市价 / 每股收益



















































### 基金





#### 前置理论



> 什么是基金？



- 委托关系
- 专业性
- 集合性
- 合法合规
- 按比例共享收益，共担风险。









#### 分类





##### 按照用途分类





###### 货币型基金

国债、银行存款







###### 债券基金

80 % 以上基金资产投资债券









###### 混合型基金

股票、债券、货币









###### 股票型基金

80%以上基金资产，股票小







> 以上从上往下依次风险增高，流动性不断减少































##### 按场地划分



###### 场内基金



.SH 或 .SZ

买卖时需要股票账号





###### 场外基金



基金后缀为.OF结尾



















##### 基金持仓



基金只在财报中披露当时的持仓，未来有调仓时，不进行披露。 









### 发展年会3.1





#### 今日心得



​		2022年万得发展的年会，其实刚开始有对董事长陆风仅仅是存在了解层面，我感到十分幸运，能够参与了解万得的发展和公司的整体规划和思想，有幸能够听到董事长陆风的讲话，有人说要发扬“螺丝钉”精神理解的非常片面，就是必须要扎根一个地方发扬自己的踏实，勤勤恳恳的工作在自己的岗位，不再想着别的事情。可是我并不这么认为，根据自己的能力，你可能知道你比较适合的岗位和比较喜欢的岗位，但是以公司整体发展的大局，还是要树立以大环境为发展思想，这样才能知道你这颗“螺丝钉”，到底放在哪里才能把你的效益最大化。

​		董事长在公司年会中不断强调要有主动性和责任意识：如果有了主动性和责任意识，再平凡的人都能做出不平凡的事来，只要这样才能够对自己严格要求，不负韶华。曾经那个以“坐飞机”为梦想的陆风，如今已成为亚洲排名第七的中国金融信息服务企业总裁。拥有这么多傲人的成功，离不开公司所有员工齐心协力，和领导层的正确指挥。

​		和勤奋的人在一起不会懒惰，和积极的人在一起不会消沉。要敢作为，勇担当。

​																																											

​																																										    李浩

​																																											2022.03.01

















如果你想要造一艘船，不是要去忙着发号施令，而是要激起他们对大海的无限渴望





和勤奋的人在一起不会懒惰

和积极的人在一起不会消沉

选对方向，做对事情，比努力更重要















对外做到公平对待客户,做童叟无欺的生意.











#### 孤勇之道



当达到一定的程度，甚至处于领先地位(进入了无人区，领先地位)

只有不停的奔跑才能保证在“原位”







> 伟大的公司需要什么?



一个决策接着一个决策,

日复一日,年复一年

日积月累的成果

…



>遇事找自身原因

什么事都找外因,十年都没有变化

什么事都找内因,天天都会有变化









> 激励产生多巴胺,惩罚产生躲避











> 重要的不是你做了什么,而是你做成了什么

尝试了几下,做不出来就放弃了











>要有主动性和责任意识

如果有了主动性和责任意识，再平凡的人都能做出不平凡的事来









> 备岗无能，提升无门

保留团队比保留业务重要，如果要一个人抽调去开展新业务，前提条件就是他自己培养出了备岗。







> 每个人都要有一颗天天向上的心















#### 规范公平之战



提升品牌形象，用价值取胜，而不是其它。







> 凡自万得，皆为精品

一旦进入低价竞争，这个产品就已经快到头了，在沼泽地困的越久，越容易陷入死亡





> 五个极致

- 功能
- 品质
- 体验
- 服务
- 技术













































> 执行像我们的产品一样被0.5折



经营产品转向经营价值。

从野蛮成长转向文明成长。

















> 书籍介绍



《创新者的窘境》

《卡耐基——语言的突破与沟通的艺术》

《管理——任务责任和实践》

《营销管理》

《滚雪球》

















> 人才密度是一个企业创新发展的内核基础

1. 强化领导责任
2. 提升人才密度
3. 建设人才梯队







>业务能否成功的关键

- 一号位
- 一杆旗
- **一条龙**
- 一颗心
- 一张图







>打通业务线，重构组织网

数据、产品、技术、运营、销售、服务一条龙彻底打通，以客户为中心、提供价值、提升品牌













>底线



1. 合规
2. 安全
3. 价值观
   1. 一生勤为本：必须树立以劳动获取相应报酬的观念
   2. 万事诚作基：不钻空子，不染颜色，每个人更不要做违法违纪的事情。(离职也要追溯)





































#### FICC正义之战



- 金融信息服务业的新闻
- F5
- 交易
- F9是四大核心

















> 金融信息服务业

不连接全球，就不能叫金融信息服务业，因为金融本身就是全球化的

不连接交易，也不能叫金融信息服务业，因为金融时时刻刻需要交易























































### Win.d金融终端







#### 使用

> 如何查看全部 A 股中年初至今涨的最好的股票？



1. 在右下角命令行输入命令：60 查看A股详情 ——>选择年初至今——>点击降序排列

![image-20220302101120424](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021011381.png)



![image-20220302101111875](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021011095.png)













>如何在宁德时代的 K 线图上叠加创业板指的行情走势？



1. 右下角命令行输入：NDSD
2. 双击宁德时代
3. 点击叠加
4. 选择任何品种
5. 创业板指数
6. 确定

![image-20220302101721599](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021017060.png)



![image-20220302101755394](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021017013.png)















>请创建一个北京制造业的板块，并设为自定义板块。

1. 快捷键F7进入板块管理
2. 点击新建板块
3. 选出行业
4. 制造业，下方点击







 3、 请创建一个北京制造业的板块，并设为自定义板块。

 4、 找到 Wind 软件与服务行业所有成分股，并查看最新一期财报显示的净资产收益率 ROE 的中位数是多少？ 5、 Wind 行业分类下汽车与汽车零部件行业的所有成分股中，最新一期销售毛利率超过 30% 的公司有多少家？ 6、 “新基建”包括 5G、人工智能、数据中心、工业互联等科技新基建，以及教育等。请 问“工业 4.0”概念股票主要集中在哪几个 Wind 二级行业？ 

7、 在学习全球行情和数据浏览器的过程中，你认为这些功能模块分别有哪些优点和缺点？





![image-20220302102341837](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021023586.png)









![image-20220302102421921](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021024244.png)

















> 如何查看当前股票是否优质



查看系统栏目

- 盈利预测：预测一览
- 投资评级
- 研究报告
- 同业比较









![image-20220302103548415](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021035905.png)



![image-20220302103540411](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021035018.png)

















![image-20220302103811275](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021038708.png)

EPS(一致预测图)比较密集的话，预测比较密集，大部分的选择都是这样的预测结果 = 可参考价值高











十大股东明细

![image-20220302104036291](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021040720.png)











应收款项











![image-20220302131929656](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021319097.png)











































### WFT-经济数据库(EDB)







右下角输入命令EDB即可打开

WFT经济数据库

数据来源都比较靠谱，甚至很多都来自原于政府机关单位的数据





![image-20220302134514832](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021345995.png)





![image-20220302135045341](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021350497.png)









##### 指标检索

![image-20220302135123108](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021351251.png)





>指标多选，按住Ctrl键，多选指标对比



















##### 数据来源

![image-20220302135306072](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021353235.png)







##### 指标联想



![image-20220302135453561](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021354712.png)











##### 提取数据



![image-20220302140114834](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021401936.png)



![image-20220302140230151](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021402344.png)





##### 个性化

![image-20220302140438884](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021404015.png)

















![image-20220302140533168](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021405324.png)

























##### 变频





![image-20220302142709799](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021427986.png)

















![image-20220302142905315](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021429463.png)











##### 数据导出

![image-20220302142933108](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021429235.png)









##### 做好的模板保存

![image-20220302142955436](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021429592.png)























#### 总结：

![image-20220302143038429](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021430562.png)











##### 产品特色

![image-20220302143104685](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203021431832.png)

























#### 练习



















同比，跟去年的这个月进行对比























































### AMS资产管理系统3.3















#### AMS



![image-20220303102142687](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203031021166.png)











### AMS优势



![image-20220303102557135](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203031025434.png)









万得之星培训
---

1. 快速融入团队
2. 要正、要爱、要严、要美 

>注重提高演讲能力

走向管理层必备



>终端

1. 基金重仓——可以看到专业的基金经理重仓的股票



>推荐书籍

1. 《影响力》——INFLUENCE
2. 《投资学》——原书第9版





### 创新性思维训练—蔡常昆



——创新就是让“不可能变成可能”



- 不是“”不可能“”
- 只是暂时没有找到方法
- 只要找到方法就会成为可能

```java

```





1. 有能力，但没有













































# cloud培训

![image-20220509205350808](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092053991.png)







![image-20220509192830050](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091928246.png)

共五天

![image-20220509183850251](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091848904.png)









## Cloud报表介绍





## Cloud是个数据服务

![image-20220509190156709](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091901989.png)





![image-20220509190511250](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091905473.png)





![image-20220509190551664](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091905051.png)







> 分布式系统

![image-20220509190715778](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091907031.png)





![image-20220509190749019](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091907310.png)







![image-20220509190947535](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091909800.png)





注意：超过一定数量的并发就会限流、排队、再到中断等



![image-20220509191344110](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091913415.png)



![image-20220509191902634](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091919907.png)



![image-20220509192031420](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091920733.png)





![image-20220509192321734](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091923996.png)







![image-20220509192452335](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091924628.png)





>高并发，聚合等业务场景，调用需要比较开，使用此接口

![image-20220509192652442](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091926726.png)





![image-20220509192843004](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091928286.png)



![image-20220509193424468](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091934754.png)



![image-20220509193507300](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091935561.png)



![image-20220509193624299](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091936621.png)





![image-20220509193956979](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091939248.png)









![image-20220509194021760](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091940022.png)



![image-20220509194415228](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091944544.png)



![image-20220509194540680](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091945995.png)



![image-20220509194958368](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091949733.png)





![image-20220509195049970](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091950315.png)











![image-20220509195502960](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091955230.png)





![image-20220509195514563](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091955844.png)





![image-20220509195551890](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091955219.png)





![image-20220509195744400](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091957780.png)



![image-20220509195846016](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205091958312.png)





![image-20220509200044240](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092000564.png)

![image-20220509200106762](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092001091.png)



![image-20220509200135739](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092001164.png)

![image-20220509200240422](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092002768.png)



![image-20220509200346931](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092003259.png)



![image-20220509200438433](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092004755.png)





![image-20220509200606993](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092006328.png)





![image-20220509200809288](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092008649.png)









- **报表记录类**

- **业务逻辑类**

4.5.2



![image-20220509201813241](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092018481.png)





![image-20220509202456323](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092024604.png)







//看到cloud有哪些缓存，加载了多少数据

```bash
cache
```

![image-20220509202848294](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092028792.png)



![image-20220509203101180](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092031612.png)





>动态加载

![image-20220509203210372](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092032684.png)























![image-20220509203406942](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092034211.png)

![image-20220509203613167](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092036409.png)



![image-20220509203709657](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092037899.png)



![image-20220509203808135](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092038362.png)

![image-20220509203819991](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092038260.png)

![image-20220509203848765](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092038105.png)



![image-20220509203953283](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092039552.png)



![image-20220509204047414](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092040708.png)

![image-20220509204125587](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092041819.png)

![image-20220509204211968](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092042219.png)



![image-20220509204344673](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205092043944.png)











Cloud代码规范
---

![image-20220510190232146](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101902584.png)











Cloud动态编译
---



### 操作要点

![image-20220511190927156](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205111909396.png)



![image-20220511192149220](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205111921449.png)



![image-20220511192953011](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205111929269.png)



![image-20220511193436620](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205111934826.png)

![image-20220511193505375](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205111935674.png)





>cloud编译发布工具

![image-20220512194358473](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121943875.png)



cloud环境搭建
---

![image-20220512195449476](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121954684.png)



下载软件

![image-20220512195512120](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121955342.png)





![image-20220512195544979](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121955323.png)











![image-20220512195716329](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205121957786.png)



![image-20220512200308228](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205122003442.png)



![image-20220512200436613](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205122004853.png)



![image-20220512200946249](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205122009644.png)





![image-20220512201034822](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205122010045.png)



>errorCode可以加在任何可能会出错的地方

![image-20220512201242859](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205122012077.png)

errorCode更多的是放在业务上来使用





![image-20220512201845719](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205122018929.png)





![image-20220512201911489](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205122019671.png)





思路：

1. 先找到下载文档地址
2. 然后对应下载工具
3. 加载项目
4. 编写报表



![image-20220513191404372](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131914742.png)



![image-20220513191505277](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131915818.png)



![image-20220513192107354](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205131921643.png)


























Cloud总结
===



## Cloud概念总结

可以从Win.d的知识管理系统中获取相关信息

#### 是个数据服务



Cloud是Win.d**数据统一查询平台**。



- **==统一==的数据运算平台**(实现数据的函数运算统一和报表运算的统一)。

- ==**高效、可复用**==的数据运算平台
  - 包括WFT、EXCEL、量化、万旷、企业库、孔雀开会



#### 服务接入Expo

**Expo总线单独为Cloud提供==专线==**





#### 数据分片加载

**sharding模型，==并行==计算，复杂任务拆分多个子任务==分别计算后再合并结果==**

注：但是超过一定数量的并发就会限流、排队、再到中断等







#### Cloud基于Key/Value结构的内存平台

存储都是三个自行开发的集合来完成

- CloudDictionary<Tkey,TValue>
- CloudSortedList<Tkey,TValue>
- CloudUshortSortedList<Tkey,TValue>
- CloudList<T>

**以上都是==线程安全==的，能极大==提高内存的读写效率==。内存数据的读取都是==实时更新==的**





#### Cloud系统数据同步

**支持==数据自动更新(RMQ)==**

1. `Wind.DP`**扫描**数据库的更新数据
2. `Wind.DP`**获取**数据库的更新数据
3. 然后发送获取到的更新数据导RabbitMQ的消息总线对应更新数据







#### 权限控制

![image-20220510102727473](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101027572.png)



#### 动态编译

Cloud支持动态编译、易于维护、易于产品发布。

- Cloud使用动态逻辑注入的思想。使用.Net的动态编译技术。
  - 能==实时修改系统内部的逻辑==，==增加新的业务逻辑==。
  - ==动态灌入==新的数据
  - 使新加入的表==自动进行数据同步==
  - ==无需更换可执行程序==，DLL等
  - ==无需重启程序==，向服务==发送一些指令即可==完成







#### 环境

##### Cloud运行环境

1. Windows Server 2003/2008(X64) 256G内存
2. NET Framework 4.5.2
3. Microsoft SQL Server 2008

##### Cloud开发环境

1. 开发工具：VS2013及以上版本
2. 开发语言：C#







#### 请求协议



##### 调用接口

![image-20220510104056566](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101040658.png)





#### 多命令格式支持

![image-20220510104204476](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101042571.png)



#### 服务端协议



##### 支持的数据协议

> Cloud服务端协议，支持5种数据协议：

![image-20220510104304012](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101043079.png)





##### 协议明细

![image-20220510104403622](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101044716.png)









#### 数据类型



##### 定义

![image-20220510104630317](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101046444.png)



#### 多语言

==支持数据国际化==可以==根据不同的语言参数来实现数据的国际化==

```
//目前支持中英两种语言切换
Lan=en\cn
```

![image-20220510104904541](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101049597.png)



#### 白名单

应用场景：公司内部系统在使用过程中，需要进行二次加工计算等，后自身对数据作权限控制。申请白名单两种方式



##### 应用白名单

注：是针对某个应用申请白名单，应用的ID是Expo的Appclass。

- 当申请了之后Cloud不对来自==该应用的所有命令==做权限控制



##### 应用==命令==白名单

针对应用中部分业务的命令申请白名单，申请后，Cloud将不对来自该==应用的命令==做权限控制

![image-20220510105332422](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101053487.png)





#### 接入



![image-20220510105531070](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101055169.png)









##### Expo案例

![image-20220510105601661](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101056778.png)



##### 反序列化案例

![image-20220510105706846](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101057952.png)





###### 消息体反序列化

![image-20220510105753465](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101057549.png)





##### 错误码

![image-20220510110013996](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101100110.png)







#### 生态



##### 代码管理

Cloud对接的业务比较多，为了便于管理，按照业务分成各自的模块，业务代码在各自的模块中维护

1. 报表开发人员==只需要关注业务代码==
2. 公共函数、API统一提供、算法和复用==统一==
3. 业务模块采用插拔式挂载，可==动态加载==



##### 发布流程

![image-20220510110713655](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101107762.png)



##### 业务开发和工具介绍

![image-20220510110759248](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101107339.png)





开发
---



### 报表开发



#### 报表概述



##### 框架简介

![image-20220510111158355](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101111435.png)

##### 报表代码结构

![image-20220510111234541](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101112661.png)



##### 报表记录类(成员变量)

![image-20220510111536049](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101115144.png)

![image-20220510111602151](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101116229.png)

![image-20220510111626093](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101116179.png)

![image-20220510111749524](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101117631.png)

![image-20220510111810415](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101118525.png)



###### 业务逻辑处理类

![image-20220510112030931](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101120026.png)





![image-20220510111857315](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101118418.png)

![image-20220509200438433](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101119414.png)

![image-20220510111956780](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101119879.png)

![image-20220510112057905](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101120060.png)





### MR报表



#### 概念

MR报表由主表和子表两部分组成

##### 主表

写在`WUDS.HQMR`项目下面。

1. 负责拆分和合并，将任务拆分为JOB1、JOB2、JOB3…
2. 通过JOB发送普通报表请求，通过子表实现具体的JOB任务。
3. 在JOB都执行完成后，主表进行合并
4. 合并为一个结果集返回



##### 子表

写在`WUDS.Service.Stock`项目下。

实现具体的JOB任务



##### 两个类



###### MRJOB类

继承`MRReportJob`类，负责生成子表命令请求。

一个报表可以有多个`MRJOB`



###### MRReport类

负责报表拆分和合并

所有报表JOB都是由`MRReport Job`派生。需重载`CreateJobCommand`方法

根据MRJob之间是否有依赖关系将MRReport类分为串行和混合(并行)分别继承不同的基类如下：

1. BaseMRReport(串行)
2. BaseParallelMRReport(并行)



注意：无论串行或者并行都需要重载4个方法，并且并行多一个方法用于确定各个JOB运行关系。

>4个方法

1. GetBusinessKey()：返回前端调用的报表命令名称
2. CloumnNames()：返回列名
3. CreateMRJob()：创建JOB



>并行额外多一个方法

1. BuildParallelIndex()：确定各个JOB执行关系





























#### MR报表拆分



##### 为什么要拆？

随着cloud的数据量越来越大，很多==大数据量的表==如：

- 沪深行情
- 港股行情
- 美股行情

在内存中的cache也越来越大，同一个服务器加载多个行情cache，那么占用的资源巨大，消耗大量内存。

将不同的大数据量的表加载到不同的实例里，==同一张报表如果需要多个行情，可拆分为多个子表，调用多个实例的数据，最终合并为一张表==。





##### 怎么拆？

MR适用于行情拆分、对于大数据量、耗时长、优化空间校的报表可以根据具体情况分析：

​	将一个耗时量大的报表==拆分为几个快速子报表，最后合并==，大大提升报表效率

==基于报表拆分子表，同一个工作分配到不同的实例上==，使得各个服务器==实例的使用率提高==，可==提高Cloud系统的负载均衡==。





#### 框架搭建

1. 将两个解决方案添加同一个工程下
2. 将各自的模块里面的引用重新引用一下(类库在各自模块的Lib文件夹下)
3. 生成解决方案。成功利用MapStudio工具调试
   1. 工具路径![image-20220510114108853](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101141938.png)















## 问题

>这个扫描和获取更新数据的DP是什么？

![image-20220510102118427](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202205101021585.png)







>什么是sharding模型?



>几大集合的具体应用场景

- CloudDictionary<Tkey,TValue>
- CloudSortedList<Tkey,TValue>
- CloudUshortSortedList<Tkey,TValue>
- CloudList<T>





>怎么做到线程安全的，还能极大提高内存的读写效率？









>MRReport中的4个方法最后一个是什么？（找到相关PPT即可）

1. GetBusinessKey()：返回前端调用的报表命令名称
2. CloumnNames()：返回列名
3. CreateMRJob()：创建JOB



在今天的培训课程中仍让我感到受益匪浅，从上午课程中了解到万得整体的研发之路，是如履薄冰，摸着石头过河。一个公司的实际工作需求，原来和我们之前所学的各种开源框架的迭代，还是有很多方面的不同。万得的今天不单单只是技术层次的不断突破，扩展了自己在实际工作上面的思路，在技术层面提升了我的认知，在此由衷的感谢孙老师。

​	下午的《代码之美》课程中，老师从操作系统，代码规范和代码测试等多个方面去阐述了什么是代码的美。给我的感受就是老师的知识的宽度和深度令我由衷的感到敬畏，不单是对老师，也是技术的敬畏！课后请教了老师关于多线程并发时有没有可能在操作系统层面上去实际控制线程的执行速度的问题？很感谢老师非常专业、耐心的解答。又是收获满满的一天！

​	每天进步一点点，加油！

























```java
import java.util.*;

/**
 * @Project_Name calculator_day01
 * @Author LH
 * @Date 2022/8/22 13:23
 * @TODO：Java编码规范练习题B
 * @Thinking: 建立一个Java项目，使用Maven作为项目构建管理工具，实现下面功能
 * 问题描述：输入：(5+6/2+2*3-1)*2+8
 * 输出：输出对应表达式的结果
 * <p>
 * 思路：
 * 一、理出优先级：
 * 1.有括号先算括号内的
 * 2.先乘除,再加减
 * 二、sl4j日志框架记录日志并提示
 * 三、引入junit简单测试
 * 四、导入打包工具导出为jar
 */
//@sl4j
public class Calculators {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Please enter an expression:");
        String s = scanner.next();
        int calculate = calculate(s);
        System.out.println("result = " + calculate);
    }

    /**
     * 利用栈来实现
     * @param s
     * @return
     */
    public static int calculate(String s) {
        List<String> tokens = getRPN(s);
        return evalRPN(tokens);
    }

    /**
     * 字符串计算表达式
     * @param s 字符串计算表达式
     * @return
     */
    public static List<String> getRPN(String s) {
        List<String> rpn = new ArrayList<String>();
        Deque<Character> stack = new ArrayDeque<Character>();
        int length = s.length();
        int num = 0;
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            if (Character.isDigit(c)) {
                num = num * 10 + c - '0';
            } else {
                if (i > 0 && Character.isDigit(s.charAt(i - 1))) {
                    rpn.add(String.valueOf(num));
                    num = 0;
                }
                if (c == '(') {
                    stack.push(c);
                } else if (c == ')') {
                    while (stack.peek() != '(') {
                        rpn.add(String.valueOf(stack.pop()));
                    }
                    stack.pop();
                } else {
                    int precedence = getPrecedence(c);
                    while (!stack.isEmpty() && getPrecedence(stack.peek()) >= precedence) {
                        rpn.add(String.valueOf(stack.pop()));
                    }
                    stack.push(c);
                }
            }
        }
        if (Character.isDigit(s.charAt(length - 1))) {
            rpn.add(String.valueOf(num));
        }
        while (!stack.isEmpty()) {
            rpn.add(String.valueOf(stack.pop()));
        }
        return rpn;
    }

    public static int evalRPN(List<String> tokens) {
        Deque<Integer> stack = new ArrayDeque<Integer>();
        int size = tokens.size();
        for (int i = 0; i < size; i++) {
            String token = tokens.get(i);
            if (isNumber(token)) {
                stack.push(Integer.parseInt(token));
            } else {
                int num2 = stack.pop();
                int num1 = stack.pop();
                switch (token) {
                    case "+":
                        stack.push(num1 + num2);
                        break;
                    case "-":
                        stack.push(num1 - num2);
                        break;
                    case "*":
                        stack.push(num1 * num2);
                        break;
                    case "/":
                        stack.push(num1 / num2);
                        break;
                    default:
                }
            }
        }
        return stack.pop();
    }

    /**
     * 评选计算优先级
     * @param operator 运算符号
     * @return 优先级的权重
     */
    public static int getPrecedence(char operator) {
        if (operator == '*' || operator == '/') {
            return 2;
        } else if (operator == '+' || operator == '-') {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * 识别是否为数字参数
     * @param token 需要校验参数
     * @return 是或者不是
     */
    public static boolean isNumber(String token) {
        return Character.isDigit(token.charAt(token.length() - 1));
    }
}
```



```java
import java.util.Scanner;

/**
 * @Project_Name calculator_day01
 * @Author LH
 * @Date 2022/8/22 13:23
 * @TODO：Java编码规范练习题B(此思路误入歧途！)
 * @Thinking:
    建立一个Java项目，使用Maven作为项目构建管理工具，实现下面功能
    问题描述：输入：(5+6/2+2*3-1)*2+8
    输出：输出对应表达式的结果

 思路：
    一、理出优先级：
        1.有括号先算括号内的
        2.先乘除,再加减
    二、sl4j日志框架记录日志并提示
    三、引入junit简单测试
    四、导入打包工具导出为jar
 */
public class CalculatorTest {
    /**
     * 输入表达式设定为全局变量
     */
    static String calculatorStr = "";

    public static void main(String[] args) {
        //识别扫描括号
        //(5+6/2+2*3-1)*2+8
        Scanner sc = new Scanner(System.in);
        //传入的表达式
        calculatorStr = sc.next();
        int s1 = 0,s2 = 0;
        //有括号
        for (int i = 0; i < calculatorStr.length(); i++) {
            //先算括号内的
            if (calculatorStr.charAt(i) == '('){
                s1 = i;
                //给括号内的整体计算结果
                for (int j = i; j < calculatorStr.length(); j++) {
                    if (calculatorStr.charAt(j) == ')'){
                       s2 = j;
                       break;
                    }
                }
            }
        }
        String s = calculatorStr.substring(s1,s2 + 1);
        //传入时候删除左右两边括号
        order(s.substring(1, s.length() - 1));
        System.out.println(calculatorStr);
        //传入四则运算方法中计算值
//        int result1 =
        //将括号内的整体计算出结果并替换
//        calculatorStr.replace(s,)

    }

    /**
     * 运算顺序组合
     * @param str 无括号四则表达式
     */
    public static void order(String str){
        String param1 = "",param2 = "";
        //先乘除
        for (int i = 0; i < str.length(); i++) {
            int param1Order = 0,param2Order = 0;
            if (str.charAt(i) == '*' || str.charAt(i) == '/'){
                //参数1
                for (param1Order = i;param1Order > 0 ;param1Order--){
                    if (str.charAt(param1Order) == '*' || str.charAt(param1Order) == '/' || str.charAt(param1Order) == '+' || str.charAt(param1Order) == '-'){
                        param1 = str.substring(param1Order + 1,i);
                    }
                }
                //参数2
                for (param2Order = i; param2Order < str.length(); param2Order++){
                    if (str.charAt(param2Order) == '*' || str.charAt(param2Order) == '/' || str.charAt(param2Order) == '+' || str.charAt(param2Order) == '-'){
                        param2 = str.substring(i + 1,param2Order);
                    }
                }

                //计算并替换
                double calculateNum = calculate(Integer.parseInt(param1), Integer.parseInt(param2), str.charAt(i));
                String CalculateStr = String.valueOf(calculateNum);
                //将当前计算结果替换当前表达式
                str.replace(str.substring(param1Order + 1,param2Order),CalculateStr);
                //重置i,以重新扫描乘除,直到没有乘除为止
                i = 0;
            }
        }

        //后加减
        for (int i = 0; i < str.length(); i++) {
            int param1Order = 0,param2Order = 0;
            if (str.charAt(i) == '+' || str.charAt(i) == '-'){
                //参数1
                for (param1Order = i;param1Order > 0 ;param1Order--){
                    if (str.charAt(param1Order) == '*' || str.charAt(param1Order) == '/' || str.charAt(param1Order) == '+' || str.charAt(param1Order) == '-'){
                        param1 = str.substring(param1Order + 1,i);
                    }
                }
                //参数2
                for (param2Order = i; param2Order < str.length(); param2Order++){
                    if (str.charAt(param2Order) == '*' || str.charAt(param2Order) == '/' || str.charAt(param2Order) == '+' || str.charAt(param2Order) == '-'){
                        param2 = str.substring(i + 1,param2Order);
                    }
                }

                //计算并替换
                double calculateNum = calculate(Integer.parseInt(param1), Integer.parseInt(param2), str.charAt(i));
                String CalculateStr = String.valueOf(calculateNum);
                //将当前计算结果替换当前表达式
                str.replace(str.substring(param1Order + 1,param2Order),CalculateStr);
                //重置i,以重新扫描乘除,直到没有乘除为止
                i = 0;
            }
        }
    }

    /**
     * 计算加减乘除
     * @param param1 计算参数1
     * @param param2 计算参数2
     * @param symbol 计算符号
     */
    public static double calculate(double param1, double param2, char symbol){
        double result = 0;
        switch (symbol){
            case '*':
                result = param1 * param2;
                break;
            case '/':
                result = param1 / param2;
                break;
            case '+':
                result = param1 + param2;
                break;
            case '-':
                result = param1 - param2;
                break;
            default:
                //需要打印日志扫描异常
                break;
        }
        return result;
    }
}

```





```java
		<!--junit单元测试-->
		<dependency>
			<groupId>junit</groupId>
			<artifactId>junit</artifactId>
			<scope>test</scope>
		</dependency>
        <!--sl4j日志门面-->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>1.7.25</version>
		</dependency>
```











软件仓库
===



步骤
---

### 新应用申请

![image-20220823131624227](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231316485.png)



>主模块类型一般选前两种，打的jar包，第三种则为war包

![image-20220823131637930](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231316104.png)



![image-20220823131656852](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231316017.png)



![image-20220823131750683](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231317850.png)





![image-20220823131821558](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231318721.png)











### 集成产品申请

![image-20220823135227398](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231352581.png)





![image-20220823135318505](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231353768.png)





![image-20220823135357478](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231353696.png)







### 部署应用申请

![image-20220823142238131](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231422326.png)





![image-20220823142336316](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231423493.png)





![image-20220823142344538](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231423761.png)









### 应用实例申请

![image-20220823143435032](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231434210.png)





![image-20220823144315464](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202208231443654.png)











day2作业
---

```java
给定一个文本文件，写一个程序，计算文件中英文字母出现的次数(不区分大小写)，并最终输出出现次数最多的10个字母，按出现次数从大到小排列，每个一行，每行格式：字母+空格+出现次数，输出到一个文件中。
```





```java
import cn.com.wind.service.NumberOfLetterService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * @Project_Name Wind.2022Java.hli.lihao
 * @Author LH
 * @Date 2022/8/23 15:40
 * @TODO：软件仓库练习题
 * 题目：
 * 给定一个文本文件，写一个程序，计算文件中英文字母出现的次数(不区分大小写)
 * 并最终输出出现次数最多的10个字母，
 * 按出现次数从大到小排列，每个一行，每行格式：字母+空格+出现次数，输出到一个文件中。
 * @Thinking:
 * 1.定义1个26 + 26(大小写)位全字符数组(作为当前位置子母的映射)
 * 2.识别到当前字符则在对应后面加入
 */
@Controller
@RequestMapping("/")
public class NumberOfLetterController {
    @Autowired
    private NumberOfLetterService numberOfLetterService;
    @PostMapping("/letter")
    public void getNumberOfLetter(String str){
        numberOfLetterService.getNumberOfLetter(str);
    }
}
```



```java
/**
 * @Project_Name Wind.2022Java.hli.lihao
 * @Author LH
 * @Date 2022/8/23 15:59
 * @TODO：描述
 * @Thinking:
 */
public interface NumberOfLetterService {
    /**
     * 计算文件中英文字母出现的次数
     * @param str 文件提取的字符串
     */
    void getNumberOfLetter(String str);
}
```

```java
import cn.com.wind.service.NumberOfLetterService;
import org.springframework.stereotype.Service;

/**
 * @Project_Name Wind.2022Java.hli.lihao
 * @Author LH
 * @Date 2022/8/23 15:59
 * @TODO：描述
 * @Thinking:
 */
@Service
public class NumberOfLetterServiceImpl implements NumberOfLetterService {
    /**
     * 计算文件中英文字母出现的次数
     *
     * @param str 文件提取的字符串
     * 1.定义1个26 + 26(大小写)位全字符数组(作为当前位置子母的映射)
     * 2.识别到当前字符则在对应后面加入
     * 3.将当前字符
     */
    //全局数组
    static int[] capitalLetter;
    static int[] smallLetter;
    static StringBuilder sb;

    @Override
    public void getNumberOfLetter(String str) {
        capitalLetter = new int[26];
        smallLetter = new int[26];
        sb = new StringBuilder();
        //遍历扫描并对应计数
        for (int i = 0; i < str.length(); i++) {
            //当前字符为大写,对应位置++
            if (str.charAt(i) - 'A' < capitalLetter.length && str.charAt(i) - 'A' >= 0) {
                capitalLetter[str.charAt(i) - 'A']++;
            }
            //当前为小写
            else if (str.charAt(i) - 'a' < smallLetter.length && str.charAt(i) - 'a' >= 0) {
                smallLetter[str.charAt(i) - 'A']++;
            }
            //除大小写以外任意字符跳过
            else {
                continue;
            }
        }

        //找出10个出现频率最高的子母
        for (int i = 0; i < 10; i++) {
            maxNum();
        }
        System.out.println(sb.toString());
    }

    public void maxNum() {
        //在两个数组中找10个频率最高的
        int maxNum = -1, maxLocal = -1;
        for (int i = 0; i < capitalLetter.length + smallLetter.length - 1; i++) {
            if (i >= 26 && maxNum < capitalLetter[i]) {
                maxLocal = i + 'A';
                maxNum = capitalLetter[i];
                capitalLetter[i] = 0;
            } else if (i >= 26 && maxNum < smallLetter[i]) {
                maxLocal = i + 'a';
                maxNum = capitalLetter[i];
                capitalLetter[i] = 0;
            }
        }
        char c = (char) maxLocal;
        sb.append(c);
        sb.append(maxNum);
    }
}
```













实际可以直接测试代码

```java
public class NumberOfLetter {
    /**
     * 计算文件中英文字母出现的次数
     *
     * @param str 文件提取的字符串
     * 1.定义1个26 + 26(大小写)位全字符数组(作为当前位置子母的映射)
     * 2.识别到当前字符则在对应后面加入
     * 3.将当前字符
     */
    //全局数组
    static int[] capitalLetter;
    static int[] smallLetter;
    static StringBuilder sb;

    public static void getNumberOfLetter(String str) {
        capitalLetter = new int[26];
        smallLetter = new int[26];
        sb = new StringBuilder();
        //遍历扫描并对应计数
        for (int i = 0; i < str.length(); i++) {
            //当前字符为大写,对应位置++
            if (str.charAt(i) - 'A' < capitalLetter.length && str.charAt(i) - 'A' >= 0) {
                capitalLetter[str.charAt(i) - 'A'] += 1;
            }
            //当前为小写
            else if (str.charAt(i) - 'a' < smallLetter.length && str.charAt(i) - 'a' >= 0) {
                smallLetter[str.charAt(i) - 'a'] += 1;
            }
            //除大小写以外任意字符跳过
            else {
                continue;
            }
        }

        //找出10个出现频率最高的子母
        for (int i = 0; i < 10; i++) {
            maxNum();
        }
        System.out.println(sb.toString());
    }

    public static void maxNum() {
        //在两个数组中找10个频率最高的
        int maxNum = -1, maxLocal = -1;
        for (int i = 0; i < capitalLetter.length + smallLetter.length - 1; i++) {
            //从0开始
            if (i >= 26 && maxNum < capitalLetter[i - 26]) {
                maxLocal = i - 26 + 'A';
                maxNum = capitalLetter[i - 26];
                //当前位置次数置为0
                capitalLetter[i - 26] = 0;
            } else if (i < 26 && maxNum < smallLetter[i]) {
                maxLocal = i + 'a';
                maxNum = smallLetter[i];
                smallLetter[i] = 0;
            }
        }
        char c = (char) maxLocal;
        sb.append(c);
        sb.append(maxNum);
        sb.append("/n");
    }


    public static void main(String[] args) {
        String s = "aaabbbcccdddeeefffggghhhiiijjjkkklllnnnmmmuuuvvvwwwAAAA";
        getNumberOfLetter(s);
    }
}
```



>加入输入输出流

```java
package cn.com.wind;

/**
 * @Project_Name Wind.2022Java.hli.lihao
 * @Author LH
 * @Date 2022/8/23 17:47
 * @TODO：描述
 * @Thinking:
 */
import javax.sound.midi.SysexMessage;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Scanner;

public class NumberOfLetter {
    /**
     * 计算文件中英文字母出现的次数
     *
     * @param str 文件提取的字符串
     * 1.定义1个26 + 26(大小写)位全字符数组(作为当前位置子母的映射)
     * 2.识别到当前字符则在对应后面加入
     * 3.将当前字符
     */
    //全局数组
    static int[] capitalLetter;
    static int[] smallLetter;
    static StringBuilder sb;

    public static void output(){
        String path = path1 +"/out.txt";
        File file = new File(path);
        //如果文件不存在，则自动生成文件；
        if(!file.exists()){
            try {
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        //引入输出流
        OutputStream outPutStream;
        try{
            outPutStream = new FileOutputStream(file);
            outPutStream.write((sb.toString()+"\r\n").getBytes());//开始写入内容到文件；
            outPutStream.close();//一定要关闭输出流；
        }catch(Exception e){
            e.printStackTrace();//获取异常
        }
    }
    public static String readFileAsString(String fileName)throws Exception{
        String data = "";
        data = new String(Files.readAllBytes(Paths.get(fileName)));
        return data;
    }



    public static void getNumberOfLetter(String str) {
        capitalLetter = new int[26];
        smallLetter = new int[26];
        sb = new StringBuilder();
        //遍历扫描并对应计数
        for (int i = 0; i < str.length(); i++) {
            //当前字符为大写,对应位置++
            if (str.charAt(i) - 'A' < capitalLetter.length && str.charAt(i) - 'A' >= 0) {
                capitalLetter[str.charAt(i) - 'A'] += 1;
            }
            //当前为小写
            else if (str.charAt(i) - 'a' < smallLetter.length && str.charAt(i) - 'a' >= 0) {
                smallLetter[str.charAt(i) - 'a'] += 1;
            }
            //除大小写以外任意字符跳过
            else {
                continue;
            }
        }

        //找出10个出现频率最高的子母
        for (int i = 0; i < 10; i++) {
            maxNum();
        }

        System.out.println(sb.toString());
        //最后调用输出
        output();
    }

    public static void maxNum() {
        //在两个数组中找10个频率最高的
        int maxNum = -1, maxLocal = -1;
        for (int i = 0; i < capitalLetter.length + smallLetter.length - 1; i++) {
            //从0开始
            if (i >= 26 && maxNum < capitalLetter[i - 26]) {
                maxLocal = i - 26 + 'A';
                maxNum = capitalLetter[i - 26];
                //当前位置次数置为0
                capitalLetter[i - 26] = 0;
            } else if (i < 26 && maxNum < smallLetter[i]) {
                maxLocal = i + 'a';
                maxNum = smallLetter[i];
                smallLetter[i] = 0;
            }
        }
        char c = (char) maxLocal;
        sb.append(c);
        sb.append(maxNum);
        sb.append("\n");
    }

static String path1;
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入path:");
        path1 = System.getProperties().getProperty("user.dir");
        System.out.println(path1);
        //输入windows默认一般为src/main/resources
        String path = sc.nextLine();
        String s = "aaabbbcccdddeeefffggghhhiiijjjkkklllnnnmmmuuuvvvwwwAAAA";
        String data = null;
        try {
            data = readFileAsString(path);
        } catch (Exception e) {
            e.printStackTrace();
        }
        //打印输入的字符串
        System.out.println("paramStr = " + data);
        getNumberOfLetter(data);
    }
}
```





```java
https://start.aliyun.com
```











研发22条军规培训心得

​	今天的22条军规着实让我感触良多，受益匪浅，特别是在刚走向工作，这就相当于定规矩，这些军规就是前人不断爬坑摸索出来的结果。

​	**编码的目标是为了方便用户而不是方便自己**：在实习的时候，阅读部门的项目代码时，让我对今天的第13条军规。有着不一样的认识：在接触部门项目的代码时，我时常感到疑惑，例如一个很小的细节：我记得当时调用接口测试的时候，明明测试就已经出现的错误，为何不直接在接口中的返回值中返回确切一些的错误类型：是接口中的参数解析出错、接口中的逻辑处理的环节出错、或者返回的接口中请求其它接口获取数据出错……而都是统一返回一个“系统繁忙！”。这样还需要申请堡垒机去查看对应的项目运行日志，我直接调用返回出来，我就不需要走这样的流程，就可以直接在前端看到我大致出错的地方，这样不是更方便，我不解的问导师。我导师当时并没有说什么，但是他回了我一句:“假设你是用户，你在界面上进行操作,如果请求出错了，返回一个参数解析出错，你想用户帮你处理吗？这还是你是一个做技术开发的人，那么不懂的人呢？你要人家怎么做？”今天孙老师讲到军规的“编码的目标是为了方便用户而不是方便自己”，突然让我回想起来。确实是，你做的产品本身就是给用户用的，如果不站在用户的角度去考虑问题，一直只想着你自己怎么方便，无疑是非常自私的一种思想。

​	**让程序运行快一点、再快一点，直到极限**：作为一个开发人员，自身应该就要对自己有着严格的要求。这也对应到**让程序使用尽可能少的资源**，在现今，经过所依附的硬件资源已经达到比较高的水准。但我总相信，真正优秀的程序员，并不是在丰富硬件等资源前提下去开发项目，而是在有限的资源，甚至自己给自己额外减少资源的前提来完成开发工作。“不想当将军的士兵不是好士兵”，只有这样技术水平层次才能不断的得到提高，才能走的更远。













