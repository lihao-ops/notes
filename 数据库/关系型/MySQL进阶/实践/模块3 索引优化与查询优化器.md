# 索引优化与查询优化器深度实验

## 实验10: 覆盖索引 vs 回表性能对比

### 实验目标

量化覆盖索引的性能提升

### 场景A: 非覆盖索引（需要回表）

```sql
-- 清空查询缓存
RESET QUERY CACHE;

-- 查看执行计划
EXPLAIN SELECT id, user_id, balance, status 
FROM account_transaction 
WHERE user_id = 1001;

/*
分析输出:
- type: ref
- key: idx_user_id
- Extra: 无"Using index"
说明：需要回表获取balance和status
*/

-- FORMAT=JSON查看详细信息
EXPLAIN FORMAT=JSON 
SELECT id, user_id, balance, status 
FROM account_transaction 
WHERE user_id = 1001\G

/*
关注字段:
- used_key_parts: ["user_id"]
- access_type: "ref"
- rows_examined_per_scan: 估算扫描行数
- cost_info.read_cost: 读取成本
*/

-- 开启profiling测量实际耗时
SET profiling = 1;

SELECT id, user_id, balance, status 
FROM account_transaction 
WHERE user_id = 1001;

SHOW PROFILES;
SHOW PROFILE FOR QUERY 1;

/*
关注阶段:
- Sending data: 包含了回表的I/O时间
*/
```

### 场景B: 覆盖索引（无回表）

```sql
-- 创建覆盖索引
ALTER TABLE account_transaction 
ADD INDEX idx_user_cover(user_id, balance, status);

-- 同样的查询
EXPLAIN SELECT id, user_id, balance, status 
FROM account_transaction 
WHERE user_id = 1001;

/*
变化:
- key: idx_user_cover
- Extra: Using index (覆盖索引标志)
*/

-- 性能对比
SET profiling = 1;

SELECT id, user_id, balance, status 
FROM account_transaction 
WHERE user_id = 1001;

SHOW PROFILES;

/*
预期提升:
- 查询时间减少 30%-70%
- 无需回表，减少随机I/O
*/
```

### 场景C: SELECT * 破坏覆盖索引

```sql
EXPLAIN SELECT * 
FROM account_transaction 
WHERE user_id = 1001;

/*
即使有idx_user_cover:
- Extra: 无"Using index"
- 原因：*包含remark等大字段，必须回表
*/

-- 优化建议
-- ❌ 避免
SELECT * FROM account_transaction WHERE user_id = 1001;

-- ✅ 推荐
SELECT id, user_id, balance, status 
FROM account_transaction 
WHERE user_id = 1001;
```

### 回表成本模型

```sql
-- 查看表统计信息
SELECT 
    TABLE_NAME,
    TABLE_ROWS,
    AVG_ROW_LENGTH,
    DATA_LENGTH / 1024 / 1024 AS data_mb,
    INDEX_LENGTH / 1024 / 1024 AS index_mb
FROM information_schema.TABLES
WHERE TABLE_SCHEMA = 'mysql_labs' 
  AND TABLE_NAME = 'account_transaction';

-- 计算回表成本
/*
假设:
- 二级索引行: 20 bytes
- 主键行: 200 bytes
- 匹配100行

非覆盖索引成本:
= 100次二级索引读取 + 100次主键索引读取
= 100 * (20 + 200) = 22KB

覆盖索引成本:
= 100次二级索引读取
= 100 * 20 = 2KB

性能提升: 约10倍
*/
```

### 核心要点

- ✅ 覆盖索引标志：Extra = "Using index"
- ✅ 避免SELECT *，明确查询字段
- ✅ 高频查询优先建立覆盖索引
- ⚠️ 宽索引维护成本高，需权衡

------

## 实验11: 联合索引与最左前缀原则

### 实验目标

理解联合索引的匹配规则和优化器选择

### 索引准备

```sql
-- 已存在的联合索引
SHOW INDEX FROM account_transaction WHERE Key_name LIKE 'idx_%';

/*
idx_status_balance_time(status, balance, last_trans_time)
idx_branch_type_status_balance(branch_id, account_type, status, balance)
*/
```

### 场景A: 完全匹配（最优）

```sql
EXPLAIN SELECT * FROM account_transaction
WHERE status = 1 
  AND balance > 5000 
  AND last_trans_time > '2024-01-01';

/*
分析:
- key: idx_status_balance_time
- key_len: 1 + 7 + 4 = 12 (status + balance + time部分)
- type: range
- 三个字段全部用上
*/
```

### 场景B: 前缀匹配

```sql
-- 测试1: 只有第一列
EXPLAIN SELECT * FROM account_transaction WHERE status = 1;
-- key: idx_status_balance_time
-- key_len: 1 (仅status)

-- 测试2: 前两列
EXPLAIN SELECT * FROM account_transaction 
WHERE status = 1 AND balance > 5000;
-- key: idx_status_balance_time  
-- key_len: 8 (status + balance)

-- 测试3: 跳过第一列
EXPLAIN SELECT * FROM account_transaction WHERE balance > 5000;
-- key: NULL 或其他索引
-- idx_status_balance_time 不可用
```

### 场景C: 范围查询中断索引

```sql
EXPLAIN SELECT * FROM account_transaction
WHERE status = 1 
  AND balance > 5000  -- 范围查询
  AND last_trans_time > '2024-01-01'; -- 无法使用

/*
key_len: 8 (仅status + balance)
原因：balance范围查询后，last_trans_time无法利用索引排序
*/

-- 优化方案：调整索引顺序
ALTER TABLE account_transaction 
ADD INDEX idx_status_time_balance(status, last_trans_time, balance);

EXPLAIN SELECT * FROM account_transaction
WHERE status = 1 
  AND last_trans_time > '2024-01-01'
  AND balance > 5000;

-- 现在所有字段都能用上
```

### 场景D: OR 条件破坏索引

```sql
-- ❌ 无法使用联合索引
EXPLAIN SELECT * FROM account_transaction
WHERE status = 1 OR balance > 5000;

-- type: ALL (全表扫描)

-- ✅ 优化方案1: UNION
EXPLAIN 
SELECT * FROM account_transaction WHERE status = 1
UNION
SELECT * FROM account_transaction WHERE balance > 5000;

-- ✅ 优化方案2: 分别建立单列索引
ALTER TABLE account_transaction ADD INDEX idx_balance(balance);
-- 优化器可能选择Index Merge
```

### 场景E: 函数操作导致索引失效

```sql
-- ❌ 索引失效
EXPLAIN SELECT * FROM account_transaction
WHERE YEAR(last_trans_time) = 2024;

-- type: ALL

-- ✅ 改写为范围查询
EXPLAIN SELECT * FROM account_transaction
WHERE last_trans_time >= '2024-01-01' 
  AND last_trans_time < '2025-01-01';

-- type: range
-- key: idx_trans_time
```

### key_len 计算规则

```sql
/*
字段类型           | 长度计算
------------------|------------------
INT               | 4
BIGINT            | 8
TINYINT           | 1
DECIMAL(M,D)      | M/2 + 1 (约)
CHAR(N)           | N * 字符集字节数
VARCHAR(N)        | N * 字符集字节数 + 2
DATETIME          | 5
TIMESTAMP         | 4
允许NULL          | +1
变长类型          | +2

示例：
VARCHAR(50) utf8mb4 NOT NULL
= 50 * 4 + 2 = 202

DECIMAL(15,2) NOT NULL
= 15/2 + 1 = 8 (近似)
*/

-- 验证key_len
EXPLAIN SELECT * FROM account_transaction 
WHERE account_no = 'ACC20240001';

/*
account_no: CHAR(20) utf8mb4
key_len = 20 * 4 = 80
*/
```

### 核心要点

- ✅ 联合索引遵循最左前缀原则
- ✅ 范围查询会中断后续字段使用
- ✅ OR条件无法使用联合索引
- ✅ 函数/表达式破坏索引

------

## 实验12: Index Condition Pushdown (ICP)

### 实验目标

理解ICP优化器特性的工作原理和性能提升

### ICP原理说明

```
传统流程（无ICP）:
1. 存储引擎：根据索引条件筛选
2. Server层：获取完整行
3. Server层：应用剩余WHERE条件

ICP流程:
1. 存储引擎：根据索引条件筛选
2. 存储引擎：应用索引包含的WHERE条件（下推）
3. Server层：仅获取过滤后的行
```

### 场景A: ICP生效条件

```sql
-- 联合索引：idx_branch_type_status_balance
EXPLAIN SELECT * FROM account_transaction
WHERE branch_id = 101 
  AND account_type = 1
  AND status IN (1, 2);

/*
分析:
- key: idx_branch_type_status_balance
- key_len: 4 + 1 + 1 = 6 (前三列)
- Extra: Using index condition (ICP生效)

工作过程:
1. 通过branch_id=101定位索引
2. 在索引中直接过滤account_type=1和status IN (1,2)
3. 减少回表次数
*/
```

### 场景B: 对比ICP开关

```sql
-- 关闭ICP
SET optimizer_switch='index_condition_pushdown=off';

EXPLAIN SELECT * FROM account_transaction
WHERE branch_id = 101 
  AND account_type = 1
  AND status IN (1, 2);

/*
Extra: Using where (无ICP)
需要回表后在Server层过滤
*/

-- 性能对比
SET profiling = 1;

-- 无ICP
SELECT * FROM account_transaction
WHERE branch_id = 101 AND account_type = 1 AND status IN (1, 2);

-- 开启ICP
SET optimizer_switch='index_condition_pushdown=on';

SELECT * FROM account_transaction
WHERE branch_id = 101 AND account_type = 1 AND status IN (1, 2);

SHOW PROFILES;

-- 预期：ICP性能提升20%-50%
```

### 场景C: ICP不生效的情况

```sql
-- 情况1: 主键查询（无需ICP）
EXPLAIN SELECT * FROM account_transaction WHERE id = 1;
-- Extra: 无"Using index condition"

-- 情况2: 覆盖索引（无需回表）
EXPLAIN SELECT status, balance FROM account_transaction 
WHERE status = 1;
-- Extra: Using where; Using index

-- 情况3: 全表扫描
EXPLAIN SELECT * FROM account_transaction 
WHERE remark LIKE '%test%';
-- Extra: Using where
```

### ICP监控指标

```sql
-- 查看ICP相关统计
SHOW STATUS LIKE 'Handler_read%';

/*
Handler_read_rnd_next: 顺序读下一行
Handler_read_rnd: 随机位置读（回表）
Handler_read_key: 索引读

ICP生效时Handler_read_rnd显著减少
*/

-- 重置计数器
FLUSH STATUS;

-- 执行查询后查看
SHOW STATUS LIKE 'Handler_read%';
```

### 核心要点

- ✅ ICP仅对非聚簇索引有效
- ✅ 需要回表才有优化空间
- ✅ 减少回表次数，提升性能
- ✅ MySQL 5.6+ 默认开启

------

## 实验13: 查询优化器Cost Model分析

### 实验目标

理解优化器如何基于统计信息和代价模型选择执行计划

### 统计信息收集

```sql
-- 更新统计信息
ANALYZE TABLE account_transaction;

-- 查看统计信息
SELECT 
    INDEX_NAME,
    COLUMN_NAME,
    SEQ_IN_INDEX,
    CARDINALITY,
    SUB_PART,
    NULLABLE
FROM information_schema.STATISTICS
WHERE TABLE_SCHEMA = 'mysql_labs'
  AND TABLE_NAME = 'account_transaction'
ORDER BY INDEX_NAME, SEQ_IN_INDEX;

/*
关键指标:
- CARDINALITY: 索引基数（唯一值数量）
- 基数越高，选择性越好
*/
```

### 场景A: 优化器选择错误索引

```sql
-- 场景：低选择性字段
EXPLAIN SELECT * FROM account_transaction WHERE status = 1;

/*
假设：
- idx_status基数: 4 (状态只有0,1,2,3)
- 表总行数: 18
- status=1占比: 70%

优化器可能误判全表扫描更快
*/

-- 强制使用索引
EXPLAIN SELECT * FROM account_transaction 
FORCE INDEX(idx_status) 
WHERE status = 1;

-- 对比成本
EXPLAIN FORMAT=JSON 
SELECT * FROM account_transaction WHERE status = 1\G

/*
"cost_info": {
  "read_cost": "3.60",
  "eval_cost": "1.80",
  "prefix_cost": "5.40",
  "data_read_per_join": "..."
}

公式:
总成本 = 读取成本 + 评估成本
读取成本 = 页读取成本 + 行扫描成本
*/
```

### 场景B: 多索引可选时的决策

```sql
-- 同时有多个可用索引
EXPLAIN SELECT * FROM account_transaction
WHERE status = 1 AND balance > 5000;

/*
候选索引:
1. idx_status
2. idx_balance_status
3. idx_status_balance_time

优化器选择依据:
- 索引列顺序匹配度
- 覆盖字段数量
- 基数和选择性
- 回表成本
*/

-- 查看优化器 trace
SET optimizer_trace='enabled=on';

SELECT * FROM account_transaction
WHERE status = 1 AND balance > 5000;

SELECT * FROM information_schema.OPTIMIZER_TRACE\G

/*
trace信息包含:
- considered_execution_plans: 考虑的执行计划
- cost: 每个计划的成本
- chosen: 最终选择及原因
*/

SET optimizer_trace='enabled=off';
```

### 场景C: JOIN优化器决策

```sql
EXPLAIN SELECT 
    a.id,
    a.balance,
    COUNT(t.id) AS trans_count
FROM account_transaction a
LEFT JOIN transaction_log t ON a.id = t.account_id
WHERE a.status = 1
  AND t.trans_time >= '2024-01-01'
GROUP BY a.id, a.balance;

/*
优化器决策:
1. 驱动表选择（小表驱动大表）
2. JOIN方式（Nested Loop / Hash Join / Block Loop）
3. JOIN顺序
4. 索引选择

分析字段:
- select_type: SIMPLE / SUBQUERY / DERIVED
- table: 表访问顺序
- rows: 预估扫描行数
- filtered: 过滤百分比
- Extra: JOIN算法
*/
```

### 成本模型参数调整

```sql
-- 查看成本模型参数
SELECT * FROM mysql.server_cost;
SELECT * FROM mysql.engine_cost;

/*
关键参数:
- disk_temptable_create_cost: 磁盘临时表创建成本
- key_compare_cost: 键比较成本
- memory_temptable_create_cost: 内存临时表成本
- row_evaluate_cost: 行评估成本
*/

-- 调整参数（仅测试，生产慎用）
UPDATE mysql.engine_cost 
SET cost_value = 0.5 
WHERE cost_name = 'io_block_read_cost';

FLUSH OPTIMIZER_COSTS;
```

### 优化器Hint使用

```sql
-- Hint语法（MySQL 8.0+）
SELECT /*+ MAX_EXECUTION_TIME(1000) */ * 
FROM account_transaction WHERE status = 1;

-- 索引Hint
SELECT /*+ INDEX(account_transaction idx_status) */ * 
FROM account_transaction WHERE status = 1;

-- JOIN顺序Hint
SELECT /*+ JOIN_ORDER(a, t) */ 
    a.id, t.amount
FROM account_transaction a
JOIN transaction_log t ON a.id = t.account_id;

-- 并行查询Hint（MySQL 8.0.14+）
SELECT /*+ SET_VAR(parallel_workers=4) */ 
COUNT(*) FROM account_transaction;
```

### 核心要点

- ✅ ANALYZE TABLE确保统计信息准确
- ✅ 使用EXPLAIN FORMAT=JSON查看成本
- ✅ optimizer_trace深入分析决策过程
- ⚠️ 低选择性索引可能被放弃
- ⚠️ Hint仅在必要时使用

------

## 实验14: 慢查询优化全流程

### Step 1: 开启慢查询日志

```sql
-- 查看当前配置
SHOW VARIABLES LIKE 'slow_query%';
SHOW VARIABLES LIKE 'long_query_time';

-- 会话级别开启
SET SESSION slow_query_log = 1;
SET SESSION long_query_time = 0.1; -- 100ms

-- 全局配置（my.cnf）
/*
[mysqld]
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow.log
long_query_time = 0.5
log_queries_not_using_indexes = 1
*/
```

### Step 2: 模拟慢查询

```sql
-- 慢查询1: 全表扫描
SELECT * FROM account_transaction 
WHERE remark LIKE '%test%';

-- 慢查询2: 无索引JOIN
SELECT a.*, t.*
FROM account_transaction a, transaction_log t
WHERE a.user_id = t.account_id;

-- 慢查询3: 子查询未优化
SELECT * FROM account_transaction
WHERE id IN (
    SELECT account_id FROM transaction_log 
    WHERE trans_type = 1
);
```

### Step 3: 分析慢查询

```sql
-- 使用mysqldumpslow分析（命令行）
-- mysqldumpslow -s t -t 10 /var/log/mysql/slow.log

-- 或使用pt-query-digest（Percona Toolkit）
-- pt-query-digest /var/log/mysql/slow.log

-- 在MySQL内查询
SELECT 
    DIGEST_TEXT,
    COUNT_STAR AS exec_count,
    AVG_TIMER_WAIT/1000000000000 AS avg_time_sec,
    MAX_TIMER_WAIT/1000000000000 AS max_time_sec,
    SUM_ROWS_EXAMINED AS total_rows_examined,
    SUM_ROWS_SENT AS total_rows_sent
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = 'mysql_labs'
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 10;
```

### Step 4: 优化方案

```sql
-- 优化1: 添加索引
ALTER TABLE account_transaction 
ADD FULLTEXT INDEX ft_remark(remark);

SELECT * FROM account_transaction 
WHERE MATCH(remark) AGAINST('test' IN NATURAL LANGUAGE MODE);

-- 优化2: 改写JOIN
EXPLAIN SELECT a.*, t.*
FROM account_transaction a
INNER JOIN transaction_log t ON a.id = t.account_id;

-- 优化3: 改写子查询
EXPLAIN SELECT a.*
FROM account_transaction a
WHERE EXISTS (
    SELECT 1 FROM transaction_log t
    WHERE t.account_id = a.id AND t.trans_type = 1
);

-- 或使用JOIN
EXPLAIN SELECT DISTINCT a.*
FROM account_transaction a
INNER JOIN transaction_log t ON a.id = t.account_id
WHERE t.trans_type = 1;
```

### Step 5: 验证优化效果

```sql
-- 对比执行计划
EXPLAIN FORMAT=JSON [优化前SQL];
EXPLAIN FORMAT=JSON [优化后SQL];

-- 对比实际执行时间
SET profiling = 1;
[优化前SQL];
[优化后SQL];
SHOW PROFILES;
```

### 核心要点

- ✅ 开启慢查询日志监控
- ✅ 使用EXPLAIN分析执行计划
- ✅ 优先优化高频慢查询
- ✅ 添加索引需权衡维护成本

------

## 索引优化总结

### 三星索引标准

| 星级 | 定义                           | 示例                    |
| ---- | ------------------------------ | ----------------------- |
| ⭐    | WHERE过滤列在索引中            | idx_status              |
| ⭐⭐   | 避免排序（ORDER BY列在索引中） | idx_status_balance      |
| ⭐⭐⭐  | 覆盖索引（SELECT列在索引中）   | idx_status_balance_time |

### 索引设计原则

```sql
-- ✅ DO
1. 高频查询的WHERE列建立索引
2. 联合索引考虑区分度从高到低
3. 覆盖高频查询的所有列
4. 控制索引数量（单表≤5个）
5. 定期ANALYZE TABLE更新统计信息

-- ❌ DON'T
1. 低基数列单独建索引（如性别）
2. 频繁更新的列建多个索引
3. 过长的VARCHAR建索引（考虑前缀索引）
4. 无WHERE条件的列建索引
5. 重复或冗余的索引
```

### 生产环境检查清单

```sql
-- 检查1: 冗余索引
SELECT 
    a.TABLE_SCHEMA,
    a.TABLE_NAME,
    a.INDEX_NAME AS index1,
    b.INDEX_NAME AS index2,
    a.COLUMN_NAME
FROM information_schema.STATISTICS a
JOIN information_schema.STATISTICS b
    ON a.TABLE_SCHEMA = b.TABLE_SCHEMA
    AND a.TABLE_NAME = b.TABLE_NAME
    AND a.COLUMN_NAME = b.COLUMN_NAME
    AND a.SEQ_IN_INDEX = b.SEQ_IN_INDEX
    AND a.INDEX_NAME < b.INDEX_NAME
WHERE a.TABLE_SCHEMA = 'mysql_labs';

-- 检查2: 未使用的索引
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    INDEX_NAME,
    COUNT_STAR,
    COUNT_READ,
    COUNT_INSERT,
    COUNT_UPDATE,
    COUNT_DELETE
FROM performance_schema.table_io_waits_summary_by_index_usage
WHERE OBJECT_SCHEMA = 'mysql_labs'
  AND COUNT_STAR = 0
  AND INDEX_NAME IS NOT NULL;

-- 检查3: 缺失索引（频繁全表扫描）
SELECT 
    OBJECT_SCHEMA,
    OBJECT_NAME,
    COUNT_READ,
    COUNT_FETCH,
    SUM_TIMER_WAIT/1000000000000 AS total_time_sec
FROM performance_schema.table_io_waits_summary_by_table
WHERE OBJECT_SCHEMA = 'mysql_labs'
  AND COUNT_READ > 1000
ORDER BY SUM_TIMER_WAIT DESC;
```