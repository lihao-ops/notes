# 高并发场景综合实战案例

## 案例1: 秒杀系统 - 库存扣减方案对比

### 业务场景

- 10000个用户同时抢购100件商品
- 要求: 不超卖、不少卖、高性能

### 方案A: 悲观锁（FOR UPDATE）

```sql
-- 创建秒杀商品表
CREATE TABLE seckill_product (
    id INT PRIMARY KEY,
    product_name VARCHAR(100),
    stock INT NOT NULL,
    version INT NOT NULL DEFAULT 0,
    INDEX idx_stock(stock)
) ENGINE=InnoDB;

INSERT INTO seckill_product VALUES (1, 'iPhone 15', 100, 0);

-- 秒杀逻辑
DELIMITER $$
CREATE PROCEDURE sp_seckill_pessimistic(
    IN p_user_id BIGINT,
    IN p_product_id INT,
    OUT p_result VARCHAR(50)
)
BEGIN
    DECLARE v_stock INT;
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = 'ERROR';
    END;
    
    START TRANSACTION;
    
    -- 悲观锁锁定行
    SELECT stock INTO v_stock 
    FROM seckill_product 
    WHERE id = p_product_id 
    FOR UPDATE;
    
    IF v_stock <= 0 THEN
        SET p_result = 'SOLD_OUT';
        ROLLBACK;
    ELSE
        -- 扣减库存
        UPDATE seckill_product 
        SET stock = stock - 1 
        WHERE id = p_product_id;
        
        -- 创建订单（简化）
        INSERT INTO seckill_order(user_id, product_id, create_time)
        VALUES(p_user_id, p_product_id, NOW());
        
        SET p_result = 'SUCCESS';
        COMMIT;
    END IF;
END$$
DELIMITER ;

-- 压测（模拟10个并发）
-- 在10个会话中同时执行
CALL sp_seckill_pessimistic(1001, 1, @result);
SELECT @result;
```

**性能分析**

```sql
-- 查看锁等待
SELECT 
    COUNT(*) AS waiting_count
FROM information_schema.innodb_trx
WHERE trx_state = 'LOCK WAIT';

-- TPS预估：单行锁，串行执行
-- 100件商品 / (0.01秒 * 100) = 1000 TPS
```

### 方案B: 乐观锁（CAS）

```sql
DELIMITER $$
CREATE PROCEDURE sp_seckill_optimistic(
    IN p_user_id BIGINT,
    IN p_product_id INT,
    OUT p_result VARCHAR(50)
)
BEGIN
    DECLARE v_stock INT;
    DECLARE v_version INT;
    DECLARE v_affected INT;
    DECLARE v_retry INT DEFAULT 0;
    
    retry_loop: LOOP
        START TRANSACTION;
        
        -- 读取当前状态
        SELECT stock, version INTO v_stock, v_version
        FROM seckill_product 
        WHERE id = p_product_id;
        
        IF v_stock <= 0 THEN
            SET p_result = 'SOLD_OUT';
            ROLLBACK;
            LEAVE retry_loop;
        END IF;
        
        -- CAS更新
        UPDATE seckill_product 
        SET stock = stock - 1, 
            version = version + 1
        WHERE id = p_product_id 
          AND version = v_version
          AND stock > 0;
        
        SET v_affected = ROW_COUNT();
        
        IF v_affected = 1 THEN
            INSERT INTO seckill_order(user_id, product_id, create_time)
            VALUES(p_user_id, p_product_id, NOW());
            
            SET p_result = 'SUCCESS';
            COMMIT;
            LEAVE retry_loop;
        ELSE
            ROLLBACK;
            SET v_retry = v_retry + 1;
            
            IF v_retry >= 3 THEN
                SET p_result = 'RETRY_EXCEEDED';
                LEAVE retry_loop;
            END IF;
            
            -- 随机退避
            DO SLEEP(0.001 + RAND() * 0.005);
        END IF;
    END LOOP;
END$$
DELIMITER ;
```

**性能分析**

```sql
-- 无锁等待，但有重试成本
-- TPS预估：并发度高，2000-3000 TPS
-- 适用场景：库存充足，冲突率<30%
```

### 方案C: Redis预扣减 + MySQL异步落库

```sql
-- MySQL仅做最终一致性保证
-- 实际扣减在Redis完成

-- Redis Lua脚本（伪代码）
/*
local stock = redis.call('GET', KEYS[1])
if tonumber(stock) > 0 then
    redis.call('DECR', KEYS[1])
    redis.call('LPUSH', 'order_queue', ARGV[1])
    return 1
else
    return 0
end
*/

-- MySQL消费队列异步写入
CREATE EVENT event_consume_order
ON SCHEDULE EVERY 1 SECOND
DO
BEGIN
    -- 批量插入订单
    INSERT INTO seckill_order 
    SELECT * FROM temp_order_queue LIMIT 1000;
    
    DELETE FROM temp_order_queue LIMIT 1000;
END;
```

**性能对比**

| 方案   | TPS    | 优点     | 缺点       | 适用场景                 |
| ------ | ------ | -------- | ---------- | ------------------------ |
| 悲观锁 | 1000   | 强一致性 | 性能瓶颈   | 库存少、要求绝对准确     |
| 乐观锁 | 2500   | 高并发   | 重试成本   | 库存适中、允许短暂不一致 |
| Redis  | 10000+ | 极高性能 | 最终一致性 | 海量并发、允许异步       |

------

## 案例2: 转账系统 - 分布式事务

### 业务场景

- A账户转账给B账户
- 要求: 原子性、一致性、防止重复提交

### 方案A: 本地事务（单库）

```sql
DELIMITER $$
CREATE PROCEDURE sp_transfer_local(
    IN p_from_account BIGINT,
    IN p_to_account BIGINT,
    IN p_amount DECIMAL(15,2),
    IN p_trans_id VARCHAR(50), -- 幂等性保证
    OUT p_result VARCHAR(50)
)
BEGIN
    DECLARE v_from_balance DECIMAL(15,2);
    DECLARE v_exists INT;
    
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        SET p_result = 'ERROR';
    END;
    
    START TRANSACTION;
    
    -- 幂等性检查
    SELECT COUNT(*) INTO v_exists 
    FROM transfer_log 
    WHERE trans_id = p_trans_id;
    
    IF v_exists > 0 THEN
        SET p_result = 'DUPLICATE';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 锁定转出账户（避免死锁：总是先锁ID小的）
    IF p_from_account < p_to_account THEN
        SELECT balance INTO v_from_balance
        FROM account_transaction
        WHERE id = p_from_account
        FOR UPDATE;
        
        SELECT balance FROM account_transaction
        WHERE id = p_to_account
        FOR UPDATE;
    ELSE
        SELECT balance FROM account_transaction
        WHERE id = p_to_account
        FOR UPDATE;
        
        SELECT balance INTO v_from_balance
        FROM account_transaction
        WHERE id = p_from_account
        FOR UPDATE;
    END IF;
    
    -- 余额检查
    IF v_from_balance < p_amount THEN
        SET p_result = 'INSUFFICIENT_BALANCE';
        ROLLBACK;
        LEAVE proc_label;
    END IF;
    
    -- 扣减转出账户
    UPDATE account_transaction 
    SET balance = balance - p_amount,
        version = version + 1
    WHERE id = p_from_account;
    
    -- 增加转入账户
    UPDATE account_transaction 
    SET balance = balance + p_amount,
        version = version + 1
    WHERE id = p_to_account;
    
    -- 记录流水
    INSERT INTO transfer_log(
        trans_id, from_account, to_account, 
        amount, status, create_time
    ) VALUES (
        p_trans_id, p_from_account, p_to_account,
        p_amount, 'SUCCESS', NOW()
    );
    
    SET p_result = 'SUCCESS';
    COMMIT;
END proc_label $$
DELIMITER ;

-- 测试
CALL sp_transfer_local(1, 2, 100.00, UUID(), @result);
SELECT @result;
```

### 方案B: 两阶段提交（分库场景）

```sql
-- 准备阶段表
CREATE TABLE transfer_prepare (
    trans_id VARCHAR(50) PRIMARY KEY,
    from_account BIGINT,
    to_account BIGINT,
    amount DECIMAL(15,2),
    status TINYINT, -- 0:INIT 1:PREPARED 2:COMMITTED 3:ROLLBACK
    create_time DATETIME,
    expire_time DATETIME,
    INDEX idx_status_expire(status, expire_time)
) ENGINE=InnoDB;

-- 第一阶段：准备
DELIMITER $$
CREATE PROCEDURE sp_transfer_prepare(
    IN p_trans_id VARCHAR(50),
    IN p_from_account BIGINT,
    IN p_amount DECIMAL(15,2),
    OUT p_result VARCHAR(50)
)
BEGIN
    DECLARE v_balance DECIMAL(15,2);
    
    START TRANSACTION;
    
    -- 插入准备记录
    INSERT INTO transfer_prepare(
        trans_id, from_account, amount, 
        status, create_time, expire_time
    ) VALUES (
        p_trans_id, p_from_account, p_amount,
        0, NOW(), NOW() + INTERVAL 1 MINUTE
    );
    
    -- 冻结金额
    SELECT balance INTO v_balance
    FROM account_transaction
    WHERE id = p_from_account
    FOR UPDATE;
    
    IF v_balance < p_amount THEN
        SET p_result = 'INSUFFICIENT';
        ROLLBACK;
    ELSE
        UPDATE account_transaction
        SET frozen_amount = frozen_amount + p_amount
        WHERE id = p_from_account;
        
        UPDATE transfer_prepare
        SET status = 1
        WHERE trans_id = p_trans_id;
        
        SET p_result = 'PREPARED';
        COMMIT;
    END IF;
END$$

-- 第二阶段：提交
CREATE PROCEDURE sp_transfer_commit(
    IN p_trans_id VARCHAR(50),
    OUT p_result VARCHAR(50)
)
BEGIN
    DECLARE v_from_account BIGINT;
    DECLARE v_to_account BIGINT;
    DECLARE v_amount DECIMAL(15,2);
    
    START TRANSACTION;
    
    -- 获取准备数据
    SELECT from_account, to_account, amount
    INTO v_from_account, v_to_account, v_amount
    FROM transfer_prepare
    WHERE trans_id = p_trans_id AND status = 1
    FOR UPDATE;
    
    -- 扣减转出账户
    UPDATE account_transaction
    SET balance = balance - v_amount,
        frozen_amount = frozen_amount - v_amount
    WHERE id = v_from_account;
    
    -- 增加转入账户
    UPDATE account_transaction
    SET balance = balance + v_amount
    WHERE id = v_to_account;
    
    -- 更新状态
    UPDATE transfer_prepare
    SET status = 2
    WHERE trans_id = p_trans_id;
    
    SET p_result = 'COMMITTED';
    COMMIT;
END$$

-- 第二阶段：回滚
CREATE PROCEDURE sp_transfer_rollback(
    IN p_trans_id VARCHAR(50),
    OUT p_result VARCHAR(50)
)
BEGIN
    DECLARE v_from_account BIGINT;
    DECLARE v_amount DECIMAL(15,2);
    
    START TRANSACTION;
    
    SELECT from_account, amount
    INTO v_from_account, v_amount
    FROM transfer_prepare
    WHERE trans_id = p_trans_id AND status = 1
    FOR UPDATE;
    
    -- 解冻
    UPDATE account_transaction
    SET frozen_amount = frozen_amount - v_amount
    WHERE id = v_from_account;
    
    UPDATE transfer_prepare
    SET status = 3
    WHERE trans_id = p_trans_id;
    
    SET p_result = 'ROLLBACK';
    COMMIT;
END$$
DELIMITER ;

-- 超时回滚定时任务
CREATE EVENT event_transfer_timeout
ON SCHEDULE EVERY 10 SECOND
DO
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_trans_id VARCHAR(50);
    DECLARE cur CURSOR FOR 
        SELECT trans_id FROM transfer_prepare
        WHERE status = 1 AND expire_time < NOW();
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO v_trans_id;
        IF done THEN
            LEAVE read_loop;
        END IF;
        
        CALL sp_transfer_rollback(v_trans_id, @result);
    END LOOP;
    CLOSE cur;
END;
```

### 方案C: TCC（Try-Confirm-Cancel）

```sql
-- 类似2PC，但更灵活
-- Try: 资源检查和预留
-- Confirm: 执行业务逻辑
-- Cancel: 释放预留资源

-- 实现与2PC类似，此处省略
```

------

## 案例3: 订单系统 - 分页查询优化

### 业务场景

- 1000万订单数据
- 用户查询自己的订单历史（分页）

### 方案A: 传统LIMIT分页（深度分页问题）

```sql
-- 第1页（快）
SELECT * FROM transaction_log
WHERE account_id = 1
ORDER BY trans_time DESC
LIMIT 0, 20;
-- 耗时: 10ms

-- 第100页（慢）
SELECT * FROM transaction_log
WHERE account_id = 1
ORDER BY trans_time DESC
LIMIT 2000, 20;
-- 耗时: 200ms

-- 第10000页（极慢）
SELECT * FROM transaction_log
WHERE account_id = 1
ORDER BY trans_time DESC
LIMIT 200000, 20;
-- 耗时: 5000ms

-- 问题：MySQL需要扫描前200000行再丢弃
```

### 方案B: 子查询优化

```sql
-- 优化思路：先通过索引定位，再回表
SELECT t.*
FROM transaction_log t
INNER JOIN (
    SELECT id
    FROM transaction_log
    WHERE account_id = 1
    ORDER BY trans_time DESC
    LIMIT 200000, 20
) tmp ON t.id = tmp.id;

-- 性能提升：200ms → 50ms
-- 原因：子查询使用覆盖索引，减少回表
```

### 方案C: 延迟关联

```sql
-- 进一步优化
SELECT t.*
FROM transaction_log t
WHERE t.id >= (
    SELECT id
    FROM transaction_log
    WHERE account_id = 1
    ORDER BY trans_time DESC
    LIMIT 200000, 1
)
AND account_id = 1
ORDER BY trans_time DESC
LIMIT 20;

-- 性能: 50ms → 20ms
```

### 方案D: 游标分页（推荐）

```sql
-- 第一次请求
SELECT id, trans_time, amount
FROM transaction_log
WHERE account_id = 1
ORDER BY trans_time DESC
LIMIT 20;

-- 返回最后一条记录：last_id=12345, last_time='2024-10-15 10:00:00'

-- 第二次请求（使用游标）
SELECT id, trans_time, amount
FROM transaction_log
WHERE account_id = 1
  AND (trans_time < '2024-10-15 10:00:00' 
       OR (trans_time = '2024-10-15 10:00:00' AND id < 12345))
ORDER BY trans_time DESC, id DESC
LIMIT 20;

-- 性能：恒定<10ms，不受页数影响
-- 限制：不能跳页，只能顺序翻页
```

### 方案E: 数据冗余（适合复杂排序）

```sql
-- 创建汇总表
CREATE TABLE transaction_summary (
    user_id BIGINT,
    year_month INT, -- 202410
    total_count INT,
    total_amount DECIMAL(15,2),
    PRIMARY KEY(user_id, year_month)
) ENGINE=InnoDB;

-- 按月分页，先查汇总再查明细
SELECT year_month FROM transaction_summary
WHERE user_id = 1
ORDER BY year_month DESC;

-- 再查具体月份的明细
SELECT * FROM transaction_log
WHERE account_id = 1
  AND trans_time >= '2024-10-01'
  AND trans_time < '2024-11-01'
ORDER BY trans_time DESC;
```

**分页方案对比**

| 方案   | 深度分页性能 | 跳页支持 | 实现复杂度 | 适用场景         |
| ------ | ------------ | -------- | ---------- | ---------------- |
| LIMIT  | 差           | 支持     | 简单       | 小数据量         |
| 子查询 | 中           | 支持     | 中等       | 中等数据量       |
| 游标   | 优           | 不支持   | 简单       | 大数据量顺序翻页 |
| 冗余表 | 优           | 支持     | 复杂       | 复杂统计查询     |

------

## 案例4: 实时报表 - 聚合查询优化

### 业务场景

- 实时统计各网点的账户数和总余额
- 要求响应时间<200ms

### 方案A: 直接聚合（慢）

```sql
SELECT 
    branch_id,
    COUNT(*) AS account_count,
    SUM(balance) AS total_balance,
    AVG(balance) AS avg_balance
FROM account_transaction
WHERE status = 1
GROUP BY branch_id;

-- 10万行数据耗时: 800ms
```

### 方案B: 物化视图（不支持，改用定时汇总）

```sql
-- 创建汇总表
CREATE TABLE branch_summary (
    branch_id INT PRIMARY KEY,
    account_count INT,
    total_balance DECIMAL(18,2),
    avg_balance DECIMAL(15,2),
    update_time DATETIME,
    INDEX idx_update_time(update_time)
) ENGINE=InnoDB;

-- 定时刷新（每分钟）
DELIMITER $$
CREATE PROCEDURE sp_refresh_branch_summary()
BEGIN
    DELETE FROM branch_summary;
    
    INSERT INTO branch_summary
    SELECT 
        branch_id,
        COUNT(*),
        SUM(balance),
        AVG(balance),
        NOW()
    FROM account_transaction
    WHERE status = 1
    GROUP BY branch_id;
END$$
DELIMITER ;

-- 创建定时任务
CREATE EVENT event_refresh_summary
ON SCHEDULE EVERY 1 MINUTE
DO CALL sp_refresh_branch_summary();

-- 查询汇总表（快）
SELECT * FROM branch_summary;
-- 耗时: <5ms
```

### 方案C: 增量更新（精确实时）

```sql
-- 触发器维护汇总表
DELIMITER $$
CREATE TRIGGER trg_account_after_insert
AFTER INSERT ON account_transaction
FOR EACH ROW
BEGIN
    INSERT INTO branch_summary(
        branch_id, account_count, total_balance, avg_balance, update_time
    ) VALUES (
        NEW.branch_id, 1, NEW.balance, NEW.balance, NOW()
    )
    ON DUPLICATE KEY UPDATE
        account_count = account_count + 1,
        total_balance = total_balance + NEW.balance,
        avg_balance = total_balance / account_count,
        update_time = NOW();
END$$

CREATE TRIGGER trg_account_after_update
AFTER UPDATE ON account_transaction
FOR EACH ROW
BEGIN
    UPDATE branch_summary
    SET total_balance = total_balance - OLD.balance + NEW.balance,
        avg_balance = total_balance / account_count,
        update_time = NOW()
    WHERE branch_id = NEW.branch_id;
END$$

CREATE TRIGGER trg_account_after_delete
AFTER DELETE ON account_transaction
FOR EACH ROW
BEGIN
    UPDATE branch_summary
    SET account_count = account_count - 1,
        total_balance = total_balance - OLD.balance,
        avg_balance = IF(account_count > 0, total_balance / account_count, 0),
        update_time = NOW()
    WHERE branch_id = OLD.branch_id;
END$$
DELIMITER ;

-- 查询实时数据
SELECT * FROM branch_summary;
```

### 方案D: 双写一致性（适合微服务）

```sql
-- 应用层双写
-- 1. 更新account_transaction
-- 2. 发送MQ消息
-- 3. 消费者更新branch_summary

-- 保证最终一致性
-- MySQL仅存储明细，Redis存储汇总
```

**报表方案对比**

| 方案     | 实时性 | 查询性能 | 写入性能 | 一致性   |
| -------- | ------ | -------- | -------- | -------- |
| 直接聚合 | 强     | 差       | 好       | 强一致   |
| 定时汇总 | 分钟级 | 优       | 好       | 最终一致 |
| 触发器   | 强     | 优       | 差       | 强一致   |
| 双写MQ   | 秒级   | 优       | 好       | 最终一致 |

------

## 性能优化总结

### 高并发三板斧

1. **缓存**: Redis/Memcached减轻DB压力
2. **异步**: MQ削峰填谷
3. **拆分**: 分库分表/读写分离

### SQL优化核心

1. **索引**: 确保查询走索引
2. **减少回表**: 覆盖索引
3. **减少扫描**: 精确WHERE条件
4. **避免锁冲突**: 乐观锁/缩小事务范围

### 监控指标

```sql
-- 慢查询数
SHOW GLOBAL STATUS LIKE 'Slow_queries';

-- QPS/TPS
SHOW GLOBAL STATUS LIKE 'Questions';
SHOW GLOBAL STATUS LIKE 'Com_commit';

-- 连接数
SHOW GLOBAL STATUS LIKE 'Threads_connected';

-- 锁等待
SHOW GLOBAL STATUS LIKE 'Innodb_row_lock_waits';

-- 死锁
SHOW ENGINE INNODB STATUS;
```

### 容量规划

```sql
-- 单表建议: <2000万行
-- 单库建议: <50GB
-- 超过阈值考虑分库分表
```