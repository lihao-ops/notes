# MySQL核心技术体系化学习路径

## 第一阶段: 基础理论（1-2周）

### 学习内容

#### 1.1 MySQL架构体系
- [ ] Server层 vs 存储引擎层
- [ ] 查询执行流程（连接器→分析器→优化器→执行器）
- [ ] InnoDB架构（Buffer Pool、Change Buffer、Redo Log、Undo Log）
- [ ] 数据页结构（16KB页、B+树组织）

**验证实验**
```sql
-- 查看架构参数
SHOW VARIABLES LIKE 'innodb_buffer_pool_size';
SHOW VARIABLES LIKE 'innodb_log_file_size';

-- 查看页使用情况
SHOW ENGINE INNODB STATUS\G
-- 关注：Buffer pool size, Free buffers, Database pages
```

#### 1.2 事务ACID理论
- [ ] 原子性（Atomicity）- Undo Log实现
- [ ] 一致性（Consistency）- 业务逻辑保证
- [ ] 隔离性（Isolation）- 锁 + MVCC
- [ ] 持久性（Durability）- Redo Log实现

**必答题**
1. 为什么需要Redo Log和Undo Log两种日志？
2. 描述Write-Ahead Logging（WAL）机制
3. 说明InnoDB如何实现崩溃恢复

---

## 第二阶段: 事务隔离与MVCC（2-3周）

### 学习目标
- 完全理解四种隔离级别的差异
- 掌握MVCC的Read View机制
- 能够分析版本链的可见性判断

### 实验清单

| 实验编号 | 实验名称        | 核心知识点       | 难度 |
| -------- | --------------- | ---------------- | ---- |
| EXP-01   | 脏读验证        | READ UNCOMMITTED | ⭐    |
| EXP-02   | 不可重复读验证  | READ COMMITTED   | ⭐⭐   |
| EXP-03   | 幻读验证        | REPEATABLE READ  | ⭐⭐⭐  |
| EXP-04   | Read View可见性 | MVCC核心原理     | ⭐⭐⭐⭐ |
| EXP-05   | 乐观锁实现      | CAS + version    | ⭐⭐⭐  |

### 考核标准

**初级**（60分）
- 能说出四种隔离级别的名称
- 知道MySQL默认隔离级别
- 能演示脏读和不可重复读

**中级**（80分）
- 理解Read View的四个字段含义
- 能画出MVCC版本链示意图
- 能解释为什么RR级别下快照读不产生幻读

**高级**（95分）
- 能手写版本链的可见性判断算法
- 理解当前读和快照读的区别
- 能设计基于MVCC的无锁并发方案

**专家级**（100分）
- 能解释Undo Log的purge机制
- 理解一致性非锁定读的底层实现
- 能分析长事务对MVCC的性能影响

---

## 第三阶段: 锁机制深度（3-4周）

### 学习目标
- 区分表锁、行锁、间隙锁、Next-Key Lock
- 掌握死锁的识别、分析、预防
- 理解锁的粒度和升级机制

### 实验清单

| 实验编号 | 实验名称     | 核心知识点         | 难度 |
| -------- | ------------ | ------------------ | ---- |
| EXP-06   | 行锁vs表锁   | 索引对锁的影响     | ⭐⭐   |
| EXP-07   | 间隙锁实验   | Gap Lock原理       | ⭐⭐⭐  |
| EXP-08   | 死锁复现     | 循环等待检测       | ⭐⭐⭐⭐ |
| EXP-09   | 锁等待监控   | performance_schema | ⭐⭐⭐  |
| EXP-10   | RC vs RR加锁 | 隔离级别对锁的影响 | ⭐⭐⭐⭐ |

### 锁机制面试题库

**题目1: 为什么唯一索引等值查询不加间隙锁？**
<details>
<summary>点击查看答案</summary>

原因：
1. 唯一索引保证记录唯一性
2. 不存在"间隙内插入重复值"的幻读风险
3. 只需锁定记录本身（Record Lock）

特例：
- 查询记录不存在时，仍然加Gap Lock
- 非唯一索引始终需要Next-Key Lock

验证SQL：
```sql
-- 记录存在：仅Record Lock
SELECT * FROM account_transaction 
WHERE account_no = 'ACC20240001' FOR UPDATE;

-- 记录不存在：Gap Lock
SELECT * FROM account_transaction 
WHERE account_no = 'ACC99999999' FOR UPDATE;
```
</details>

**题目2: 如何排查和解决线上死锁？**
<details>
<summary>点击查看答案</summary>

排查步骤：
```sql
-- 1. 查看最近死锁
SHOW ENGINE INNODB STATUS\G
-- 查找 LATEST DETECTED DEADLOCK 部分

-- 2. 分析持有锁和等待锁
-- 死锁日志会显示：
-- Transaction 1: 持有锁A，等待锁B
-- Transaction 2: 持有锁B，等待锁A

-- 3. 查看慢查询日志
-- 死锁往往伴随慢查询

-- 4. 使用pt-deadlock-logger持续监控
```

解决方案：
1. 统一加锁顺序（按主键ID升序）
2. 缩小事务范围（减少持锁时间）
3. 降低隔离级别（RC无Gap Lock）
4. 添加适当索引（避免锁升级）
5. 业务层重试机制
</details>

**题目3: 生产环境发现大量锁等待，如何快速定位？**
<details>
<summary>点击查看答案</summary>

```sql
-- Step 1: 查看锁等待链
SELECT 
    r.trx_id AS waiting_trx,
    r.trx_mysql_thread_id AS waiting_thread,
    r.trx_query AS waiting_query,
    b.trx_id AS blocking_trx,
    b.trx_mysql_thread_id AS blocking_thread,
    b.trx_query AS blocking_query,
    TIMESTAMPDIFF(SECOND, r.trx_wait_started, NOW()) AS wait_seconds
FROM information_schema.innodb_lock_waits w
JOIN information_schema.innodb_trx r ON w.requesting_trx_id = r.trx_id
JOIN information_schema.innodb_trx b ON w.blocking_trx_id = b.trx_id
ORDER BY wait_seconds DESC;

-- Step 2: 查看长事务
SELECT 
    trx_id,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration_sec,
    trx_query,
    trx_rows_locked,
    trx_rows_modified
FROM information_schema.innodb_trx
WHERE TIMESTAMPDIFF(SECOND, trx_started, NOW()) > 10
ORDER BY trx_started;

-- Step 3: 定位具体锁信息
SELECT 
    OBJECT_NAME,
    INDEX_NAME,
    LOCK_TYPE,
    LOCK_MODE,
    LOCK_STATUS,
    LOCK_DATA
FROM performance_schema.data_locks
WHERE LOCK_STATUS = 'WAITING';

-- Step 4: 紧急处理（杀掉阻塞线程）
KILL <blocking_thread_id>;
```

预防措施：
1. 监控告警：锁等待超过5秒报警
2. 慢查询优化：避免长时间持锁
3. 代码审查：检查事务范围
4. 定期巡检：查找未提交事务
</details>

### 考核标准

**中级**（80分）
- 能区分行锁、表锁、间隙锁
- 能复现简单的死锁场景
- 知道如何查看锁等待

**高级**（95分）
- 理解Next-Key Lock的锁定范围
- 能分析死锁日志并给出优化方案
- 掌握RC和RR隔离级别的加锁差异

**专家级**（100分）
- 能根据执行计划预判加锁范围
- 理解插入意向锁与间隙锁的冲突
- 能设计无死锁风险的并发方案

---

## 第四阶段: 索引优化与查询调优（4-5周）

### 学习目标
- 精通B+树索引的数据结构
- 掌握覆盖索引、回表、ICP等优化技术
- 能够分析和优化复杂SQL

### 实验清单

| 实验编号 | 实验名称         | 核心知识点   | 难度 |
| -------- | ---------------- | ------------ | ---- |
| EXP-11   | 覆盖索引vs回表   | 性能对比     | ⭐⭐   |
| EXP-12   | 联合索引最左前缀 | 索引匹配规则 | ⭐⭐⭐  |
| EXP-13   | ICP性能提升      | 索引条件下推 | ⭐⭐⭐  |
| EXP-14   | 优化器Cost Model | 执行计划分析 | ⭐⭐⭐⭐ |
| EXP-15   | 慢查询优化       | 综合调优     | ⭐⭐⭐⭐ |

### 索引优化面试题库

**题目4: 如何判断一个SQL是否需要优化？**
<details>
<summary>点击查看答案</summary>

量化标准：
1. **执行时间**: 
   - 简单查询 > 10ms
   - 复杂查询 > 100ms
   - 统计查询 > 1s

2. **扫描行数 vs 返回行数**:
   ```sql
   EXPLAIN SELECT ...;
   -- rows: 10000（扫描）
   -- filtered: 10%（过滤）
   -- 实际返回: 1000行
   -- 比例: 10:1 → 需要优化
   ```

3. **EXPLAIN关键指标**:
   - type: ALL/index → 需要优化
   - Extra: Using filesort → 需要优化索引
   - Extra: Using temporary → 需要优化

4. **监控指标**:
   - 慢查询日志中出现
   - QPS突然下降
   - 锁等待增加

判断流程：
```sql
-- 1. 查看执行计划
EXPLAIN FORMAT=JSON <SQL>;

-- 2. 实际执行查看时间
SET profiling = 1;
<SQL>;
SHOW PROFILES;
SHOW PROFILE FOR QUERY N;

-- 3. 分析瓶颈
-- Sending data耗时高 → I/O瓶颈（回表）
-- Sorting result耗时高 → 排序瓶颈（filesort）
-- Creating tmp table耗时高 → 临时表瓶颈
```
</details>

**题目5: 联合索引(a,b,c)，哪些查询能用上索引？**
<details>
<summary>点击查看答案</summary>

| WHERE条件                 | 索引使用情况  | 说明               |
| ------------------------- | ------------- | ------------------ |
| a = 1                     | ✅ 使用(a)     | 最左前缀           |
| a = 1 AND b = 2           | ✅ 使用(a,b)   | 前缀匹配           |
| a = 1 AND b = 2 AND c = 3 | ✅ 使用(a,b,c) | 完全匹配           |
| a = 1 AND c = 3           | ✅ 使用(a)     | b缺失，c无法使用   |
| b = 2                     | ❌ 不使用      | 缺少a              |
| b = 2 AND c = 3           | ❌ 不使用      | 缺少a              |
| a = 1 AND b > 2 AND c = 3 | ⚠️ 使用(a,b)   | b范围后c无法使用   |
| a IN (1,2) AND b = 2      | ✅ 使用(a,b)   | IN等价于多个OR     |
| a = 1 OR b = 2            | ❌ 不使用      | OR无法使用联合索引 |

验证：
```sql
EXPLAIN SELECT * FROM t 
WHERE a = 1 AND b > 2 AND c = 3;

-- 查看key_len判断使用了几列
-- INT: 4字节
-- key_len = 8 → 使用了(a,b)，c未使用
```
</details>

**题目6: 什么情况下索引会失效？**
<details>
<summary>点击查看答案</summary>

| 场景        | 示例                    | 原因             |
| ----------- | ----------------------- | ---------------- |
| 函数操作    | WHERE YEAR(date) = 2024 | 破坏索引顺序     |
| 类型转换    | WHERE varchar_col = 123 | 隐式转换         |
| 前导模糊    | WHERE name LIKE '%test' | 无法定位起点     |
| NOT、!=、<> | WHERE status != 1       | 范围过大         |
| IS NOT NULL | WHERE col IS NOT NULL   | 优化器选择       |
| OR条件      | WHERE a = 1 OR b = 2    | 无法使用联合索引 |
| 表达式      | WHERE id + 1 = 10       | 左侧表达式计算   |

**正确写法**：
```sql
-- ❌ 函数操作
WHERE YEAR(create_time) = 2024

-- ✅ 改写为范围
WHERE create_time >= '2024-01-01' 
  AND create_time < '2025-01-01'

-- ❌ 隐式转换
WHERE account_no = 123

-- ✅ 显式转换
WHERE account_no = '123'

-- ❌ 前导模糊
WHERE name LIKE '%test%'

-- ✅ 后缀模糊
WHERE name LIKE 'test%'
```
</details>

### 考核标准

**中级**（80分）
- 理解B+树索引的原理
- 能看懂EXPLAIN输出
- 知道覆盖索引和回表的区别

**高级**（95分）
- 能设计高效的联合索引
- 理解ICP、MRR等优化特性
- 能分析优化器的Cost Model

**专家级**（100分）
- 能根据业务设计索引策略
- 理解统计信息对优化器的影响
- 能手工干预优化器选择（Hint）

---

## 第五阶段: 高并发场景实战（3-4周）

### 学习目标
- 掌握秒杀、转账等典型场景的方案
- 理解分布式事务的实现
- 具备生产环境问题排查能力

### 综合案例

| 案例编号 | 案例名称     | 技术要点            | 业务价值   |
| -------- | ------------ | ------------------- | ---------- |
| CASE-01  | 秒杀库存扣减 | 悲观锁/乐观锁/Redis | 高并发写   |
| CASE-02  | 账户转账     | 事务/死锁预防       | 数据一致性 |
| CASE-03  | 订单分页查询 | 深度分页优化        | 查询性能   |
| CASE-04  | 实时报表     | 汇总表/触发器       | 聚合性能   |
| CASE-05  | 数据归档     | 分区表/定时任务     | 容量管理   |

### 生产问题排查

**问题1: 突然出现大量慢查询，如何快速定位？**
<details>
<summary>点击查看答案</summary>

排查流程：
```sql
-- 1. 查看当前活跃事务
SELECT 
    trx_id,
    trx_state,
    trx_started,
    TIMESTAMPDIFF(SECOND, trx_started, NOW()) AS duration,
    trx_query
FROM information_schema.innodb_trx
ORDER BY trx_started;

-- 2. 查看慢查询
SELECT 
    DIGEST_TEXT,
    COUNT_STAR,
    AVG_TIMER_WAIT/1000000000000 AS avg_sec,
    MAX_TIMER_WAIT/1000000000000 AS max_sec
FROM performance_schema.events_statements_summary_by_digest
WHERE SCHEMA_NAME = DATABASE()
  AND AVG_TIMER_WAIT > 1000000000000
ORDER BY AVG_TIMER_WAIT DESC
LIMIT 10;

-- 3. 查看锁等待
SELECT COUNT(*) FROM information_schema.innodb_trx
WHERE trx_state = 'LOCK WAIT';

-- 4. 查看系统负载
SHOW GLOBAL STATUS LIKE 'Threads_running';
SHOW GLOBAL STATUS LIKE 'Innodb_row_lock_waits';
```

常见原因：
1. 长事务未提交 → KILL掉
2. 索引失效 → 重建索引/ANALYZE TABLE
3. 锁冲突激增 → 优化事务逻辑
4. Buffer Pool不足 → 扩容
5. 磁盘I/O瓶颈 → 硬件升级
</details>

**问题2: 如何设计一个能抗10万QPS的系统？**
<details>
<summary>点击查看答案</summary>

架构设计：
```
+--------+     +-------+     +----------+     +----------+
| 客户端 | --> | Nginx | --> | 应用集群 | --> | 读写分离 |
+--------+     +-------+     +----------+     +----------+
                                   |               |
                                   v               v
                               +-------+       +--------+
                               | Redis |       | MySQL  |
                               | 缓存  |       | 主从   |
                               +-------+       +--------+
                                                    |
                                                    v
                                                +--------+
                                                | 分库   |
                                                | 分表   |
                                                +--------+
```

MySQL层优化：
1. **读写分离**:
   - 主库：写操作
   - 从库：读操作（多个从库负载均衡）
   - 读QPS: 8万/从库

2. **分库分表**:
   - 水平分库：按用户ID % 8
   - 每库QPS: 1.25万
   - 单表控制在2000万行

3. **缓存策略**:
   - 热数据100% Redis
   - 减少MySQL压力到1万QPS

4. **连接池**:
   ```sql
   max_connections = 2000
   应用连接池 = 100（单实例）
   应用实例数 = 20
   ```

5. **SQL优化**:
   - 所有查询<10ms
   - 强制走索引
   - 禁止大事务

6. **硬件**:
   - SSD磁盘
   - 内存 ≥ 数据量 * 2
   - 万兆网卡
</details>

### 考核标准

**高级**（95分）
- 能独立设计秒杀方案
- 理解分布式事务的权衡
- 能优化复杂业务查询

**专家级**（100分）
- 能设计高可用架构
- 理解容量规划和性能调优
- 具备生产问题快速定位能力

---

## 学习资源推荐

### 书籍
1. 《MySQL技术内幕：InnoDB存储引擎》（必读）
2. 《高性能MySQL》第4版（必读）
3. 《MySQL排错指南》（实战）

### 官方文档
- [MySQL 8.0 Reference Manual](https://dev.mysql.com/doc/refman/8.0/en/)
- [InnoDB Architecture](https://dev.mysql.com/doc/refman/8.0/en/innodb-architecture.html)

### 工具
- MySQL Workbench（可视化）
- pt-query-digest（慢查询分析）
- mysqldumpslow（慢查询统计）
- mysqlslap（压力测试）

---

## 终极考核：综合大作业

### 题目：设计一个电商交易系统的MySQL方案

**业务需求**：
1. 用户下单（扣减库存、创建订单、扣减余额）
2. 订单查询（支持多维度筛选、分页）
3. 实时库存展示
4. 日订单量500万，峰值QPS 5万

**要求**：
1. 设计表结构（包括索引）
2. 设计事务方案（保证一致性）
3. 设计查询优化方案
4. 设计监控告警方案
5. 编写核心SQL和存储过程
6. 进行压力测试并给出性能报告

**评分标准**：
- 表设计合理性（20分）
- 事务一致性保证（25分）
- 索引和查询优化（25分）
- 并发性能（20分）
- 监控和运维（10分）

---

## 学习时间安排

| 阶段     | 周数  | 每日时间 | 里程碑         |
| -------- | ----- | -------- | -------------- |
| 基础理论 | 1-2周 | 2小时    | 通过理论测试   |
| 事务MVCC | 2-3周 | 3小时    | 完成5个实验    |
| 锁机制   | 3-4周 | 3小时    | 完成5个实验    |
| 索引优化 | 4-5周 | 4小时    | 完成5个实验    |
| 综合实战 | 3-4周 | 4小时    | 完成综合大作业 |

**总计：13-18周，达到专家级水平**

祝你学习顺利，成为MySQL专家！🚀