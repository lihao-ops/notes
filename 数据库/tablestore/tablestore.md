TableStore
===



一、是什么？
---



### 1.前言

表格存储（Tablestore）**面向海量结构化数据提供Serverless表存储服务**，同时针对物联网场景深度优化提供一站式的IoTstore解决方案。适用于**海量账单、IM消息、物联网、车联网、风控、推荐等场景中的结构化数据存储**，提供**海量数据低成本存储、毫秒级的在线数据查询和检索**以及**灵活的数据分析能力**。

表格存储是一款用于存储`海量非关系型（NoSQL）结构化数据`的`云原生`、`免运维`、`无限容量`表存储服务，提供` Schemaless 表结构`设计、`多元化索引`以及`数据更新实时订阅通道`，支撑 `PB 级数据存储`的同时能提供丰富且灵活的数据查询、检索和分析能力。对接了各大主流开源计算引擎，能灵活的实现`流批一体分析`。



> 海量非关系型(NoSQL)结构化数据

通常指的是大量的非关系型数据库中存储的结构化数据。NoSQL数据库是一类用于大规模数据存储的数据库管理系统，它们**不遵循传统的关系型数据库管理系统（RDBMS）的结构和约束**。NoSQL数据库通常用于**处理大量数据和需要高度可扩展性的应用程序**。

这些非关系型数据库可以处理各种类型的结构化数据，包括但不限于以下几种类型：

1. **键值存储（Key-Value Stores）：** 这种类型的数据库以键值对的形式存储数据，每个键都是唯一的，可以用来检索对应的值。

2. **文档数据库（Document Stores）：** 这种类型的数据库以类似于 JSON 或 XML 的文档格式存储数据，文档可以包含复杂的嵌套结构。

3. **列族存储（Column Family Stores）：** 这种类型的数据库按列族存储数据，类似于表格，其中每个列族包含多行数据，每行数据包含不同的列。

4. **图形数据库（Graph Databases）：** 这种类型的数据库专门用于处理图形数据，适合存储和处理图形结构、网络和复杂的关系数据。

5. **对象数据库（Object Databases）：** 这种类型的数据库以对象的形式存储数据，适合存储面向对象编程中的数据结构。

处理海量非关系型结构化数据：

通常需要**选择适当的NoSQL数据库类型**，并**根据数据的特点和应用场景来设计数据库架构**。这样可以**确保数据存储和检索的效率，并且满足应用程序对于可扩展性和性能的需求**。



> 关系型数据库管理系统(RDBMS)

是一类基于关系模型的数据库管理系统，它以表的形式组织数据，并使用事先定义的模式来描述数据的结构和关系。RDBMS 遵循一系列结构和约束，这些结构和约束确保了数据的一致性、完整性和安全性。以下是关系型数据库管理系统的常见结构和约束：

1. **表（Table）：** 表是 RDBMS 中最基本的数据组织形式，它**由行和列组成。每一行表示一个记录，而每一列代表一个字段或属性**。表具有固定的模式，定义了每个字段的数据类型以及约束条件。

2. **键（Key）：** 在关系数据库中，**键是用来唯一标识每一条记录的字段或字段组合**。主键（Primary Key）是一种特殊的键，用来唯一标识每一条记录，而外键（Foreign Key）用来建立表之间的关联。

3. **约束（Constraint）：** 约束是**应用于表中数据的规则，用来保证数据的完整性和一致性**。常见的约束包括主键约束、外键约束、唯一约束、默认值约束、检查约束等。

4. **关系（Relationships）：** 关系是**表与表之间的连接，它们定义了数据之间的关联和依赖关系**。通过关系，可以进行表之间的连接查询，从而获取多个表中相关联数据的结果。

5. **ACID 属性：** ACID 是指**原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性**（Durability）。这些属性**保证了数据库事务的可靠性和稳定性**，确保了在并发环境下数据的正确性和安全性。

**遵循这些结构和约束，RDBMS 可以有效地管理和组织数据，并提供可靠的数据存储和处理机制**。它们被广泛应用于各种类型的企业应用程序和数据驱动型应用程序。







### 2.概念



#### (1)基本概念

- **地域(Region)**：是指**阿里云物理数据中心所在的位置**。表格存储部署在多个地域中，您可以根据自身的业务需求创建不同地域中的表格存储实例。

- **读写吞吐量**：读/写吞吐量的单位为`读服务能力单元`和`写服务能力单元`，简称CU（Capacity Unit），是数据读写操作的`最小计费单位`。当通过表格存储的API对数据表进行读写操作时，会消耗对应的写服务能力单元和读服务能力单元。

  - CU**计算规则**

    - 1单位读服务能力单元表示从数据表中读一条4 KB数据。
    - 1单位写服务能力单元表示向数据表写一条4 KB数据。
    - **操作数据大小不足4 KB的部分向上取整**，例如写入7.6 KB数据消耗2单位写服务能力单元，读出0.1 KB数据消耗1单位读服务能力单元。

  - **按量读/写吞吐**

    - 按量读/写吞吐量是数据表在每秒实际消耗的读/写吞吐量中超出预留读/写吞吐量的部分，统计周期为1秒。每个小时内，表格存储对预留读/写吞吐量取平均值，对按量读/写吞吐量取累加值来作为用户实际消耗的吞吐量。

      **由于按量读/写吞吐量的模式无法预估需要为数据表预留的计算资源，表格存储需要提供足够的服务能力以应对突发的访问高峰，所以按量读/写吞吐量的单价高于预留读/写吞吐量的单价。**合理设置数据表的预留读/写吞吐量能够有效地降低使用成本。

      **重要**

      由于按量读/写吞吐量无法准确估计需要预留的资源，在某些极端访问情况下，**==如果单个分区键每秒的访问需要消耗10000 CU，表格存储可能会返回OTSCapacityUnitExhausted错误==**。此时需要**使用退避重试等策略来减少访问该数据表的频率**。

    - 预留读/写吞吐量

      - **使用多元索引时，表格存储会根据索引数据规模自动设置一个预留读吞吐量**。更多信息，请参见[多元索引计量计费](https://help.aliyun.com/zh/tablestore/product-overview/billable-items-of-search-indexes-1#concept-287174)。多元索引中的预留读吞吐量配置不支持调整，如果期望减少该部分开销，只能通过优化索引大小或行数来解决。

      预留读/写吞吐量是高性能实例中数据表的一个属性。在创建数据表时，可以为数据表指定预留读/写吞吐量。

      - **当设置的预留读/写吞吐量大于0时，表格存储会为数据表分配和预留相应的资源，每秒对数据表的访问不超过预留读/写吞吐量时将按照预留读/写吞吐量的单价计费**。

      - 当设置的预留读/写吞吐量等于0时，表格存储不会为数据表分配和预留相应的资源。

        **说明**

        不存在的数据表将视作预留读/写吞吐量均为0，访问不存在的数据表将根据操作类型消耗1个按量读CU或者1个按量写CU。

      由于预留读/写吞吐量在单价上低于按量读/写吞吐量，配置合适的预留读/写吞吐量可以进一步降低成本。例如数据表创建后如果需要导入大量数据，可以设置较大的预留写吞吐量，能够以较低的写成本导入数据，当数据导入完成后，再将预留读/写吞吐量下调。

  - 计算示例

    假如数据表设置的预留读吞吐量为100 CU，连续3秒的访问情况如下：

    - T0：读操作实际消耗120 CU读吞吐量，则这1秒内预留吞吐量为100 CU，消耗的按量读吞吐量为20 CU。
    - T1：读操作实际消耗95 CU读吞吐量，则这1秒内预留吞吐量为100 CU，消耗的按量读吞吐量为0 CU。
    - T2：读操作实际消耗110 CU读吞吐量，则这1秒内预留吞吐量为100 CU，消耗的按量读吞吐量为10 CU。

    T0到T2时刻消耗的读吞吐量为：100 CU预留读吞吐量以及30 CU按量读吞吐量。
  
- **实例**

  - 实例(Instance)是**使用和管理表格存储服务的实体**，==**每个实例相当于一个数据库**==。表格存储对应**应用程序的访问控制和资源计算**都在实例级别完成。

- **服务地址**

  - **每个实例对应一个服务地址(EndPoint)**,应用程序在进行表和数据操作时需要**指定服务地址**。

- **数据生命周期**

  - **数据生命周期（Time To Live，简称TTL）是数据表的一个属性**，即**数据的存活时间**，单位为秒。表格存储**会在后台对超过存活时间的数据进行清理，以减少您的数据存储空间，降低存储成本**。





##### 扩展



###### 单表PB级别：

参考文档：https://www.dbs724.com/377102.html

什么是PB级别的数据库技术：

PB级别的数据库技术是指可以**管理大量数据（以PB为单位）的数据管理系统**。PB级别的数据库技术的原理是**分治技术**，即**将大量的数据分割为多个分区，然后将分区分散存储在不同的服务器上**，以提高数据处理速度和可靠性。此外，PB级别的数据库技术还**支持水平和垂直扩展**，可以**根据数据规模和业务需求进行弹性扩展和缩小**。

PB级别的数据库技术是一种**基于分布式数据库管理系统的技术**，它具有以下几个基本特点：

1、**数据分布**：PB级别的数据库技术通过数据分散存储在多个节点上，以提高处理速度和可靠性。数据分布需要考虑数据冗余度和数据一致性等问题。

2、**数据管理**：PB级别的数据库技术可以实现多节点数据管理，将数据分配给指定的节点进行管理，并通过分区技术进行分配和管理。

3、**数据处理**：PB级别的数据库技术支持分布式数据处理，可以将大任务分为多个小任务分别处理，以实现并行处理，并减少处理时间。

4、**数据查询**：PB级别的数据库技术支持分布式数据查询，可以在多个节点上进行查询操作。查询操作需要考虑数据一致性和负载均衡等问题。





假设共两台河西主站数据库实例1(简称n1)，外高桥数据库实例1(简称h1)。

数据一致性问题：

> 方案一：PB级别数据库设计理念中比较核心概念是分而治之，故此这里也可参照类似思想：

以主键id为核心区分每行数据，取表中最大id(maxId)

if(maxId % 2 == 0){

​		存储河西

}else{

​		存储外高桥	

}





#### (2).数据模型

参考文档地址：

- https://developer.aliyun.com/article/620989
- https://help.aliyun.com/zh/tablestore/product-overview/what-is-tablestore





表格存储提供了`宽表（WideColumn）模型`、`时序（TimeSeries）模型`和`消息（Timeline）模型`三种数据存储模型，请根据使用场景选择合适的模型。不同数据存储模型支持的功能特性请参见[功能特性](https://help.aliyun.com/zh/tablestore/product-overview/features-of-tablestore#concept-2210962)。

| **模型** | **描述**                                                     |
| -------- | ------------------------------------------------------------ |
| 宽表模型 | 类Bigtable/HBase模型，可应用于元数据、大数据等多种场景，支持数据版本、生命周期、主键列自增、条件更新、局部事务、原子计数器、过滤器等功能。更多信息，请参见[宽表模型](https://help.aliyun.com/zh/tablestore/overview-of-widecolumn#concept-89879-zh)。 |
| 时序模型 | 针对时间序列数据的特点进行设计的模型，可应用于物联网设备监控、设备采集数据、机器监控数据等场景，支持自动构建时序元数据索引、丰富的时序查询能力等功能。更多信息，请参见[时序模型](https://help.aliyun.com/zh/tablestore/user-guide/overview-8#concept-2123024)。 |
| 消息模型 | 针对消息数据场景设计的模型，可应用于IM、Feed流等消息场景。能满足消息场景对消息保序、海量消息存储、实时同步的需求，同时支持全文检索与多维度组合查询。更多信息，请参见[消息模型](https://help.aliyun.com/zh/tablestore/overview-22#concept-89885-zh)。 |





TableStore是阿里云自研首款**分布式多模型数据库**，属于**NoSQL**的类别。提到NoSQL数据库，现在对很多应用研发来说都已经不再陌生。当前很多应用系统底层不会再仅仅依赖于关系型数据库，而是**会根据不同的业务场景，来选型使用不同类型的数据库，例如缓存型KeyValue数据会存储在Redis，文档型数据会存储在MongoDB，图数据会存储在Neo4J等**。

![d7f428846f277b2ad9550b7ffdafeee39c14ce63](https://yqfile.alicdn.com/d7f428846f277b2ad9550b7ffdafeee39c14ce63.png)

 总结下，NoSQL的发展是基于互联网时代对业务的新挑战以及数据库的新需求而推动的，基于此发展起来的NoSQL，有其显著的特征：

- **多数据模型**：为满足不同数据的需求，诞生出了很多不同的数据模型，例如KeyValue、Document、Wide Column、Graph以及Time Series等。这是NoSQL数据库发展的一个最显著特征，打破了关系模型的约束，选择一个多元的发展方向。数据模型的选择是更加场景化的，更贴近业务的实际需求，能够做更深层次的优化。
- **高并发、低延迟**：NoSQL数据库的发展更多由在线业务的需求推动，其设计目标更多的是面向在线业务提供高并发、低延迟的访问。
- **高可扩展**：为应对爆发的数据量增长，可扩展是最核心的设计目标之一，所以底层架构往往在设计之初即考虑分布式架构。



表格存储提供了`宽表（WideColumn）模型`、`时序（TimeSeries）模型`和`消息（Timeline）模型`三种数据存储模型，请根据使用场景选择合适的模型。不同数据存储模型支持的功能特性请参见[功能特性](https://help.aliyun.com/zh/tablestore/product-overview/features-of-tablestore#concept-2210962)。



##### (1)WideColumn(宽表模型)

宽表模型是一种数据存储结构，**它通过将大量的数据存储在单个数据表中，支持存储极大容量的数据，并且能够高效地处理大量的查询请求**。

想象一下你有一个非常大的数据集，以 PB（Petabytes，百万亿字节）为单位来计量。传统的数据库表结构可能会分成多个表来存储这么大的数据，每个表存储特定类型或特定时间范围的数据。但在宽表模型中，所有相关的数据都存储在一个表中，这个表可能会有非常多的列，每一列可能代表不同的数据属性或维度。

例如，如果你正在构建一个电商平台，你可能有一个宽表，其中每一行代表一个订单，而每一列则代表订单的不同属性，比如订单号、订单日期、购买的商品、商品数量、购买者信息等等。这个表可能会有数千万甚至数亿的行，但由于所有相关的数据都存储在同一个表中，所以可以轻松地进行复杂的数据查询和分析。

宽表模型的另一个特点是高并发处理能力。由于所有的数据都在同一个表中，数据库系统可以针对这个表进行优化，使得它能够快速地处理大量的查询请求，即使每秒查询请求的数量达到了上千万次（QPS，Queries Per Second）也能够轻松应对。

总之，宽表模型通过将大量的数据存储在单个数据表中，既能够支持 PB 级别的数据存储，又能够支持千万级别的查询请求，是处理大数据量和高并发的有效解决方案。



`WideColumn模型`是由Bigtable提出，后被其他同类型系统广泛应用的一种经典模型，目前世界上的`绝大部分半结构化、结构化数据`都是存储在该模型系统中。

![e62e310507aa9c98d719f632dddad1fe2128b7ad](https://yqfile.alicdn.com/e62e310507aa9c98d719f632dddad1fe2128b7ad.png)

上图是Wide Column模型的一个模型图，为更好的理解这个模型，我们拿关系模型来做一个对比。

**关系模型可以简单的理解为一个二维的模型，由行列组成，每一行的列固定Schema**。

所以**==关系模型的特征是：二维以及固定Schema，这是一个最简单的理解，抛开事务和约束来看的话==**。

**Wide Column模型是一个三维的模型，==在行与列二维的基础上，增加了一个时间维度==**。时间维度体现**在属性列上，属性列可以拥有多个值，每个值对应一个Timestamp作为版本**。并且每一行是Schema Free的，没有强Schema定义。所以Wide Column模型对比关系模型，简单总结就是：三维、Schema Free、简化事务和约束。







![img](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202311021917498.png)

再详细看下这个模型的组成，有几个主要部分：

- **主键（Primary Key）**：每**一行都会有主键，主键会由多列（1-4列）构成**，主键的定义是固定Schema，**主键的作用主要是唯一区分一行数据**。
- **分区键（Partition Key）**：**主键的第一列称为分区键，分区键用于对表进行范围分区**，每个分区会分布式的调度到不同的机器上进行服务。在同一个分区键内，我们提供跨行事务。
- **属性列（Attribute Column）**：**==一行中除开主键列外，其余都是属性列==。属性列会对应多个值，不同值对应不同的版本**，**一行可存储不限个数个属性列**。
- **版本（Version）**：每一个值对应不同的版本，**版本的值是一个时间戳，用于定义数据的生命周期**。
- **数据类型（Data Type）**：TableStore支持多种数据类型，包含**String、Binary、Double、Integer和Boolean**。
- **生命周期（Time To Live）**：**每个表可定义数据生命周期**，例如生命周期配置为一个月，则该表数据中在一个月之前写入的数据就会被自动清理。数据的写入时间由版本来决定，版本一般由服务端在数据写入时根据服务器时间来定，也可由应用自己指定。
- **最大版本数（MaxVersion）**：每个表可定义每一列最多保存的版本数，用于控制一列的版本的个数，老版本的超过个数上限的数据会被自动清理。



Wide Column模型的特色，总结来说就是：

- **三维结构（行、列和时间）、**

- **宽行、**

- **多版本数据**

- **以及生命周期管理。**

  同时Wide Column模型在数据操作层面，提供两类数据访问API，**Data API和Stream API**。

###### 功能特性

> 宽表模型支持的功能特性请参见下表。

| **功能特性** | **描述** | **相关文档** |
| ------------ | -------- | ------------ |
|              |          |              |

| **功能特性**           | **描述**                                                     | **相关文档**                                                 |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **表操作**             | 支持列出实例中的全部数据表、创建一张数据表、查询数据表的配置信息、更新数据表的配置信息以及删除一张数据表。 | [表操作](https://help.aliyun.com/zh/tablestore/table-operations#concept-2211386) |
| **基础数据操作**       | 表格存储提供了`PutRow`、`GetRow`、`UpdateRow`和`DeleteRow`的单行数据操作接口以及`BatchWriteRow`、`BatchGetRow`和`GetRange`的多行数据操作接口。您可以**通过单行数据操作接口或者多行数据操作接口读写表中数据**。 | [写入数据](https://help.aliyun.com/zh/tablestore/write-data-by-using-console-cli-or-sdk#concept-1963020)[读取数据](https://help.aliyun.com/zh/tablestore/read-data#concept-1961904)[删除数据](https://help.aliyun.com/zh/tablestore/delete-data-by-using-console-cli-or-sdk#concept-2250864) |
| **数据版本和生命周期** | 使用数据版本以及数据生命周期（TTL）功能，您可以有效的管理数据，减少数据存储空间，降低存储成本。 | [数据版本和生命周期](https://help.aliyun.com/zh/tablestore/data-versions-and-ttl#concept-z5t-jmj-bfb) |
| **主键列自增**         | 设置非分区键的主键列为自增列后，在写入数据时，无需为自增列设置具体值，表格存储会自动生成自增列的值。该值在分区键级别唯一且严格递增。 | [主键列自增](https://help.aliyun.com/zh/tablestore/configure-an-auto-increment-primary-key-column-1#concept-47745-zh) |
| **条件更新**           | 只有满足条件时，才能对数据表中的数据进行更新；当不满足条件时，更新失败。 | [条件更新](https://help.aliyun.com/zh/tablestore/conditional-update-by-using-cli-or-sdk#concept-35194-zh) |
| **局部事务**           | 创建数据范围在一个分区键值内的局部事务。**对局部事务中的数据进行读写操作后，可以根据实际提交或者丢弃局部事务**。 | [局部事务](https://help.aliyun.com/zh/tablestore/local-transactions#concept-xbh-jd3-mfb) |
| **原子计数器**         | ==将列当成一个原子计数器使用==，对该列进行原子计数操作，可用于为某些在线应用提供实时统计功能，例如统计帖子的PV（实时浏览量）等。 | [原子计数器](https://help.aliyun.com/zh/tablestore/atomic-counters#concept-d45-tlc-dfb) |
| **过滤器**             | **==在服务端对读取的结果再进行一次过滤==，根据过滤器中的条件决定返回哪些行。由于只返回符合条件的数据行**，所以在大部分场景下，可以**有效降低网络传输的数据量**，减少响应时间。 | [过滤器](https://help.aliyun.com/zh/tablestore/configure-a-filter-4#concept-35193-zh) |
| **二级索引**           | 通过创建一张或多张索引表，使用索引表的主键列查询，相当于把数据表的主键查询能力扩展到了不同的列。二级索引包括全局二级索引和本地二级索引。全局二级索引：以异步方式将数据表中被索引的列和主键列的数据自动同步到索引表中，正常情况下同步延迟达到毫秒级别。本地二级索引：以同步方式将数据表中被索引的列和主键列的数据自动同步到索引表中，当数据写入数据表后，即可从索引表中查询到数据。 | [二级索引](https://help.aliyun.com/zh/tablestore/overview-16#concept-ogb-g2b-ffb)[全局二级索引](https://help.aliyun.com/zh/tablestore/global-secondary-index-2#concept-r1l-4db-ffb)[本地二级索引](https://help.aliyun.com/zh/tablestore/local-secondary-index-4#concept-2066928) |
| **多元索引**           | 多元索引基于倒排索引和列式存储，可以解决大数据的复杂查询难题，包括非主键列查询、全文检索、前缀查询、模糊查询、多条件组合查询、嵌套查询、地理位置查询、统计聚合（max、min、count、sum、avg、distinct_count、group_by）、并发导出数据等功能。 | [多元索引](https://help.aliyun.com/zh/tablestore/overview-17#concept-gmr-nyf-ffb)[使用控制台](https://help.aliyun.com/zh/tablestore/use-the-tablestore-console-2#concept-977387)[使用命令行工具](https://help.aliyun.com/zh/tablestore/use-the-tablestore-cli-10#concept-2149550)[使用SDK](https://help.aliyun.com/zh/tablestore/use-tablestore-sdks-1#concept-2149552) |
| **SQL查询**            | SQL查询功能为多数据引擎提供统一的访问接口。通过SQL查询功能，您可以对表格存储中数据进行复杂的查询和高效的分析。使用SQL查询数据时，您还可以配合索引来优化查询。 | [SQL查询](https://help.aliyun.com/zh/tablestore/user-guide/overview-32#concept-2098344)[使用控制台](https://help.aliyun.com/zh/tablestore/use-the-tablestore-console-1#concept-2098345)[使用SDK](https://help.aliyun.com/zh/tablestore/use-tablestore-sdks-2#concept-2136301)使用JDBC[JDBC连接表格存储](https://help.aliyun.com/zh/tablestore/user-guide/use-jdbc-to-access-tablestore#concept-2138968)[通过Hibernate使用](https://help.aliyun.com/zh/tablestore/user-guide/use-hibernate-to-use-the-jdbc-driver-for-tablestore#concept-2174752)[通过MyBatis使用](https://help.aliyun.com/zh/tablestore/user-guide/use-mybatis-to-use-the-jdbc-driver-for-tablestore#concept-2174754)[使用Go语言驱动](https://help.aliyun.com/zh/tablestore/user-guide/use-the-tablestore-driver-for-go-to-access-tablestore#concept-2206443) |
| 通道服务               | 表格存储提供了增量、全量、增量加全量三种类型的分布式数据实时消费通道，可以实现对表中历史存量和新增数据的消费处理。 | [通道服务](https://help.aliyun.com/zh/tablestore/user-guide/overview-12#concept-gmh-hs3-kgb)[快速入门](https://help.aliyun.com/zh/tablestore/user-guide/quick-start-3#concept-mnl-5s3-kgb)[使用SDK](https://help.aliyun.com/zh/tablestore/sdk-usage#concept-u3m-st3-kgb) |
| 数据安全               | 表格存储默认允许任意网络的访问，您可以通过为实例绑定VPC并更改实例网络类型实现在专有网络中使用表格存储资源，保证网络访问安全。为了保证表数据安全，表格存储提供了数据落盘加密功能。您可以在创建数据表时配置数据表加密。 | [网络安全管理](https://help.aliyun.com/zh/tablestore/user-guide/network-security-management#task-2286399)[数据加密](https://help.aliyun.com/zh/tablestore/data-encryption) |
| 数据湖投递             | 表格存储数据湖投递可以全量备份或实时投递数据到数据湖OSS中存储，以满足更低成本的历史数据存储，以及更大规模的离线和准实时数据分析需求。 | [数据湖投递](https://help.aliyun.com/zh/tablestore/overview-10#topic-1955234)[快速入门](https://help.aliyun.com/zh/tablestore/quick-start-2#topic-1955236)[使用SDK](https://help.aliyun.com/zh/tablestore/use-sdks#topic-1995240) |
| 数据可视化             | 支持对接数据可视化工具DataV或者Grafana。通过对接数据可视化工具可以实现可视化展示表格存储中的数据。 | [对接Grafana](https://help.aliyun.com/zh/tablestore/connect-tablestore-to-grafana#task-2209122)[对接DataV](https://help.aliyun.com/zh/tablestore/user-guide/connect-tablestore-to-datav#task-2209119) |
| 监控与报警             | 通过查看表格存储资源的监控信息，您可以了解资源的使用情况。通过为资源的重要监控指标设置报警规则，您还可以及时得知指标异常并快速处理异常。 | [通过表格存储控制台查看监控数据](https://help.aliyun.com/zh/tablestore/view-monitoring-data-in-the-tablestore-console#concept-2207400)[配置监控指标报警](https://help.aliyun.com/zh/tablestore/configure-alert-rules-for-metrics#concept-2207993) |
| 备份与恢复             | 通过混合云备份HBR（Hybrid Backup Recovery）定期备份表格存储实例中的数据，并在数据丢失或受损时及时恢复。HBR支持全量与增量数据备份，同时支持数据冗余机制，可以提高存储库的数据可靠性。 | [备份Tablestore数据](https://help.aliyun.com/zh/tablestore/back-up-tablestore-data#task-2157002)[恢复Tablestore数据](https://help.aliyun.com/zh/tablestore/restore-tablestore-data#task-2157009) |
| HBase支持              | 开源HBase API的Java应用可以通过Tablestore HBase Client直接访问表格存储服务。 | [HBase支持](https://help.aliyun.com/zh/tablestore/tablestore-hbase-client#concept-50125-zh)[快速入门](https://help.aliyun.com/zh/tablestore/quick-start-5#concept-50163-zh) |



###### 版本号

为数据表配置最大版本数后，当您**每次更新属性列的值时，表格存储均会为该值生成一个新版本**，版本的**值即为版本号（时间戳）**，单位为毫秒。

在属性列中写入数据时，**如果未设置版本号，则系统会自动生成数据的版本号**，您也可以自定义数据的版本号。 由于版本号的单位为毫秒，在进行TTL比较和有效版本偏差计算时，需要**除以1000换算成秒**。

- 当由系统自动生成数据的版本号时，**系统默认将当前时间的毫秒单位时间戳**（从`1970-01-01 00:00:00 UTC`计算起的毫秒数）**作为属性列值的版本号**。
- 当自定义数据的版本号时，属性列值的版本号需要为64位的毫秒单位时间戳且在有效版本范围内。

使用版本号，您可以实现以下功能：

- 数据生命周期（TTL）

  **版本号可以用于定义数据表中属性列值的生命周期**。**当属性列中数据的保留时长超过设置的TTL后，系统会自动异步清理对应版本号的数据**。

  例如数据的版本号为1468944000000（即`2016-07-20 00:00:00 UTC+8`），如果设置数据表的TTL为86400（一天），则该版本号的数据会在`2016-07-21 00:00:00 UTC+8`过期，系统会自动异步删除该版本号的数据。

- 每行数据的版本读取

  读取行数据时，您可以指定**每列最多读取的版本个数或者读取的版本号范围**。更多信息，请参见[读取数据](https://help.aliyun.com/zh/tablestore/read-data)。



> 最大版本数

**最大版本数（Max Versions）表示数据表中的属性列能够保留数据的最大版本个数**。当属性列中数据的版本个数超过设置的最大版本数时，系统会自动异步删除较早版本的数据。

**重要**

当前表格存储未限制最大版本数。但是出于性能与易用性考虑，建议控制版本数在500以内。

创建数据表时，如果未设置最大版本数，则系统会使用默认值1，您也可以自定义属性列的最大版本数。创建数据表后，您可以通过[UpdateTable](https://help.aliyun.com/zh/tablestore/developer-reference/updatetable-3)接口修改数据表的最大版本数。

超过最大版本数的数据版本为无效数据，即使系统还未删除数据，用户已无法读取对应数据。

- 当调小最大版本数时，如果数据版本个数超过新设的最大版本数，系统会异步删除较早版本的数据。
- 当调大最大版本数时，如果系统还未删除超过旧的最大版本数的对应版本数据，且对应版本数据在新设的最大版本数范围中，则对应版本的数据可以重新读取。







###### 局部事务

**使用局部事务功能**，创建数据**范围在一个分区键值内**的局部事务。

对局部事务中的数据进行读写操作后，可以根据实际提交或者丢弃局部事务。

局部事务通过悲观锁(Pessimistic Lock)实现并发控制。



目前局部事务功能处于邀测中，默认关闭

>场景

- 读-写场景（简单场景）

  当需要进行**读取-修改-写回（Read-Modify-Write）**操作时，可以选择如下两种方式，但两种方式有一些限制。

  - 条件更新：只能处理单行单次请求，不能处理数据分布在多行，或者需要多次写入的情况。更多信息，请参见[条件更新](https://help.aliyun.com/zh/tablestore/conditional-update-by-using-cli-or-sdk#concept-35194-zh)。
  - 原子计数器：只能处理单行单次请求，且只能进行列值的累加操作。更多信息，请参见[原子计数器](https://help.aliyun.com/zh/tablestore/atomic-counters#concept-d45-tlc-dfb)。

  使用局部事务可以实现一个分区键值范围内的通用读取-修改-写回流程。

  1. 使用StartLocalTransaction为分区键值创建一个局部事务，并获取局部事务ID。
  2. 使用GetRow或GetRange接口获取数据，且请求中需要带上局部事务ID。
  3. 客户端本地修改数据。
  4. 使用PutRow、UpdateRow、DeleteRow或BatchWriteRow接口将修改后的数据写回，且请求中需要带上事务ID。
  5. 使用CommitTransaction提交局部事务。



> 限制

- 每个局部事务从创建开始生命周期最长为60秒。

  如果超过60秒未提交或丢弃局部事务，表格存储服务端会认为此局部事务超时，并将局部事务丢弃。

- 如果创建局部事务时超时，此请求可能在表格存储服务端已执行成功，此时用户需要等待该局部事务超时后重新创建。

- 未提交的局部事务可能失效，如果出现此情况，需要重试该局部事务内的操作。





###### 原子计数器

参考文档：https://help.aliyun.com/zh/tablestore/atomic-counters#concept-d45-tlc-dfb



**将列当成一个原子计数器使用，对该列进行原子计数操作**，可用于为某些**在线应用提供实时统计**功能：

原子计数器可以**解决由==强一致性导致的写入性能开销==的问题**。



> 一个RMW（Read-Modify-Write）操作

- 通过一次网络请求发送到服务器端，
- 服务器端使用内部行锁机制在本地完成`RMW(原子读取、修改和写入操作)`的操作。
- 通过原子计数器将分布式计算器的计算逻辑下推到服务器端，
- 在保证强一致性的情况下，提升原子计数器的写入性能。



> 扩展：

1.分布式计算器

分布式计算器**可以进行简单的数值计算，并支持远程拉起另一个计算器FA，实现两个FA进行协同计算**，界面主要由“键盘”、“显示”及“标题栏”三个模块组成。

其中，“键盘”、“显示”模块负责响应用户点击并控制运算表达式及运算结果的显示，实现了基础的计算功能。“菜单栏”模块为计算器顶部的菜单栏，是分布式计算功能的入口。分布式计算器各模块的功能实现，可以从组件化、声明式描述和状态管理三个维度来解析。



> 使用原子计数器对某一行中的数据做实时统计。

假设您需要使用表格存储来存储图片元信息并统计图片数信息，数据表内每一行对应某一个用户ID，行上的其中一列用于存储上传的图片，另一列用于实时统计上传的图片数。

- 使用UpdateRow接口增加一张新图片时，原子计数器+1。
- 使用UpdateRow接口删除一张旧图片时，原子计数器-1。
- 使用GetRow接口读取原子计数器的值，获取当前用户的图片数。

上述行为**具有强一致性**，即当增加一张新图片时，原子计数器会相应+1，而不会出现-1的情况。

**说明**

**原子计数操作可能会由于网络超时、系统错误等导致失败。此时只需重试操作即可**，但是可能会更新两次原子计数器，导致原子计数器偏多或偏少。针对此类异常场景，建议使用[条件更新](https://help.aliyun.com/zh/tablestore/conditional-update-by-using-cli-or-sdk#concept-35194-zh)精确变更列值。











###### 二级索引

二级索引包括：全局二级索引，本地二级索引



> 全局二级索引

以**异步方式**将数据表中**被索引的列和主键列的数据自动同步到索引表**中，正常情况下同步延迟达到ms。

索引表的**第一列主键可根据需要选择任意**主键列或者预定义列



>本地二级索引

以**同步方式**将数据表中**被索引的列和主键列的数据自动同步到索引表**中，当数据写入数据表后，即可从索引表中查询到数据。

索引表的**第一列主键必须和数据表的第一列主键相同**





> 基本概念

| 名词             | 描述                                                         |
| :--------------- | :----------------------------------------------------------- |
| 索引表           | 对数据表中某些列数据的索引。**索引表只能用于读取数据，不能写入数据**。 |
| 预定义列         | 在创建数据表时**预先定义一些非主键列以及其类型，作为索引表的索引列或者属性列**。**说明**表格存储为`Schema-free模型`，原则上**一行数据可以写入任意属性列**，无需在SCHEMA中指定属性列。 |
| **单列索引**     | 只为某一列建立索引。                                         |
| **组合索引**     | 多个列组合成索引，组合索引中包含组合索引列1、列2。           |
| **索引表属性列** | 被映射到索引表中的预定义列。                                 |
| **索引列补齐**   | 系统自动将未出现在索引列中的数据表主键补齐到索引表主键中。   |



> **模式自由（Schema-free)**

  模式自由（[Schema](https://so.csdn.net/so/search?q=Schema&spm=1001.2101.3001.7020)-free)，所谓“面向集合”（Collection-Oriented），意思是**数据被分组存储在数据集中**，被称为一个集合 （Collection)。**每个集合在数据库中都有一个唯一的标识名，并且可以包含无限数目的文档**。集合的概念类似关系型数据库（RDBMS）里的表 （Table），不同的是它不需要定义任何模式（Schema)。

  模式自由（Schema-free)，意味着对于存储在Mongodb数据库中的文件，我们不需要知道它的任何结构定义。如果需要的话，你完全可以把不同结构的文件存储在同一个数据库里。

  存储在集合中的文档，被**存储为“键-值”对的形式**。

**键用于唯一标识一个文档，为字符串类型，而值则可以是各中复杂的文件类型**。我们称这种存储形式为BSON（Binary Serialized dOcument Format）。

  现在，一般设备的计算能力已经有了飞跃的提高，不再受限于使用严格格式化数据存取来提高效率。采用在线解析的方式（比如：XML，JSON）已经可以满足 人机交互，实现较好的用户体验。除了在嵌入式、处理流程极为固定的场景下，曾经定义一个按位(bit)存取的数据机构，采用二进制方式的高效数据存储的时 代，几乎一去不复返了。







书签
===







###### 宽表模型与关系模型区别

> 宽表模型和关系模型有不同的特点请参见下表。

| **模型**     | **特点**                                                     |
| ------------ | ------------------------------------------------------------ |
| **宽表模型** | **三维结构（行、列和时间）**、Schema-Free、**宽行**、**多版本数据以及生命周期管理**。 |
| **关系模型** | **二维**（行、列）以及**固定的Schema**。                     |















##### (2)Timeline

`Timeline模型`是一种`用于消息数据`的新一代模型，适用于IM、Feeds和物联网设备消息下`推等消息系统中消息的存储和同步`，目前已经开始被广泛使用。























二、怎么用？
---



### 1.初始化环境

>开通服务、创建实例、表、索引等

参考文档：https://developer.aliyun.com/article/784426





































































