

## 一、数组与字符串





#### [01.01. 判定字符是否唯一](https://leetcode.cn/problems/is-unique-lcci/)

已解答

简单

实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。

**示例 1：**

```
输入: s = "leetcode"
输出: false 
```

**示例 2：**

```
输入: s = "abc"
输出: true
```

**限制：**

- `0 <= len(s) <= 100 `
- `s[i]`仅包含小写字母
- 如果你不使用额外的数据结构，会很加分。



##### 方法一:位运算

```java
class Solution {
    public boolean isUnique(String astr) {
        int result = 0;
        char[] chars = astr.toCharArray();
        for(char c : chars){
            int mark = c - 'a';
            if((result & (1 << mark)) != 0){
                return false;
            }else{
                result ^= (1 << mark);
            }
        }
        return true;
    }
}
```











#### [01.02. 判定是否互为字符重排](https://leetcode.cn/problems/check-permutation-lcci/)

> 简单

给定两个由小写字母组成的字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

**示例 1：**

```
输入: s1 = "abc", s2 = "bca"
输出: true 
```

**示例 2：**

```
输入: s1 = "abc", s2 = "bad"
输出: false
```

**说明：**

- `0 <= len(s1) <= 100 `
- `0 <= len(s2) <= 100 `





##### 1.Arrays.sort()

```java
/**
Arrays工具类的sort:
    1.对s1,s2的长度比较进行前置判断节省资源
    2.将s1,s2分别转换为char型数据char1和char2
    3.利用Arrays.sort()方法分别将char1和char2进行排序
    4.最后将两个数据转换为new String(char[])进行equals对比
 */
class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        if(s1.length() != s2.length()) return false;
        char[] char1 = s1.toCharArray();
        char[] char2 = s2.toCharArray();
        Arrays.sort(char1);
        Arrays.sort(char2);
        return new String(char1).equals(new String(char2));
    }
}
```





##### 2.HashMap

```java
/**
HashMap:
    1.使用HashMap的Key是唯一的特性,利用map.getOrDefault(c , 0);
    2.遍历s1并且每个位置+1
    3.遍历s2并且每个位置-1
    4.最后遍历map.values(),判断是否存在不是0的情况,存在则返回false
    5.最终没有返回true
 */
class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        Map<Character,Integer> map = new HashMap();
        for(int i = 0;i < s1.length();i++){
            char c = s1.charAt(i);
            map.put(c ,map.getOrDefault(c ,0) + 1);
        }
        for(int i = 0;i < s2.length();i++){
            char c = s2.charAt(i);
            map.put(c,map.getOrDefault(c , 0) - 1);
        }
        for(Integer num : map.values()){
            if(num != 0) return false;
        }
        return true;
    }
}
```

















#### [01.03. URL化](https://leetcode.cn/problems/string-to-url-lcci/)

简单

URL化。编写一种方法，将字符串中的空格全部替换为`%20`。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用`Java`实现的话，请使用字符数组实现，以便直接在数组上操作。）

 

**示例 1：**

```
输入："Mr John Smith    ", 13
输出："Mr%20John%20Smith"
```

**示例 2：**

```
输入："               ", 5
输出："%20%20%20%20%20"
```

 

**提示：**

- 字符串长度在 [0, 500000] 范围内。





##### 1.StringBuilder

```java
/**
单指针:
	1.使用StringBuilder遍历当前字符串
	2.如果遍历到' '则append("%20")
	3.否则append当前字符
*/
class Solution {
    public String replaceSpaces(String S, int length) {
        StringBuilder sb = new StringBuilder();
        // if(S.trim().length() != 0){
        //     S = S.trim();
        // }
        for(int i = 0; i < length ;i++){
            if(S.charAt(i) == ' '){
                sb.append("%20");
            }else{
                sb.append(S.charAt(i));
            }
        }
        return sb.toString();
    }
}
```







#### [01.04. 回文排列](https://leetcode.cn/problems/palindrome-permutation-lcci/)

> 简单

给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。

回文串不一定是字典当中的单词。



**示例1：**

```
输入："tactcoa"
输出：true（排列有"tacocat"、"atcocta"，等等）
```

 



> 审题

正反两个方向都相同的单词或者短语，排列是重新打乱顺序之后的排列



##### 1.尝试方法一：26位boolean数组(X)

```java
/**
思路(利用回文相对的字符串相同的思想)：
    使用长度为26的boolean数组：
    1.将S字符串拆分为单个字符。
    2.遍历每个字符,让它-a,得到一个ascll码值n,对应到boolean数组上的n号位置换当前位置的值。
    3.如果当前位置上是false(初始值)则将其置换为true,反之置换为false。
    4.最后遍历整个boolean数组,查看有多少个ture
    5.超过1个就返回false
 */
class Solution {
    public boolean canPermutePalindrome(String s) {
        if(s == null || s.length() == 0){
            return true;
        }
        boolean[] flagArray = new boolean[26];
        for(int i = 0;i < s.length();i++){
            int n = s.charAt(i) - 'a';
            flagArray[n] = flagArray[n] ? false : true;
        }
        int result = 0;
        for(boolean c : flagArray){
            if(c){
                result += 1;
            }
        }
        return result <= 1;
    }
}
```

```java
执行出错
23 / 27 个通过的测试用例
java.lang.ArrayIndexOutOfBoundsException: Index -32 out of bounds for length 1000000
  at line 18, Solution.canPermutePalindrome
  at line 57, __DriverSolution__.__helper__
  at line 82, __Driver__.main
最后执行的输入
添加到测试用例
s =
"AaBb//a"
```



##### 2.查看提示

1. 你不必且也不应该生成所有的排列。这将极为低效。——这个可以猜到
2. 作为回文排列的字符串有什么特征？—— 对称性(如果相同就能抵消掉的话,最后长度不超过1)
3. 你试过散列表吗？你应该能把它降到O(N)的时间。







##### 3.尝试方法二：散列表(1)

```java
/**60.98%T + 63.05%M
散列表（HashMap）来解决这个问题。具体思路如下：
1.创建一个散列表，用于统计每个字符在字符串中出现的次数。
2.遍历字符串，对于每个字符，将其加入散列表，并增加其出现次数。
3.再次遍历字符串，对于每个字符，将其从散列表中减少其出现次数。
4.最终，如果字符串长度是偶数，那么散列表中所有字符的出现次数应该都是偶数；如果字符串长度是奇数，那么只有一个字符的出现次数应该是奇数，其余字符的出现次数应该都是偶数。
 */
class Solution {
    public boolean canPermutePalindrome(String s) {
        Map<Character,Integer> map = new HashMap();
        for(int i = 0; i < s.length(); i++) { 
            char c = s.charAt(i);
            map.put(c,map.getOrDefault(c,0) + 1);
        }
        Integer result = 0;
        for (Integer count : map.values()) {
            if(count % 2 != 0){
                result += 1;
            }
        }
        return result <= 1;
    }
}
```





##### 4.尝试方法三：位向量

提示中提到可以使用位向量来减少空间使用。

>首先要熟悉位运算前置概念

```java
/**
思路(位运算)：
    1.字符串拆分为astr.length()个单个字符
    2.遍历字符串,拿到单个字符进行匹配
    3.核心是将当前字符value - 'a' = moveNum(让1 << moveNum位)即可得到当前位置为1其余位置为0的数字
    4.随后让mark再|= (1 << moveNum)即可录入当前位置数据到mark中
    5.每次遍历不断进行对比看看是否位置上有重复,有的话直接返回false
    6.所有字符都不存在重复则返回true
 */
class Solution {
    public boolean isUnique(String astr) {
        int mark = 0;
        char[] strArray = astr.toCharArray();
        for(char value : strArray){
            int moveNum = value - 'a'; 
            if((mark & (1 << moveNum)) != 0){
                return false;
            }
            else{
                mark |= (1 << moveNum);
            }
        }
        return true;
    }
}
```







#### [01.05. 一次编辑](https://leetcode.cn/problems/one-away-lcci/)

中等



字符串有三种编辑操作:插入一个英文字符、删除一个英文字符或者替换一个英文字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

 

**示例 1:**

```
输入: 
first = "pale"
second = "ple"
输出: True
```

 

**示例 2:**

```
输入: 
first = "pales"
second = "pal"
输出: False
```



##### 1.尝试分情况处理(失败)

```java
/**
思路：共涉及三种操作,一种不操作情况(两字符串相等)
    前置判断:排查两字符串相等的情况
    一、插入一个字符 || 二、删除一个字符
        实际中插入或者删除其中一个字符串的字符，只是它们的顺序不一致导致需要的操作。
        也就是说只要顺序处理得当,两种操作可合并

    三、替换一个字符
 */
class Solution {
    public boolean oneEditAway(String first, String second) {
        //不操作情况
        if(first.equals(second) || (first.length() == 0 && second.length() == 1) || (second.length() == 0 && first.length() ==1)){
            return true;
        }
//        //一、插入一个字符 || 二、删除一个字符(合并)
        if(Math.abs(first.length() - second.length()) == 1){
            char[] firstChar = first.toCharArray(), secondChar = second.toCharArray();
            int length = Math.min(secondChar.length, firstChar.length);
            int n = 0,m = 0;
            for (int i = 0; i < length; i++) {
                if (firstChar[n] != secondChar[m]){
                    if(firstChar.length > secondChar.length){
                        n += 1;
                    }else {
                        m += 1;
                    }
                }
                n += 1;
                m += 1;
                if(Math.abs(n - m) > 1){
                    return false;
                }
            }
            return Math.abs(n - m) == 1;
        }
        //三、替换一个字符,遍历任意一个字符串
        else if(first.length() - second.length() == 0){
            int count = 0;
            for (int i = 0; i < first.length(); i++) {
                if(first.charAt(i) != second.charAt(i)){
                    count += 1;
                }
            }
            return count == 1;
        }
        return false;
    }
}
```



>未通过测试用例

```java
解答错误
1124 / 1146 个通过的测试用例

官方题解
输入
first =
"a"
second =
"ab"

添加到测试用例
输出
false
预期结果
true
```







##### 2.双指针

```java
/**100.00%
双指针:
题意:
    1.需要考虑三种可能的编辑操作：插入、删除和替换。
    2.问题要求判断两个字符串是否需要进行最多一次编辑,就可以使它们相同。

分析思路:
    1.首先，比较两个字符串长度差异和字符差异。有助于确定它们是否可以通过最多一次编辑变得相同。
    2.如果两个字符串的长度差异 > 1,则一定需要多次编辑,直接返回false。
    3.在长度相差为1的情况下,分别考虑长度短和长度长的字符串之间的关系:
        如果长度短的字符串是由长度长的字符串通过一个字符的删除得到的，那么最多只需要一次编辑操作。
        如果长度长的字符串是由长度短的字符串通过一个字符的插入得到的，那么最多也只需一次编辑操作。
        遍历两个字符串进行比较，当发现字符不同时，记录编辑次数，并根据长度的差异移动指针。
        最后检查结束后的编辑次数，验证是否只需要一次编辑。

代码实现思路:
    1.前置判断:比较两个字符串长度差异,差异 > 1,之间return false。
    2.初始化两个指针n,m分别指向两个字符串的起始位置,再初始化变量editCount记录编辑次数
    3.遍历两个字符串进行比较:
        遇到不同字符,先增加编辑次数,并根据长度的差异移动指针。
        如果字符相同,继续向后移动指针。
    4.最后遍历完成后检查编辑次数以判断是否为一次编辑。

 */
class Solution {
    public boolean oneEditAway(String first, String second) {
        int length1 = first.length(),length2 = second.length();
        //前置判断
        if(Math.abs(length1 - length2) > 1) return false;

        //指针及变量赋值
        int editCount = 0,n = 0,m = 0;
        //遍历分情况判断
        while(n < length1 && m < length2){
            if(first.charAt(n) != second.charAt(m)){
                //发现字符不同,编辑数+1
                editCount += 1;
                //合理判断,满足则无需判断
                if(editCount > 1) return false;
                //如果first.length()比second.length()要长,则让n += 1;
                if(length1 > length2){
                    n += 1;
                }
                //如果first.length()比second.length()要短,则让m += 1;
                else if(length1 < length2){
                    m += 1;
                }
                //如果两个都是一样长,则两个都 + 1
                else{
                    n += 1;
                    m += 1;
                }
            }
            //相同,则继续往下遍历
            else{
                n += 1;
                m += 1;
            }
        }

        //检查如果有一个字符串遍历完了,此时双指针均指向两次数最末,且编辑次数最多为1,则返回true
        if(n == length1 && m == length2) return editCount <= 1;

        //处理空字符串和一个字符的情况
        if(n == length1 && m == length2 - 1 || n == length1 - 1 && m == length2){
            return editCount == 0 || editCount == 1;
        }
        return false;
    }
}
```

注:

​	1.while条件下两个变量对应字符串长度都需要判断

​	2.除特殊情况外,正常走出循环两个指针肯定是指向两个字符串最末,因此这里需要





#### [01.06. 字符串压缩](https://leetcode.cn/problems/compress-string-lcci/)

简单



字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串`aabcccccaaa`会变为`a2b1c5a3`。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

**示例1:**

```
 输入："aabcccccaaa"
 输出："a2b1c5a3"
```

**示例2:**

```
 输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
```

**提示：**

1. 字符串长度在[0, 50000]范围内。



##### 1.尝试用map解决(失败)

```java
/**
使用Map<c,num>:
    1.遍历字符串S,使用map存储,key为当前遍历字符,value部分不断随着遍历的次数累加。
    2.最终遍历字符串，然后累加当前不重复字符 + map.get(c)得到的数字。
    3.拼接字符串返回

 */
class Solution {
    public String compressString(String S) {
        StringBuilder sb = new StringBuilder();
        Map<Character,Integer> map = new HashMap<>();
        for(int i = 0;i < S.length();i++){
            char c = S.charAt(i);
            map.put(c , map.getOrDefault(c , 0) + 1);
        }

        for(int i = 0;i < S.length();i++){
            ...
        }
        return sb.toString();
    }
}
```



> 无法解决用例：

```java
S = "aabcccccaa"
```







##### 2.双指针解决

```java
/**
双指针:
    1.指针n,m都从0起始。
    2.n不动,m动,直到m = S.length() || S.charAt(m) != S.charAt(m - 1)
    3.此时sb.append(S.charAt(n)) + (m - n)两部分
    4.最终return sb.toString();
 */
class Solution {
    public String compressString(String S) {
        //前置判断(否则遍历空指针)
        if(S == null || S.length() == 0) return S;
        StringBuilder sb = new StringBuilder();
        int n = 0,m = 0;
        for(;m < S.length();m++){
            if(m != 0 && m != S.length() && S.charAt(m) != S.charAt(m - 1)){
                sb.append(S.charAt(n));
                sb.append(m - n);
                n = m;
            }
        }
        //处理最后一次临界值
        sb.append(S.charAt(n));
        sb.append(m - n);
        return sb.length() < S.length() ? sb.toString() : S;
    }
}
```





>再优化代码

```java
/**24.84%
双指针:
    1.指针n,m都从0起始。
    2.n不动,m动,直到m = S.length() || S.charAt(m) != S.charAt(m - 1)
    3.此时sb.append(S.charAt(n)) + (m - n)两部分
    4.最终return sb.toString();
 */
class Solution {
    public String compressString(String S) {
         //前置判断(否则遍历空指针)
        if (S == null || S.length() == 0) return S;
        StringBuilder sb = new StringBuilder();
        //必须把m = S.length()带上才能利用它累加到最后的一次append
        for (int n = 0, m = 0; m <= S.length(); m++) {
            if (m == 0) continue;
            if (m < S.length()) {
                if (S.charAt(m) != S.charAt(m - 1)) {
                    sb.append(S.charAt(n));
                    sb.append(m - n);
                    n = m;
                }
            }
            //处理临界值
            else {
                sb.append(S.charAt(n));
                sb.append(m - n);
            }

        }
        return sb.length() < S.length() ? sb.toString() : S;
    }
}
```











#### [01.07. 旋转矩阵](https://leetcode.cn/problems/rotate-matrix-lcci/)

已解答

中等



给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

 

**示例 1:**

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

**注意**：本题与主站 48 题相同：https://leetcode-cn.com/problems/rotate-image/







##### 尝试一：借用额外数组空间(推理)



###### 1.推理

```java
例矩阵为:
1,2,3
4,5,6
7,8,9

一.数值变化:
1,2,3
4,5,6
7,8,9
转换为:
7,4,1
8,5,2
9,6,3

二.坐标变化:
1{0,0}	2{0,1}	3{0,2}
4{1,0}	5{1,1}	6{1,2}
7{2,0}	8{2,1}	9{2,2}

转换为:		
7{0,1}	4{0,1}	1{0,2}
8{1,0}	5{1,1}	2{1,2}
9{2,0}	6{2,1}	3{2,2}
```



###### 2.推导结果

```java
matrix[0][0] -> newMatrix[0][2]
matrix[0][1] -> newMatrix[1][2]
matrix[0][2] -> newMatrix[2][2]

matrix[1][0] -> newMatrix[0][1]
matrix[1][1] -> newMatrix[1][1]
matrix[1][2] -> newMatrix[2][1]

matrix[2][0] -> newMatrix[0][0]
matrix[2][1] -> newMatrix[1][0]
matrix[2][2] -> newMatrix[2][0]
```

这样就可以得到顺时针旋转90度后的新矩阵。从上述规律中发现：

1. 只需要**将原有的i位置替换为j**，也就是`newMatrix[j][i]`
2. 设n=矩阵的长度length随后发现现在**在j位置上的i需要替换成n-1-i**,也就是`newMatrix[n-i-1]`

最终推导出来的替换公式为：
$$
newMatrix[j][n-1-i] = matrix[i][j]
$$






>实现代码

在代码中，使用双重循环遍历原矩阵，将原矩阵中的元素按照这个规则复制到新的矩阵中。

```java
    public static void main(String[] args) {
        int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
        int length = matrix.length;
        int[][] newMatrix = new int[length][length];
        //双重循环遍历按照推导公式遍历赋值给newMatrix
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++){
                //推导公式,数组长度与实际下标相差1故此-1
                newMatrix[j][length - 1 -i] = matrix[i][j];
                //打印原数组
                System.out.print(matrix[i][j]);
                if(j != length - 1) System.out.print(" ");
            }
            System.out.println();
        }
        System.out.println("================================");
        System.out.println("旋转后如下:");
        //打印目标旋转后的矩阵
        for (int i = 0; i < newMatrix.length; i++) {
            for (int j = 0; j < newMatrix[i].length; j++) {
                System.out.print(newMatrix[i][j]);
                if(j != length - 1) System.out.print(" ");
            }
            System.out.println();
        }
    }
```

注：不可直接赋值，使用了`int[][] newMatrix = matrix;`将`newMatrix`引用指向了`matrix`的地址。这意味着`newMatrix`和`matrix`指向同一块内存，它们实际上是同一个数组。



###### 3.最终代码

```java
/**m:7.20%
占用额外数组
 */
class Solution {
    public void rotate(int[][] matrix) {
        int length = matrix.length;
        int[][] newMatrix = new int[length][length];
        for(int i = 0; i < length; i++){
            for(int j = 0; j < length; j++){
                newMatrix[j][length - 1 - i] = matrix[i][j];
            }
        }
         for(int i = 0; i < length; i++){
            for(int j = 0; j < length; j++){
                 matrix[i][j] = newMatrix[i][j];
            }
        }
    }
}
```





##### 尝试二：对角/中线翻转



###### 1.推理

当考虑如何原地旋转矩阵的时候，可以通过一系列翻转操作来实现。详细推导过程如下：



###### 2.推导步骤

>先对于一个N x N的矩阵，需要将其按对角线翻转

也就是将矩阵的元素`matrix[i][j]`和`matrix[j][i]`进行交换

```java
before
1{0,0}	2{0,1}	3{0,2}
4{1,0}	5{1,1}	6{1,2}
7{2,0}	8{2,1}	9{2,2}

after
1{0,0}	4{0,1}	7{0,2}
2{1,0}	5{1,1}	8{1,2}
3{2,0}	6{2,1}	9{2,2}
```

这一步是为了将矩阵的行和列进行互换

例如，考虑一个3x3的矩阵：

```java
1 2 3
4 5 6
7 8 9
```

在对角线翻转时，我们只需要处理上三角部分，即：

```java
1 x x
4 5 x
7 8 9
```

如果我们不使用`j = i + 1`，而是直接从`j = 0`开始，那么我们将处理整个矩阵，包括对称轴上的元素，导致元素重复翻转。

因此，`j = i + 1`是确保我们只操作矩阵的上三角部分的一种常见写法。

实现代码如下：

```java
    public static void main(String[] args) {
        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
        for (int i = 0; i < matrix.length; i++) {
            for (int j = i + 1; j < matrix[i].length; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        //打印
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.print(matrix[i][j]);
                if(j != matrix[i].length) System.out.print(" ");
            }
            System.out.println();
        }
    }
```





>随后按照中位线互换

```java
before
1{0,0}	4{0,1}	7{0,2}
2{1,0}	5{1,1}	8{1,2}
3{2,0}	6{2,1}	9{2,2}

after
7{0,0}	4{0,1}	1{0,2}
8{1,0}	5{1,1}	2{1,2}
9{2,0}	6{2,1}	3{2,2}
```

经过这两个步骤，我们完成了矩阵的顺时针旋转90度的操作。这两个步骤中的翻转操作是原地进行的，没有使用额外的数组空间。

实现代码如下：

```java
    public static void main(String[] args) {
        int[][] matrix = {{1,2,3},{4,5,6},{7,8,9}};
        for (int i = 0; i < matrix.length; i++) {
            //设matrix如此例,只是中位线前半部分的元素执行交换就可以了
            for (int j = 0; j < matrix[i].length / 2; j++) {
                //交换matrix[i][j]和matrix[i][matrix.length - 1 -j]
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length - 1 - j];
                matrix[i][matrix.length - 1 - j] = temp;
            }
        }
        //打印
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.print(matrix[i][j]);
                if(j != matrix[i].length) System.out.print(" ");
            }
            System.out.println();
        }
    }
```





###### 3.最终代码

```java
/**28.56%
1.对角线替换
2.中位线替换
 */
class Solution {
    public void rotate(int[][] matrix) {
        //1.对角线替换
        for(int i = 0;i < matrix.length;i++){
            //int j = i + 1 对角线右上三角遍历到再替换
            for(int j = i + 1;j < matrix[i].length; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        //2.中位线替换
        for(int i = 0;i < matrix.length; i++){
            //j < matrix[i].length / 2遍历中位线前的元素时替换即可
            for(int j = 0;j < matrix[i].length / 2; j++){
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length - 1 - j];
                matrix[i][matrix.length - 1 - j] = temp;
            }
        }
    }
}
```









#### [01.08. 零矩阵](https://leetcode.cn/problems/zero-matrix-lcci/)

中等

> 提示

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

 

**示例 1：**

```
输入：
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

**示例 2：**

```
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```





##### 尝试一：借用额外boolean数组



>尝试代码

```java
public static void main(String[] args) {
        int[][] nums = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 0}, {1, 2, 3, 4, 5}, {6, 7, 8, 9, 0}, {1, 2, 3, 4, 5}};
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums[i].length; j++) {
                System.out.print(nums[i][j] + " ");
            }
            System.out.println();
        }
        System.out.println("-----------------------");
        //使用同样大小的boolean数组来对应位置赋值0,初始化为false,为0的位置就是true
        boolean[][] target = new boolean[nums.length][nums.length];
        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums[i].length; j++) {
                //当前为0号位,当前横轴和纵轴都为0,对应到target数组中都为true
                if (nums[i][j] == 0) {
                    //i不变,横轴变
                    for (int s = 0; s < nums[i].length; s++) {
                        target[i][s] = true;
                    }
                    //j不变,纵轴变
                    for (int s = 0; s < nums.length; s++) {
                        target[s][j] = true;
                    }
                }
            }
        }


        for (int i = 0; i < target.length; i++) {
            for (int j = 0; j < target[i].length; j++) {
                if(target[i][j]) nums[i][j] = 0;
            }
        }



        for (int i = 0; i < nums.length; i++) {
            for (int j = 0; j < nums[i].length; j++) {
                System.out.print(nums[i][j] + " ");
            }
            System.out.println();
        }

    }
```





>实际代码

```java
/**
模板对照:
    1.初始化boolean模板数组target用于对照哪些地方需要为0,为0当前则为true
    2.遍历matrix数组查看0的位置,对应再置换target整个横坐标和整个纵坐标元素为true
    3.最后遍历对照target更改matrix数组相应位置为0
 */
class Solution {
    public void setZeroes(int[][] matrix) {
        //由于实时操作将会影响后续结果,故此初始化对照模板数组
        boolean[][] target = new boolean[matrix.length][matrix[0].length];
        for(int i = 0;i < matrix.length; i++){
            for(int j = 0;j < matrix[i].length;j++){
                //置换target对应位置
                if(matrix[i][j] == 0){
                    //置换target对应横坐标元素
                    for(int index = 0;index < matrix[i].length;index++){
                        target[i][index] = true;
                    }
                    //置换纵坐标元素
                    for(int index = 0;index < matrix.length;index++){
                        target[index][j] = true;
                    }
                }
            }
        }

        for(int i = 0;i < matrix.length; i++){
            for(int j = 0;j < matrix[i].length; j++){
                if(target[i][j]){
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```







#### [01.09. 字符串轮转](https://leetcode.cn/problems/string-rotation-lcci/)

简单

> 提示

字符串轮转。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成（比如，`waterbottle`是`erbottlewat`旋转后的字符串）。

**示例1:**

```
 输入：s1 = "waterbottle", s2 = "erbottlewat"
 输出：True
```

**示例2:**

```
 输入：s1 = "aa", s2 = "aba"
 输出：False
```



**提示：**

1. 字符串长度在[0, 100000]范围内。

**说明:**

1. 你能只调用一次检查子串的方法吗？

通过次数

90.5K

提交次数

168.2K

通过率

53.8%

##### 尝试一：s1 + s1

```java
/**100%
思路:
    1.前置判断,长度相同。
    2.s2为s1的旋转,则s1 + s1包含了s1的全部旋转字符串
 */
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        return s1.length() == s2.length() && (s1 + s1).contains(s2);
    }
}
```





##### 尝试二：截取拼接

> 提示：

如果一个字符串是另一个字符串的旋转，那么它就是在某个特定点上的旋转。例如，字符串waterbottle在3处的旋转意味着在第三个字符处切割waterbottle，并在左半部分（wat）之前放置右半部分（erbottle）。

```java
/**14.42%
思路:
    假设s2是s1的轮转字符串,那么必定从subIndex位置开始,右半部分 + 左半部分 = s1
    故此遍历s2的每个字符去对比s1的第一个字符
    注:可以对比出来的字符相同,只是当下这个字符相同而已,故此相同时开始用假设对比是否成立
 */
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        //前置判断
        if(s1 == null || s2 == null || s1.length() != s2.length()) return false;
        if("".equals(s1) && "".equals(s2)) return true;
        for(int i = 0;i < s2.length(); i++){
            //遍历s2的每个字符去对比s1的第一个字符
            if(s1.charAt(0) == s2.charAt(i)){
                //假设成立
                if(s1.equals(s2.substring(i,s2.length()) + s2.substring(0,i))){
                    return true;
                }
            }
        }
        return false;
    }
}
```





##### 尝试三：只遍历不截取

> 提示

想想前面的提示。再想想当你将erbottlewat与它本身连接会发生什么。你得到了erbottlewaterbottlewat。

```java
/**23.78%
思路:
    假设s2是s1的轮转字符串,那么必定从i位置开始,右半部分 + 左半部分 = s1
    故此遍历s2的每个字符去对比s1的第一个字符
    每次遍历到相同位置的字符串后立马开始遍历当前位置与s1[0]一直遍历为止看看是否成立
    注:可以对比出来的字符相同,只是当下这个字符相同而已,故此相同时开始用假设对比是否成立
 */
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        //前置判断
        if(s1 == null || s2 == null || s1.length() != s2.length()) return false;
        if("".equals(s1) && "".equals(s2)) return true;
        for(int i = 0;i < s2.length(); i++){
            //遍历s2的每个字符去对比s1的第一个字符
            if(s1.charAt(0) == s2.charAt(i)){
                //假设成立,对比检查整个字符串s2是否对应s1
                boolean flag = true;
                for(int j = 0;j < s1.length(); j++){
                    //并不是从这个位置开始旋转
                    if(s1.charAt(j) != s2.charAt((i + j) % s2.length())){
                        flag = false;
                        break;
                    }
                }
                if(flag) return true;
            }
        }
        return false;
    }
}
```













## 二、链表







#### [02.01. 移除重复节点](https://leetcode.cn/problems/remove-duplicate-node-lcci/)

简单

> 提示



编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

**示例1:**

```
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
```

**示例2:**

```
 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
```

**提示：**

1. 链表长度在[0, 20000]范围内。
2. 链表元素在[0, 20000]范围内。

**进阶：**

如果不得使用临时缓冲区，该怎么解决？





##### 尝试一:HashSet

```java
/**27.05%
HashSet:
    使用set累加判断是否重复
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
       ListNode index = head;
       //set用于累加判断是否重复
       Set<Integer> set = new HashSet();
            while(index != null && index.next != null){
                set.add(index.val);
                //重复则删除index.next
                if(set.contains(index.next.val)){
                    index.next = index.next.next;
                }
                else{
                    index = index.next;
                }
            }
       return head;
    }
}
```





##### 尝试二:双指针

```java
/**8.22%
双指针:
    1.遍历链表使用left指针
    2.left用于遍历每个元素,起始值为head起始元素
    3.right指针用于对比遍历left右边的所有元素,起始位置从left开始
    4.遍历时left指针对应right.next的元素值对比是否相同
    5.相同则right.next = right.next.next
    6.直到right.next.next = null,执行完就停止
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
       ListNode left = head;
       while(left != null){
           ListNode right = left; 
           //注意:right.next != null一定要加上否则right.next.val会空指针
           while(right != null && right.next != null){
               //重复元素直接利用链接下下个元素删除当前重复元素
               if(left.val == right.next.val){
                   //删除下一个重复的元素之后,再重新遍历比较一次,否则会有遗漏例如:1,1,1,1,2变成1,1,2
                   right.next = right.next.next;
               }else{
                   right = right.next;
               }
           }
           left = left.next;
       }
       return head;
    }
}
```



































#### [02.02. 返回倒数第 k 个节点](https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/)

已解答

简单

> 提示



实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

**注意：**本题相对原题稍作改动

**示例：**

```
输入： 1->2->3->4->5 和 k = 2
输出： 4
```

**说明：**

给定的 *k* 保证是有效的。



##### 尝试一：快慢双指针

```java
/**100%
快慢双指针:
    1.left,right双指针起点都在head节点上
    2.先让right走k步
    3.随后遍历到right = null为最后一个尾节点为止
    4.此时left为倒数第k个节点
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode left = head,right = head;
        //先让right走k步
        for(int i = 0;i < k; i++){
            //题中说明k保证有效,则无需此判断
            // if(right.next == null) return 0;
            right = right.next;
        }
        while(right != null){
            left = left.next;
            right = right.next;
        }
        return left.val;
    }
}
```















#### [02.03. 删除中间节点](https://leetcode.cn/problems/delete-middle-node-lcci/)

简单

> 提示



若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。

假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。

例如，传入节点 `c`（位于单向链表 `a->b->c->d->e->f` 中），将其删除后，剩余链表为 `a->b->d->e->f`

 

**示例：**

```
输入：节点 5 （位于单向链表 4->5->1->9 中）
输出：不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9
```

通过率

85.8%



##### 尝试一：双指针(走一步，和走两步)



>想着用deleteFlag作为left的上一个指针，但是解答错误

```java
/**
双指针
 */
class Solution {
    public void deleteNode(ListNode node) {
        ListNode left = node,right = node,deleteFlag = node;
        boolean firstFlag = false;
        //&& right.next.next != null无需此条件,在链表中right遍历当前位置的节点时可以为null
        while(right != null && right.next != null){
            //当left遍历到该删除的位置上时,这个时需要deleteFlag才能删除left当前所在元素
            if(firstFlag) deleteFlag = deleteFlag.next;
            firstFlag = true;
            left = left.next;
            right = right.next.next;
        }
        //删除left所在中间(需要删除)的节点
        deleteFlag.next = left.next;
        return;
    }
}
```

```http
解答错误
执行用时: 0 ms
Case 1
输入
[4,5,1,9]
5
输出
[4,5,9]
预期结果
[4,1,9]
```





>审题错误！！！当前head已经指向了需要删除的那个节点呢！

```java
/**100.00%
*
*/
class Solution {
    public void deleteNode(ListNode node) {
        // 首先确保节点不是尾节点
        if (node == null || node.next == null)
            return;
        
        // 将下一个节点的值复制到当前节点
        node.val = node.next.val;
        // 跳过下一个节点
        node.next = node.next.next;
    }
}
```











#### [02.04. 分割链表](https://leetcode.cn/problems/partition-list-lcci/)

已解答

中等

> 提示



给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你不需要 **保留** 每个分区中各节点的初始相对位置。

 

**示例 1：**

![image-20240319193534088](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202403191935202.png)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 200]` 内
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`



##### 尝试一:使用两个新链表

>使用两个新链表分别处理不同情况的节点，最后将两个节点拼接

```java
/**100%
新建两链表:
    1.创建两个新链表headA和headB。
    2. < X的节点不断赋值给新的节点给不断接入到headA后。
    3. >= x的节点则不断接入到headB后。
    4.最后取headB的头节点.next(从有效节点开始)接入到headA的尾部。
    5.最后从headA的有效节点开始返回也就是headA.next
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        //创建两个新节点
        ListNode headA = new ListNode(), headB = new ListNode();
        ListNode A = headA, B = headB;
        while(head != null){
            if(head.val < x){
                A.next = new ListNode(head.val);
                // 更新 A 指针
                A = A.next;
            }else{
                B.next = new ListNode(head.val);
                // 更新B指针
                B = B.next;
            }
            head = head.next;
        }
        //headB还指向头部空节点
        headB = headB.next;
        A.next = headB;
        return headA.next;
    }
}
```





##### 尝试二:双指针(未完成)











#### [02.05. 链表求和](https://leetcode.cn/problems/sum-lists-lcci/)

中等

> 提示



给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

 

**示例：**

```
输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
输出：2 -> 1 -> 9，即912
```

**进阶：**思考一下，假设这些数位是正向存放的，又该如何解决呢?

**示例：**

```
输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
输出：9 -> 1 -> 2，即912
```





##### 尝试一:按步骤一步一步来(失败)

>测试用例数值太大，超int和过程中导致精度缺失

```java
/**失败
思路:
    1.用num1和num2来分别累加两个链表对应遍历的所有节点。
    2.累加规则为:从1起始,遍历下一个节点就X10,直到累加到最后null节点为止。
    3.最终将num1 + num2计算为num后,将String.valueOf(num)。
    4.最后遍历每个字符(转换为Integer类型)作为新链表l的每个节点值。
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        //也申明flag作为累加数的系数
        //注:这里用long来进行累加计算,但无奈还是在过程中造成精度缺失
        long num1 = 0,num2 = 0,flag = 1;
        while(l1 != null){
            num1 += l1.val * flag;
            flag *= 10;
            l1 = l1.next;
        }
        //重置flag
        flag = 1;
        while(l2 != null){
            num2 += l2.val * flag;
            flag *= 10;
            l2 = l2.next;
        }
        long num = num1 + num2;
        //创建求和后的新链表
        ListNode l = new ListNode(0);
        //前置判断如果num的结果=0则直接return此新链表
        if(num == 0) return l;
        ListNode index = l;
        while(num != 0){
            index.next = new ListNode((int) (num % 10));
            num /= 10;
            index = index.next;
        }
        return l.next;
    }
}
```

1. 原本题目中的测试用例数值太大，造成超过int支持范围**[-2147483648~2147483647]**，随后采用long类型进行计算。
2. 虽然已经将数字类型从 int 改为 long，以避免溢出问题，但是在将 long 类型的数字转换为链表时，直接将其**强制转换**为 int，这可能**导致丢失高位信息**。

```http
解答错误1560 / 1563 个通过的测试用例

官方题解

输入

l1 =

[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]

l2 =

[5,6,4]



添加到测试用例

输出

[2,8,0,4,6,2,5,0,3,0,7,2,4,4,9,6,7,0,5]

预期结果

[6,6,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]
```





##### 尝试二:累加过程中直接创建新链表

>既然测试用例会存在超大值情况，且分步骤计算后过程中**强制转换**也会精度缺失，那么就边遍历边将遍历到的计算数值创建合并后的新链表的每个节点。

```java
/**100% + 84.01%
同步计算生成新链表:
    1.创建双指针left,right分别指向l1和l2的头节点。
    2.创建新链表target初始头节点值为0,再创建需要处理是否需要进位的flag = 0。
    3.同时遍历l1和l2,且while条件为:left != null || right != null || flag != 0。
    4.用sum来累加left.val + right.val + flag。
    5.flag = sum / 10(用来处理进位的值)。
    6.target.next = new ListNode(sum % 10)。
    7.最终返回target.next有效起始头节点。
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode left = l1,right = l2,target = new ListNode(0),targetIndex = target;
        //处理进位
        int flag = 0;
        while(left != null || right != null || flag != 0){
            int leftNum = left == null ? 0 : left.val;
            int rightNum = right == null ? 0 : right.val;
            int sum = leftNum + rightNum + flag;
            flag = sum / 10;
            targetIndex.next = new ListNode(sum % 10);
            //遍历条件
            if(left != null) left = left.next;
            if(right != null) right = right.next;
            targetIndex = targetIndex.next;
        }
        return target.next;
    }
}
```











#### [02.06. 回文链表](https://leetcode.cn/problems/palindrome-linked-list-lcci/)



简单



> 提示



编写一个函数，检查输入的链表是否是回文的。

 

**示例 1：**

```
输入： 1->2
输出： false 
```

**示例 2：**

```
输入： 1->2->2->1
输出： true 
```

 

**进阶：**
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？



##### 尝试一:指针+List(失败)

```java
/**
指针+List:
    1.遍历链表,并将链表不断add到template中。
    2.当前遍历到的链表元素与上一个链表元素相同时。
    3.此时用新指针,起始点为当前节点,不断与template中的元素(从后至前)。
    4.若遍历完都是相同直至最后一个位置为null时,template刚好遍历完成,并对比的每个元素都相同。
    5.return true。
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        //前置判断
        if(head == null || head.next == null) return true;
        List<Integer> template = new ArrayList();
        while(head != null && head.next != null){
            if(head.val != head.next.val){
                template.add(head.val);
            }else{
                ListNode right = head.next;
                for(int i = template.size() - 1;i >= 0 && right != null; i--){
                    if(template.get(i) != right.val){
                        break;
                    }
                    if(right != null) right = right.next;
                }
            }
            head = head.next;
        }
        return false;
    }
}
```

```http
解答错误
17 / 26 个通过的测试用例

官方题解
输入
head =
[0,0]

添加到测试用例
输出
false
预期结果
true
```





##### 尝试二:反转后半部分链表

```java
/**94.00% + 89.17%
反转后半部分链表:
    1.快慢双指针找到中间节点
    2.反转后半部分链表
    3.遍历按照回文规则对比出结果
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        //前置判断
        if(head == null || head.next == null) return true;
        //快慢双指针找到中间节点
        ListNode left = head,right = head;
        while(right.next != null && right.next.next != null){
            left = left.next;
            right = right.next.next;
        }
        //反转后半部分
        ListNode template = reverse(left.next);
        while(template != null){
            if(head.val != template.val){
                return false;
            }
            template = template.next;
            head = head.next;
        }
        return true;
    }
    public ListNode reverse(ListNode node){
        // 初始化前一个节点为 null，因为链表反转后原来的头节点会变成尾节点，其 next 指针应该指向 null
        ListNode prev = null;
        // 当前节点初始化为链表的头节点
        ListNode current = node;
        // 循环直到当前节点为空，即到达链表尾部
        while (current != null) {
            // 保存当前节点的下一个节点，防止链表断裂
            ListNode nextNode = current.next;
            // 将当前节点的 next 指针指向前一个节点，实现反转
            current.next = prev;
            // 更新 prev 指针为当前节点，为下一次迭代做准备
            prev = current;
            // 更新 current 指针为原链表中的下一个节点，继续下一次迭代
            current = nextNode;
        }
        // 循环结束后，prev 指向反转后的链表的头节点，即链表的原尾节点
        // 返回 prev，即为反转后的链表的头节点
        return prev;
    }
}
```









#### [02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

已解答

简单

> 提示



给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

 

**示例 1：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

 

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `0 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`

 

**进阶：**你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？



提交次数

340.8K

通过率

66.3%



##### 尝试一：嵌套遍历(失败)

```java
/**
思路:
    1.两链表相交必有一个交点C,且节点值是相同的。
    2.随后接下来的节点都是一样的。
    3.使用双指针left和right。
    4.遍历headA,每遍历一个节点,就用right遍历一遍headB,找到与之节点值相同的节点。
    5.找到相同的节点后再new一个新指针来与right对比接下来的节点,都相同才相交。
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        //双指针
        ListNode left = headA,right = headB;
        while(left != null && headB != null){
            while(right != null){
                if(left.val == right.val){
                    ListNode flagA = left,flagB = right;
                    if(getResult(flagA, flagB)) return left;
                }
                right = right.next;
            }
            headB = headB.next;
            right = headB;
            left = left.next;
        }
        return null;
    }

     boolean getResult(ListNode left,ListNode right){
        while(left != null && right != null){
            if(left.val != right.val) return false;
                left = left.next;
                right = right.next;
            }
            if(left == null && right == null){
                return true;
            }
            return false;
     }
}
```

```http
在双指针循环的内部，对右指针进行了遍历。这导致时间复杂度为O(m * n)，其中m和n分别是两个链表的长度。可以优化为O(m + n)，即使双指针内部也不需要嵌套遍历。
getResult方法可以简化。不需要检查左右指针是否同时为空，只需检查它们是否都到达了链表的末尾即可。
```





##### 尝试二:双指针

```java
/**99.92% + 47.69
双指针:
    1.初始化left指向headA,初始化right指向headB。
    2.两链表相交,headA或者headB长度可能不一致,但是肯定存在某个节点相同的。
    3.当left或者right指向null的时候就将其指向另一个链表的头节点,继续遍历。
    4.直到left == right为止。
    5.(假设headA比headB多初始两个节点,那么,当right遍历完开始指向headA)。
    6.此时再过两个节点位置,left将指向headB的头节点,此时两链表相对长度一致。
    故此成立
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 双指针
        ListNode left = headA, right = headB;
        while (left != right) {
            left = left != null ? left.next : headB;
            right = right != null ? right.next : headA;
        }
        return left; // 如果有交点，返回交点；如果没有交点，返回null。
    }
}
```











#### [02.08. 环路检测](https://leetcode.cn/problems/linked-list-cycle-lcci/)

中等

> 提示



给定一个链表，如果它是有环链表，实现一个算法返回环路的`开头节点`。若环不存在，请返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```

 

**进阶：**

- 你是否可以不用额外空间解决此题？

 

##### 尝试一:双指针

```java
/**100% + 48.03%
双指针:
    1.使用快慢双指针left and right。
    2.第一次先让left走1步,right走2步。
    3.随后让left = head回到起点。
    4.接下来left and right都每次走1步。
    5.随之相遇的节点便是入环节点!
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        //双指针
        ListNode left = head,right = head;
        //left走1,right走2
        while(right != null && right.next != null){
            left = left.next;
            right = right.next.next;
            //边界判断
            if(left == right){
                //使得left重新回到起点!
                left = head;
                //left走1,right走1
                 while(left != right){
                    left = left.next;
                    right = right.next;
                }
                return left;
            }
        }
        return null;
    }
}
```



###### 疑问1

>为什么left走1,right走2到了left = right的时候，需要让left = head重新回到起点？

在left和right指针第一次相遇时,当前节点head1不一定是环的入口点。但是：


$$
链表头head到环的入口点(假设是target)的距离 = 第1次相遇点(head1) —> 环入口节点target 的距离
$$
故此得出：
$$
S = a + b
$$


因此，当快慢指针相遇时，让**其中任意一个指针**重新指向链表头，然后两个指针**以相同的速度**（都是每次移动一个节点）移动，**再次相遇的地方**就是环的入口点。



>为什么是这个方程？S = kc

1. 假设如上所示
2. 当快慢指针相遇时，假设慢指针left走过的距离是S，快指针right走过的距离是2S。
3. 由于快指针right的速度是慢指针left的2倍，故此在相遇的时候，快指针right走过的距离是2S。
4. 因此，可以得到方程：2S = S + kc 其中k表示快指针绕环的圈数。
5. 通过此方程可得：S = kc。

由于慢指针起点是链表头head。因此，当快慢指针相遇后，让其中一个指针重新指向链表头head，再次相遇的地方就是环的入口点target！





> 公式推论

- 假设从链表头到环的入口节点的距离=a。
- 从第1次相遇点head1到环的入口点的距离为b。
- 环的长度是c。



1. 则right指针在环中绕了k圈后与慢指针相遇！

2. 由于快指针right的速度是慢指针left的2倍。因此快指针right走过的距离是慢指针left的2倍。
   $$
   S − b = a + b + kc
   $$
   将方程重组一下：

   -b = a + b + kc - S

   我们已经知道 S*=*kc（因为慢指针在相遇时已经绕了 k 圈），所以可以将 S 替换为 kc：

   -b = a + b + kc − kc

   然后，kc 和 −kc 相互抵消，得到：

   −b = a + b

   现在，我们将b移至左侧，得到：

   a = − 2b
   $$
   a = - 2b
   $$







>a是链表头head到环的入口点taget的距离，根据求解的a = -2b怎么得到a？

- *a*：链表头到环的入口点的距离。
- b：从相遇点到环的入口点的距离。
- S：慢指针在第一次相遇时走过的距离。

当慢指针第一次到达环的入口点时，它已经走过的距离等于 S，因为它从链表头开始移动。根据上面的方程，我们有：

S = a + b

另一方面，我们得到 a = −2b，因此我们可以将 b 表示为 -a/2。

现在，我们可以将 S 重写为：

S = a + (-a/2)

S = 2a/2 - a/2

S = a / 2

所以，慢指针在第一次相遇时走过的距离等于链表头到环的入口点的距离的一半。

此时让其中一个指针回到head头节点，随后让双指针均以同样的速度1来运行，再遇到的时候，此节点必是入环节点！



###### 总结推导

$$
2S = S + kc;     ->  	S = kc;
$$


$$
S - b = a + b + kc; 	-> 	kc - b = a + b + kc;	->	-b = a + b;	->	a = -2b;	->	b = -a/2;
$$

$$
S = a + b;　->	S = a + -a/2;	->	S = a/2;
$$
故此慢指针left当前与right第一次相遇点距离第一个入环节点target刚好一半的距离。







## 三、栈与队列





#### [03.01. 三合一](https://leetcode.cn/problems/three-in-one-lcci/)

简单

> 提示



三合一。描述如何只用一个数组来实现三个栈。

你应该实现`push(stackNum, value)`、`pop(stackNum)`、`isEmpty(stackNum)`、`peek(stackNum)`方法。`stackNum`表示栈下标，`value`表示压入的值。

构造函数会传入一个`stackSize`参数，代表每个栈的大小。

**示例1:**

```
 输入：
["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"]
[[1], [0, 1], [0, 2], [0], [0], [0], [0]]
 输出：
[null, null, null, 1, -1, -1, true]
说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。
```

**示例2:**

```
 输入：
["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"]
[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]
 输出：
[null, null, null, null, 2, 1, -1, -1]
```

 

**提示：**

- `0 <= stackNum <= 2`





##### 尝试一:根据需求的求解

```java
/**100% + 51.54
按部就班
 */
class TripleInOne {
    /**
    初始化:
        array:      模拟3个栈的数组
        stackSize:  每个栈的大小(每个栈大小都一样)
        stockTops:  记录三个栈的栈顶坐标位
     */
    private int[] array;
    private int stackSize;
    private int[] stackTops;

    public TripleInOne(int stackSize) {
        this.stackSize = stackSize;
        this.array = new int [3 * stackSize];
        //由于坐标从0起始,故此初始值都为-1
        this.stackTops = new int []{-1, -1, -1};
    }
    
    public void push(int stackNum, int value) {
        //检查栈是否已满
        if(stackTops[stackNum] < stackSize - 1){
            stackTops[stackNum]++;
            /**
            第一个栈的元素存储在数组的索引从0到stackSize - 1的位置。
            第二个栈的元素存储在数组的索引从stackSize到2 * stackSize - 1的位置。
            第三个栈的元素存储在数组的索引从2 * stackSize到3 * stackSize - 1的位置。
            故此stackNum是从0开始的，stackNum = 0代表第一个栈，stackNum = 1代表第二个栈，stackNum = 2代表第三个栈
             */
            array[stackNum * stackSize + stackTops[stackNum]] = value;
        }
    }
    
    public int pop(int stackNum) {
        //首先要检查栈是否为空，然后弹出栈顶元素，并更新该栈的顶部位置
        if(stackTops[stackNum] != -1){
            int value = array[stackNum * stackSize + stackTops[stackNum]];
            stackTops[stackNum]--;
            return value;
        }
        //栈为null返回-1
        return -1;
    }
    
    public int peek(int stackNum) {
        if(stackTops[stackNum] != -1){
            return array[stackNum * stackSize + stackTops[stackNum]];
        }
        return -1;
    }
    
    public boolean isEmpty(int stackNum) {
        return stackTops[stackNum] == -1;
    }
}

/**
 * Your TripleInOne object will be instantiated and called as such:
 * TripleInOne obj = new TripleInOne(stackSize);
 * obj.push(stackNum,value);
 * int param_2 = obj.pop(stackNum);
 * int param_3 = obj.peek(stackNum);
 * boolean param_4 = obj.isEmpty(stackNum);
 */
```









#### [03.02. 栈的最小值](https://leetcode.cn/problems/min-stack-lcci/)

简单



> 提示



请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。



**示例：**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```





##### 尝试一:辅助栈

```java
/**100% + 86.84%
辅助栈:
    1.当设计这样一个栈时,你需要确保在每次push和pop操作时,都能保持最小值的有效性。
    2.也就是随时能够返回当前栈中的最小值,为了达到O(1)的复杂度，可以使用辅助栈实现。
 */
class MinStack {
    private Stack<Integer> stack;
    private Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack();
        minStack = new Stack();
    }
    
    public void push(int x) {
        stack.push(x);
        if(minStack.isEmpty() || x <= minStack.peek()){
            minStack.push(x);
        }
    }
    
    public void pop() {
        int val = stack.pop();
        if(val == minStack.peek()){
            minStack.pop();
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```















#### [03.03. 堆盘子](https://leetcode.cn/problems/stack-of-plates-lcci/)

中等

> 提示



堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构`SetOfStacks`，模拟这种行为。`SetOfStacks`应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，`SetOfStacks.push()`和`SetOfStacks.pop()`应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个`popAt(int index)`方法，根据指定的子栈，执行pop操作。

当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，`pop`，`popAt` 应返回 -1.

**示例1:**

```
 输入：
["StackOfPlates", "push", "push", "popAt", "pop", "pop"]
[[1], [1], [2], [1], [], []]
 输出：
[null, null, null, 2, 1, -1]
```

**示例2:**

```
 输入：
["StackOfPlates", "push", "push", "push", "popAt", "popAt", "popAt"]
[[2], [1], [2], [3], [0], [0], [0]]
 输出：
[null, null, null, null, 2, 1, 3]
```





##### 尝试一：按步骤

```java
/**60.82 + 50.00
思路:
    1.用List<Stack>来存放多个栈,大小由实际需求动态变化。
    2.push()操作两种处理方式:
        2.1 最后一个栈满了,此时新增一个栈、push当前元素、add到List中。
        2.2 最后一个栈没满,此时push到List中的size() - 1个栈中。
    3.pop()方法可以直接采用popAt(),参数传最后一个就好:
        3.1 其中popAt()方法需要处理的是弹出指定位置栈的栈顶元素。
        3.2 可以通过list拿到指定index的栈。
        3.3 拿到之后执行stack的pop操作。
        3.4 执行pop()后还需要判断当前这个stack是否已经空了,空了要在list中remove()。

 */
class StackOfPlates {

    private List<Stack<Integer>> stackList; // 存放各个栈的列表
    private int cap; // 每个栈的容量

    /**
     * 初始化 StackOfPlates 对象
     * @param cap 每个栈的容量
     */
    public StackOfPlates(int cap) {
        stackList = new ArrayList<>();
        this.cap = cap;
    }

    /**
     * 将元素压入堆栈
     * @param val 待压入的元素值
     */
    public void push(int val) {
        // 如果栈的容量非正数，直接返回
        if (cap <= 0) {
            return;
        }

        // 如果栈列表为空或者最后一个栈已满，创建一个新的栈并压入元素
        if (stackList.isEmpty() || stackList.get(stackList.size() - 1).size() == cap) {
            Stack<Integer> stack = new Stack<>();
            stack.push(val);
            stackList.add(stack);
            return;
        }

        // 否则，将元素压入最后一个栈
        stackList.get(stackList.size() - 1).push(val);
    }

    /**
     * 从堆栈中弹出一个元素
     * @return 弹出的元素值，如果堆栈为空，则返回 -1
     */
    public int pop() {
        // 直接调用 popAt 方法，弹出最后一个栈的栈顶元素
        return popAt(stackList.size() - 1);
    }

    /**
     * 从指定位置的栈中弹出一个元素
     * @param index 指定位置的栈的索引
     * @return 弹出的元素值，如果索引无效或指定位置的栈为空，则返回 -1
     */
    public int popAt(int index) {
        // 如果索引无效，返回 -1
        if (index < 0 || index >= stackList.size()) {
            return -1;
        }

        // 获取指定位置的栈
        Stack<Integer> stack = stackList.get(index);
        // 如果栈为空，返回 -1
        if (stack.isEmpty()) {
            return -1;
        }

        // 弹出栈顶元素
        int res = stack.pop();

        // 如果栈为空，从栈列表中移除该栈
        if (stack.isEmpty()) {
            stackList.remove(index);
        }

        return res;
    }
}
```













#### [03.04. 化栈为队](https://leetcode.cn/problems/implement-queue-using-stacks-lcci/)

简单



相关标签

相关企业



> 提示



实现一个MyQueue类，该类用两个栈来实现一个队列。



**示例：**

```
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```





**说明：**

- 你只能使用标准的栈操作 -- 也就是只有 `push to top`, `peek/pop from top`, `size` 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。



##### 尝试一:双栈

```java
/**47.95 + 50.34
双栈模拟:
    1.由于队列是先进先出,而栈是先进后出。
    2.故此使用两个栈stackIn和stackOut来模拟队列。
    3.方法有push()、pop()、peek()、empty()。
    4.注意在pop()和peek()中if(stackOut.isEmpty()) conversion();
 */
class MyQueue {
    private Stack<Integer> stackIn;
    private Stack<Integer> stackOut;

    /** Initialize your data structure here. */
    public MyQueue() {
        stackIn = new Stack<Integer>();
        stackOut = new Stack<Integer>();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        stackIn.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(stackOut.isEmpty()) conversion();
        return stackOut.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        if(stackOut.isEmpty()) conversion();
        return stackOut.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stackIn.isEmpty() && stackOut.isEmpty();
    }
    //将入栈元素全部转给出栈
    public void conversion(){
        if(stackIn.isEmpty()) return;
        while(!stackIn.isEmpty()) stackOut.push(stackIn.pop());
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```



>为什么仅当 stackOut 为空时才调用 conversion 方法进行栈转换而不是stackIn为空时呢？

这是**因为 `stackOut` 是用来保存队列头部的元素，而 `stackIn` 是用来保存队列尾部的元素。**我们只需要在 `stackOut` 为空的时候将 `stackIn` 的元素转移到 `stackOut`，以确保队列的顺序（先进先出）。

当你执行 `pop` 或 `peek` 操作时：

- **`pop` 方法**：我们需要弹出队列的头部元素。**如果 `stackOut` 不为空，说明还有元素在 `stackOut` 中（这些元素是最早被插入的）**。如果 `stackOut` 为空，才需要将 `stackIn` 中的所有元素转移到 `stackOut`，这样最早插入的元素就会到达 `stackOut` 的顶部，从而能够被弹出。
- **`peek` 方法**：我们需要查看队列的头部元素。同理，如果 `stackOut` 为空，才需要将 `stackIn` 中的元素转移到 `stackOut` 中，以确保我们查看的是最早被插入的元素。

在转换（`conversion`）过程中，将 `stackIn` 的元素依次弹出并压入 `stackOut`，这样最早进入 `stackIn` 的元素就会处于 `stackOut` 的顶部。













#### [03.05. 栈排序](https://leetcode.cn/problems/sort-of-stacks-lcci/)

中等

> 提示

栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：`push`、`pop`、`peek` 和 `isEmpty`。当栈为空时，`peek` 返回 -1。

**示例1:**

```
 输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
 输出：
[null,null,null,1,null,2]
```

**示例2:**

```
 输入： 
["SortedStack", "pop", "pop", "push", "pop", "isEmpty"]
[[], [], [], [1], [], []]
 输出：
[null,null,null,null,null,true]
```

**说明:**

1. 栈中的元素数目在[0, 5000]范围内。



##### 尝试一：辅助栈

```java
import java.util.Stack;

public class StackSort {
    private Stack<Integer> stack;
    private Stack<Integer> tempStack;

    StackSort() {
        stack = new Stack<>();
        tempStack = new Stack<>();
    }

    /**
     * push
     *
     * @param x 新增元素
     */
    public void push(int x) {
        while (!stack.isEmpty() && stack.peek() < x) tempStack.push(stack.pop());
        stack.push(x);
        while (!tempStack.isEmpty()) stack.push(tempStack.pop());
    }

    public Integer peek() {
        if (stack.isEmpty()) return -1;
        return stack.peek();
    }

    public Integer pop() {
        if (stack.isEmpty()) return -1;
        return stack.pop();
    }

    public Boolean isEmpty(){
        return stack.isEmpty();
    }
}
```



>最终代码

```java
/**
辅助栈
 */
class SortedStack {
    private Stack<Integer> stack;
    private Stack<Integer> tempStack;

    public SortedStack() {
        stack = new Stack<>();
        tempStack = new Stack<>();
    }

    public void push(int val) {
        // Move elements from stack to tempStack until the correct position is found
        while (!stack.isEmpty() && stack.peek() < val) {
            tempStack.push(stack.pop());
        }
        // Push the new value onto the main stack
        stack.push(val);
        // Move elements back from tempStack to stack
        while (!tempStack.isEmpty()) {
            stack.push(tempStack.pop());
        }
    }

    public void pop() {
        if (!stack.isEmpty()) {
            stack.pop();
        }
    }

    public int peek() {
        if (stack.isEmpty()) {
            return -1;
        }
        return stack.peek();
    }

    public boolean isEmpty() {
        return stack.isEmpty();
    }
}
```





















#### [03.06. 动物收容所](https://leetcode.cn/problems/animal-shelter-lcci/)

简单



> 提示

动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如`enqueue`、`dequeueAny`、`dequeueDog`和`dequeueCat`。允许使用Java内置的LinkedList数据结构。

`enqueue`方法有一个`animal`参数，`animal[0]`代表动物编号，`animal[1]`代表动物种类，其中 0 代表猫，1 代表狗。

`dequeue*`方法返回一个列表`[动物编号, 动物种类]`，若没有可以收养的动物，则返回`[-1,-1]`。

**示例1:**

```
 输入：
["AnimalShelf", "enqueue", "enqueue", "dequeueCat", "dequeueDog", "dequeueAny"]
[[], [[0, 0]], [[1, 0]], [], [], []]
 输出：
[null,null,null,[0,0],[-1,-1],[1,0]]
```

**示例2:**

```
 输入：
["AnimalShelf", "enqueue", "enqueue", "enqueue", "dequeueDog", "dequeueCat", "dequeueAny"]
[[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]
 输出：
[null,null,null,null,[2,1],[0,0],[1,0]]
```

**说明:**

1. 收纳所的最大容量为20000

------

通过率

58.0%



##### 思考一：利用linkedList

```java
/**80.38 + 60.29
 */
class AnimalShelf {
    private List<int[]> catList;
    private List<int[]> dogList;
    //用于给对应元素排序
    private int order;

    public AnimalShelf() {
        catList = new LinkedList();
        dogList = new LinkedList();
        order = 0;
    }
    
    public void enqueue(int[] animal) {
        //animal[1]代表动物种类,其中 0 代表猫,1 代表狗
        if(animal[1] == 0){
            catList.add(new int[]{animal[0], order++});
        }  
        else{
            dogList.add(new int[]{animal[0], order++});
        }
    }
    
    public int[] dequeueAny() {
        //前置判断
        if(catList.isEmpty() && dogList.isEmpty()) return new int[]{-1,-1};
        if(catList.isEmpty()) return dequeueDog();
        if(dogList.isEmpty()) return dequeueCat();
        //分别取出各自的第一个元素,并且对比order字段来判断谁优先
        int[] cat = catList.get(0);
        int[] dog = dogList.get(0);
        if(cat[1] < dog[1]){
            return dequeueCat();
        }else{
            return dequeueDog();
        }
    }
    
    public int[] dequeueDog() {
        //由于LinkedList对应只有remove方法,则每次remove第一个元素
        if(dogList.isEmpty()) return new int[]{-1,-1};
        int[] dog = dogList.remove(0);
        //保证返回的类型是狗
        return new int[]{dog[1] ,1};
    }
    
    public int[] dequeueCat() {
        if(catList.isEmpty()) return new int[]{-1,-1};
        int[] cat = catList.remove(0);
        //保证返回的数组类型是猫
        return new int[]{cat[0], 0}; 
    }
}
```













## 四、树与图













#### [04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/)

中等

> 提示



节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

**示例1:**

```
 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
 输出：true
```

**示例2:**

```
 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4
 输出 true
```

**提示：**

1. 节点数量n在[0, 1e5]范围内。
2. 节点编号大于等于 0 小于 n。
3. 图中可能存在自环和平行边。





##### 尝试一:邻接表+BFS

```java
/**32.64 + 83.98
邻接表(Adjacency List)：
    使用数组或链表的列表来表示图，每个节点都有一个链表，链表中存储与该节点相邻的所有节点。

搜索算法：
    1.深度优先搜索(DFS,Depth-First Search):一种用于遍历或搜索树或图的算法。
    沿着树的深度进行搜索，直到找到目标节点或访问完所有节点。
    2.广度优先搜索(BFS,Breadth-First Search):一种层次遍历或搜索图的算法。
    首先访问起始节点，然后依次访问与其直接相邻的所有节点。(此处显然使用邻接表 + BFS比较合适)。

思路：
    1.构建邻接表:
        使用邻接表来存储图的结构,邻接表是一个包含n个列表的列表，每个列表存储与该节点相邻的所有节点。
    2.初始化BFS:
        使用队列来进行广度优先搜索(BFS),从起始节点开始。
        使用集合来记录已经访问过的节点，以避免重复访问。
    3.开始搜索:
        将起始节点加入队列并标记为已访问。
        当队列不为空时，取出队首节点。
        检查是否为目标节点，如果是则返回`true`。
        否则，将该节点的所有未访问过的邻居节点加入队列并标记为已访问。
    4.结束搜索:
        如果队列为空且未找到目标节点，返回`false`。
 */
class Solution {
    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {
        //1.构建邻接表
        List<List<Integer>> pathList = new ArrayList();
        //初始化邻接表
        for(int i = 0; i < n; i++){
            pathList.add(new ArrayList());
        }
        //添加边到邻接表中
        for(int[] node : graph){
            pathList.get(node[0]).add(node[1]);
        }
        
        //BFS初始化
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> visited = new HashSet<>();

        //开始搜索
        queue.offer(start);//将起始节点加入队列
        visited.add(start);//标记起始节点为已访问

        while(!queue.isEmpty()){
            //取出队首节点,如果当前节点是目标节点,返回true
            int current = queue.poll();
            if(current == target) return true;
            //遍历当前节点的所有邻居节点
            for(int neighbor : pathList.get(current)){
                if(!visited.contains(neighbor)){
                    //将邻居节点加入队列，并标记其已访问
                    queue.offer(neighbor);
                    visited.add(neighbor);
                }
            }
        }  
        //如果队列为空,且未找到目标节点,返回false。
        return false;
    }
}
```







##### 思考



###### 1.解这道题，为什么要优先选用BFS,比起DFS有什么区别吗?



BFS VS DFS:

- **BFS(广度优先搜索)**
  1. 层次遍历：BFS逐层遍历节点，**先访问距离起点最近的节点。这意味着一旦找到目标节点，路径一定是最短路径。**
  2. 队列实现：使用队列来实现BFS，先进先出(FIFO)确保了节点按照它们被发现的顺序进行处理。
  3. 路径最短：**对于无权图(所有边权重相同)，BFS能保证找到的路径是最短的**。
- **DFS(深度优先搜索)**
  1. 深度遍历：**DFS沿着路径深入节点，直到不能再继续为止。然后回溯到最近的分叉点继续搜索。**
  2. 栈实现：可以使用递归(隐式栈)或者显示额栈来实现DFS。
  3. 路径不一定最短：DFS不保证找到的路径是最短的，尤其是在图的深度很深的时候，可能会走很多不必要的路径。

对于查找从起始节点到目标节点是否存在路径，尤其是当我们**希望找到最短路径时，BFS更适合**。因为它能在找到目标节点时，保证这条路径是最短的。





###### 2.为什么`if(current == target) return true;`不能写在`if(!visited.contains(neighbor)){}`内而是现在的位置？

> 原因在于

我们需要**在每次取出队列中的节点时就检查它是否是目标节点**。这么做有以下优势：

1. **更快地找到目标节点**：每次从队列中取出的节点都是当前层次最早发现的节点，立即检查可以尽早返回结果。
2. **避免多余的遍历**：如果目标节点已经是当前节点，我们可以立即返回`true`，避免了对其邻居节点的遍历和进一步的入队操作。

如果将检查条件放在`if(!visited.contains(neighbor)){}`内部，则需要访问目标节点的所有邻居后才能判断，这样可能会进行不必要的操作，降低效率。







###### 3.`for(int neighbor : pathList.get(current))`其中`pathList`是`ArrayList<Integer>`，为什么不能`Integer neighbor`？



实际上，`for(int neighbor : pathList.get(current))`可以写成`for(Integer neighbor : pathList.get(current))`。

在Java中，这两种写法其实是等价的，因为`int`类型会自动装箱`Integer`，而`Integer`类型会自动拆箱为`int`类型。

```java
for(Integer neighbor : pathList.get(current)) {
    // 你的代码
}
```

使用`Integer`类型的写法在某些情况下(如涉及到`null`值)会更安全，但在此代码中因为数据是从邻接表中获取的，通常不会有`null`值，所以两种写法没有实质区别。





###### 总结

1. 优先选择BFS是因为它能找到最短路径，检查条件放置在队列取出节点之后是为了提高效率。
2. `int neighbor`和`Integer neighbor`在功能上是等价的。











#### [04.02. 最小高度树](https://leetcode.cn/problems/minimum-height-tree-lcci/)

简单



> 提示



给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

          0 
         / \ 
       -3   9 
       /   / 
     -10  5 
```





##### 尝试一:递归

```java
/**100 + 49.65
思路:
    1.为了构建高度最小的BST,我们需要确保每个子树的高度尽量平衡。(选择数组的中间元素作为根节点)
    2.对于一个有序数组，最简单的方法时选择中间元素作为根节点，随后递归对左右子数组进行相同的操作。
递归:
    1.选取中间元素作为根节点:
        1.1.如果数组长度为奇数，则直接选中间元素mid。
        1.2.如果数组长度为偶数，则可以选择中偏左元素或者中偏右元素。这里选中偏左!
        1.3.由此可得mid = nums.length / 2。
    2.递归构建左右子树:
        2.1.以中间元素为界，数组左边部分递归构建左子树[0,mid]。
        2.2.数组右边部分递归构建右子树[mid + 1,length - 1]。
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        //前置判断
        if(nums == null || nums.length == 0) return null;
        return helper(nums, 0, nums.length - 1);
    }
    private TreeNode helper(int[] nums, int left, int right){
        if(left > right) return null;
        //选择中间元素作为根节点
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        //递归构建左子树和右子树(记得不要将root元素算进去)
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums,mid + 1,right);
        return root;
    }
}
```





##### 思考



###### 1. `if(left > right) return null;` 为什么不能取 `>=` 呢？

在递归的过程中，`left`和`right`指示当前子数组的边界。**当`left == right`时，子数组仍然包含一个元素，这是有效的，需要继续处理**。

> 所以

- `left > right`表示当前子数组无效，不再有元素处理，此时应返回`null` 。
- `left == right`表示当前子数组有一个元素，可以创建一个叶子节点。





>举例说明



对数组`[-10, -3, 0, 5, 9]`：

- 当递归到`nums[0,0]`(即只包含`-10`)，此时`left == right`，应返回`TreeNode(-10)`而不是`null`。



注：如果用`>=`，==**当`left == right`时，会直接返回`null`，就会漏掉一个元素**==。





###### 2. `int mid = left + (right - left) / 2;` 为什么要这样取？

计算中间索引的方式 `mid = left + (right - left) / 2` 是为了**避免整数溢出**问题。具体原理如下：

- 假如直接使用 `mid = (left + right) / 2`，当 `left` 和 `right` 都很大时，`left + right` 可能会超过 `int` 类型的上限，导致溢出。
- 通过 `mid = left + (right - left) / 2`，将计算的最大值限制在 `right` 范围内，避免溢出。





###### 3.为什么最终接收的 `root` 就是满足题意的 `root`？

>递归的关键在于分而治之，确保每次调用都正确地处理当前子数组，然后组合成完整的树。

具体步骤如下：

1. **选择根节点**：
   - 每次递归调用中，计算当前子数组的中间元素作为根节点。
2. **构建子树**：
   - 递归调用`helper`函数，分别处理左半部分和右半部分，构建左子树和右子树。
3. **返回根节点**：
   - **每次递归调用返回当前子树的根节点**，**将左子树和右子树连接到根节点上**。



最终，递归的最外层调用返回完整的子树根节点。每一层递归确保子树高度尽量平衡，从而满足构建最小高度BST的要求。









#### [04.03. 特定深度节点链表](https://leetcode.cn/problems/list-of-depth-lcci/)

中等

> 提示



给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 `D`，则会创建出 `D` 个链表）。返回一个包含所有深度的链表的数组。

 

**示例：**

```
输入：[1,2,3,4,5,null,7,8]

        1
       /  \ 
      2    3
     / \    \ 
    4   5    7
   /
  8

输出：[[1],[2,3],[4,5,7],[8]]
```

通过率

80.8%



##### 尝试一:BFS

```java
/**100 + 86.65
思路(二叉树层序遍历):
    要解决这个问题，需要遍历二叉树，并且在每一次上将该层的所有节点存储到一个链表中。
最后，将每一层的链表存储到一个数组中，并返回这个数组。

问题分析：
    1.二叉树的层序遍历：
        可以使用广度优先搜索(BFS)来遍历二叉树的每一层。BFS是一种逐层遍历节点的算法，非常适合本场景。
        在BFS中，使用一个队列来存储每一层的节点。首先将根节点放入队列，然后依次处理队列中的每一个节点，将其子节点加入队列，这样就能逐层遍历二叉树。
    2.创建链表：
        在遍历每一层节点时，将每一个节点的值存储到一个链表中。这样每一层都会对应一个链表，链表中的节点顺序与树中节点的层次顺序一致。
    3.结果数组：
        每遍历完一层，创建的链表都会存储在结果数组中。最后，返回这个数组。

步骤分解：
    1.创建一个队列，用于层序遍历。
    2.对于每一层：
        创建一个新的链表来存储该层的所有节点。
        遍历当前层的所有节点，将它们的值存储到链表中，同时将它们的子节点加入队列。
        将该层的链表存储到结果数组中。
    3.重复上述过程直至队列为空(即遍历完所有层)。
    4.返回包含所有链表的结果数组。
 */
class Solution {
    public ListNode[] listOfDepth(TreeNode tree) {
        //前置判断
        if(tree == null) return new ListNode[0];
        //使用队列来进行层序遍历,首先将根节点加入队列
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(tree);
        //用于存储结果的列表
        List<ListNode> resultList = new ArrayList<>();
        //重复上述过程直至队列为空(即遍历完所有层)
        while(!queue.isEmpty()){
            //当前层的节点数
            int size = queue.size();
            //创建一个虚拟头节点和指针，指针指向头节点方便操作
            ListNode head = new ListNode(0);
            ListNode currentNode = head;
            for(int i = 0;i < size;i++){
                //从队列中遍历出当前层的每个节点
                TreeNode node = queue.poll();
                //收集当前节点值，创建相同链表节点加入链表
                currentNode.next = new ListNode(node.val);
                currentNode = currentNode.next;
                //将子节点加入到队列，以备下次遍历使用
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            //收入结果集(最开始创建链表时的虚拟节点是无效节点)
            resultList.add(head.next);
        }
        // 将结果列表转换为数组返回
        return resultList.toArray(new ListNode[resultList.size()]);
    }
}
```







#### [04.04. 检查平衡性](https://leetcode.cn/problems/check-balance-lcci/)

简单

> 提示



实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。


**示例 1:**

```
给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

**示例 2:**

```
给定二叉树 [1,2,2,3,3,null,null,4,4]
      1
     / \
    2   2
   / \
  3   3
 / \
4   4
返回 false 。
```

------

通过率

60.0%





##### 尝试一:后序遍历

```java
/**100 + 63.01
问题分析:
    1.定义平衡二叉树的条件时：任意节点的左右子树高度不超过1。
    2.为了检查这一条件，可采用递归的方式从下至上检查每个节点的左右子树高度差。
    3.同事也可以在遍历的过程中判断子树是否平衡。
后序遍历：
    1.为什么选后序:左子、右子,再当前。这种顺序使得在处理当前节点时,左右子树高度已经计算完成(直接得出是否平衡,从子节点向上回溯)。
    2.定义一个辅助函数`checkBalance`,它返回当前子树高度。
    3.如果子树不平衡(相差 > 1),则返回- 1。
    4.在这样遍历的过程中,可以直接判断整个树是否平衡。
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        // 调用辅助函数检查树的平衡性
        return checkBalance(root) != -1;
    }
    /**
     * 辅助函数，返回子树的高度。如果子树不平衡，返回-1。
     */
    private int checkBalance(TreeNode node){
        // 空树的高度为0，且空树是平衡的
        if(node == null) return 0;
        int left = checkBalance(node.left);
        int right = checkBalance(node.right);
        // 如果左,右子树不平衡 || 左右子树高度差是否超过1,直接返回-1
        if(left == -1 || right == -1 || Math.abs(left - right) > 1) return -1;
        //如果当前节点平衡，返回子树的最大高度还需要 + 1(还需包含当前节点高度1)
        return Math.max(left, right) + 1; 
    }
}
```







#### [04.05. 合法二叉搜索树](https://leetcode.cn/problems/legal-binary-search-tree-lcci/)

中等

> 提示





实现一个函数，检查一棵二叉树是否为二叉搜索树。

**示例 1:**

```
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```





##### 尝试一:递归

```java
/**100 + 10.60
题意解析:
    1.对于每个节点，其左子树的所有节点值必须小于当前节点值。
    2.右子树的所有节点值必须大于当前节点值。
    3.左右子树也必须满足二叉搜索树的性质。

注:
    作为一个二叉搜索树，并不是说每个节点都满足left.val <= current.val < right就够了。
左边的每个节点必须小于当前节点，该节点还必须要小于右边的所有节点。

思路:
    1.递归法是解决这个问题的一个常用方法。我们可以利用递归来遍历树的每个节点，并验证每个节点是否符合BST的性质。
    2.对于当前节点:
        它的值current.val必须 > 下界min, current.val < 上界max。
        递归检查左子树时，更新上界为当前current.val。
        递归检查右子树时，更新下界为当前节点值。
    3.通过这种方式，我们确保每个节点的值都符合BST的要求。
    
 */
public class Solution {
    // 主函数，判断给定的二叉树是否为合法的二叉搜索树
    public boolean isValidBST(TreeNode root) {
        // 调用递归函数，初始上下界为 null（无穷大/小）
        return validate(root, null, null);
    }

    // 递归函数：检查当前节点是否在给定的上下界范围内
    private boolean validate(TreeNode node, Integer min, Integer max) {
        // 空节点返回 true（空树也是合法 BST）
        if (node == null) {
            return true;
        }

        // 检查当前节点值是否在上下界范围内
        if (min != null && node.val <= min) {
            return false; // 节点值不应小于等于下界
        }
        if (max != null && node.val >= max) {
            return false; // 节点值不应大于等于上界
        }

        // 递归检查左子树和右子树
        // 左子树的所有节点值必须小于当前节点值（更新上界为当前节点值）
        // 右子树的所有节点值必须大于当前节点值（更新下界为当前节点值）
        return validate(node.left, min, node.val) && validate(node.right, node.val, max);
    }
}
```







#### [04.06. 后继者](https://leetcode.cn/problems/successor-lcci/)

中等

> 提示



设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。

如果指定节点没有对应的“下一个”节点，则返回`null`。

**示例 1:**

```
输入: root = [2,1,3], p = 1

  2
 / \
1   3

输出: 2
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], p = 6

      5
     / \
    3   6
   / \
  2   4
 /   
1

输出: null
```

------



> 通过率

62.5%



##### 尝试一：中序递归(未通过)

```java
/**
中序遍历:
    1.递归方法checkP(root,p);进行递归。
    2.前置判断是否当前节点是否为null,如果为null则return null。
    3.拿到当前节点current.left节点判断是否==p节点,如果=直接return current。
    4.继续递归,若找不到结果则return null。
 */
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        return checkP(root, p);
    }
    /**
    检查目标节点递归方法
     */
    private TreeNode checkP(TreeNode current,TreeNode target){
        //前置判断
        if(current == null) return null;
        TreeNode left = current.left;
        TreeNode right = current.right;
        //当前节点为目标节点时则返回右子节点,左子节点=目标节点的时候则当前节点为最终结果。
        if(current == target) return right;
        if(left == target) return current;
        //递归左,右子节点
        checkP(left, target);
        checkP(right, target);
        return null;
    }
}
/**
解答错误
11 / 24 个通过的测试用例

官方题解
输入
root =
[5,3,6,2,4,null,null,1]
        5
       / \
      3   6
     / \
    2   4
   /
  1
p =
1

添加到测试用例
输出
null
预期结果
2
 */
```

>分析原因

**递归逻辑问题**：在你的递归方法 `checkP` 中，虽然你检查了当前节点是否为目标节点，但没有正确处理目标节点的后继查找。你只返回了右子树，但并没有考虑如何找到右子树中的最左节点。

**返回值未处理**：你的 `checkP` 方法在递归后并没有处理返回值，因此如果目标节点的后继不在左子树中，最终会返回 null，而不是正确的后继节点。

**缺少逻辑判断**：你没有考虑当当前节点是目标节点，但有右子树的情况。这是找到后继的关键。





> 修正后的代码

```java
/**100% + 58.82%

 */
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        // 首先检查节点 p 是否有右子树
        if (p.right != null) {
            // 如果有，返回右子树中的最左节点
            return getMinNode(p.right);
        }

        // 如果没有右子树，从根节点开始遍历
        TreeNode successor = null;
        while (root != null) {
            // 如果当前节点值大于 p 的值，当前节点可能是后继
            if (root.val > p.val) {
                successor = root; // 更新后继节点
                root = root.left; // 继续向左查找
            } else {
                // 如果当前节点值小于等于 p 的值，向右子树查找
                root = root.right;
            }
        }
        return successor; // 返回找到的后继节点
    }

    /**
     * 找到树中最左边的节点
     * @param node 需要查找的节点
     * @return 最左边的节点
     */
    private TreeNode getMinNode(TreeNode node) {
        // 循环找到最左的节点
        while (node.left != null) {
            node = node.left;
        }
        return node; // 返回最左节点
    }
}
```







#### [04.08. 首个共同祖先](https://leetcode.cn/problems/first-common-ancestor-lcci/)

中等

> 提示



设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

```
    3
   / \
  5   1
 / \ / \
6  2 0  8
  / \
 7   4
```

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

**说明:**

```
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。
```

通过率

71.6%



##### 方式一:递归

```java
/**30.56 + 73.63
一、问题理解
    1.要在二叉树中找到两个给定节点p和q的最近公共祖先。
    2.最近公共祖先定义为：从根节点到节点p和q的路径上，最靠近它们的那个公共节点。
二、基本思路
    1.使用递归遍历二叉树，从根节点开始向下查找p和q。
    2.对于每个节点判断其左子树和右子树是否包含p和q，从而确定当前current节点是否为最近公共祖先。
递归:
    1.终止条件：如果当前节点root是null或者p或q，直接返回 root，表示找到了目标节点（或已到达空节点）。
    2.递归查找：
        递归调用左子树 lowestCommonAncestor(root.left, p, q)，获取 left。
        递归调用右子树 lowestCommonAncestor(root.right, p, q)，获取 right。
    3.判断返回结果:
        如果左右子树都非空，即 left != null && right != null，说明 p 和 q 分别在当前节点的左右子树中，因此当前节点 root 是最近公共祖先。
        如果只有一侧子树非空，说明 p 和 q 都在该子树中，返回该子树的结果。
    4.时间/空间复杂度:
        时间复杂度：O(n)因为每个节点都被访问一次。
        空间复杂度：O(h)其中h是树的高度，用于递归调用栈的空间。
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q){
            return root;
        }
        
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if(left != null && right != null) return root;
        return left != null ? left : right;
    }
}
```

















