?

#### [04.09. 二叉搜索树序列](https://leetcode.cn/problems/bst-sequences-lcci/)

> 困难



> 提示



从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。

给定一个由**不同节点**组成的二叉搜索树 `root`，输出所有可能生成此树的数组。

 

**示例 1:**

```
输入: root = [2,1,3]
输出: [[2,1,3],[2,3,1]]
解释: 数组 [2,1,3]、[2,3,1] 均可以通过从左向右遍历元素插入树中形成以下二叉搜索树
       2 
      / \ 
     1   3
```



**示例** **2:**

```
输入: root = [4,1,null,null,3,2]
输出: [[4,1,3,2]]
```

 

**提示：**

- 二叉搜索树中的节点数在 `[0, 1000]` 的范围内
- `1 <= 节点值 <= 10^6`
- 用例保证符合要求的数组数量不超过 `5000`



##### 尝试一:拆分

> 由于此题有些难度，故此，拆分为几个主要的部分分而治之。



###### 1.





##### 尝试二：递归+回溯

###### 1.问题分析

给定一棵二叉搜索树（BST），要求输出所有可能的插入顺序，能够重建出原树的结构。

###### 二叉搜索树的特性

1. **左子树**的所有节点都比当前节点小。
2. **右子树**的所有节点都比当前节点大。
3. 递归地，左子树和右子树也必须满足以上规则。

###### 核心思想

这个问题实际上就是从不同的插入顺序中找出能够重建原始树的所有可能方式。我们可以通过递归的方法来处理这个问题：

- 假设我们有一个根节点，它有两个子树：左子树和右子树。我们知道左子树的节点必须出现在根节点的前面，而右子树的节点必须在根节点的后面。
- 关键是：我们只需要知道如何将 **左子树的序列** 和 **右子树的序列** 按照二叉树的特性合并在一起，就可以生成所有可能的插入顺序。

------

###### 具体步骤解析

1. **递归分解**
   - 如果树为空（`null`），则返回一个包含一个空序列的列表，表示没有元素可以插入。
   - 如果树不为空：
     - 将当前节点的值（`root.val`）作为序列的第一个元素。
     - 递归地获取左子树和右子树的所有可能序列。
2. **合并左右序列**
   - 对于每一对左子树的序列和右子树的序列，我们需要将它们合并成一个新的序列。每次合并时，**必须保证左子树的元素出现在右子树的元素之前**，即，左子树的元素必须在前。
   - **合并方法**：假设我们有两个列表，分别表示左子树的序列 `left` 和右子树的序列 `right`。我们可以通过递归的方式交错地将它们合并：
     - 每次从左序列或右序列中取一个元素，并将它加到当前的序列中，然后递归处理剩下的元素。
     - 直到某一方序列为空时，我们可以将另一个序列的剩余部分直接添加到结果中。
3. **回溯的使用**
   - 交错合并时，每次选择从左序列或右序列取一个元素并递归地合并。这时就使用了回溯的思想。
   - 具体来说，在递归过程中，我们需要回退，恢复原来的状态，再进行另一种选择。
4. **最终结果**
   - 对于每个递归步骤，我们将左子树和右子树的所有序列交错合并，最后返回所有可能的序列。

------

###### 举个简单的例子

假设我们有如下的二叉树：

```
    2
   / \
  1   3
```

我们需要输出所有可能生成这棵树的数组：

1. 根节点是 `2`。
2. 左子树的所有序列：[1]
3. 右子树的所有序列：[3]

从而可以生成的两种插入顺序是：

- `[2, 1, 3]`
- `[2, 3, 1]`

这两种插入顺序都能够生成与原始树结构相同的二叉搜索树。

------



###### 代码的具体推理

1. **递归调用**：通过 `BSTSequences(root)` 方法，我们分别处理左子树和右子树。
2. **合并子树序列**：使用 `weaveLists` 方法交错合并左子树和右子树的序列。
3. **回溯处理**：在合并过程中，移除元素时使用回溯（恢复状态），然后继续尝试另一种合并方式。

------



###### 重要概念回顾

- **递归**：递归帮助我们处理树的结构，分解为子问题。
- **回溯**：在处理子问题时，回溯允许我们恢复之前的状态，以便尝试不同的选择。
- **交错合并**：我们需要将左子树和右子树的序列交错合并，以保证二叉搜索树的结构。

------



###### 总结

1. 对于每个节点，我们只需要确保左子树的元素在右子树的元素之前插入，并且递归处理每个子树的序列。
2. 通过递归和交错合并的方法，可以生成所有可能的插入顺序。
3. 这类题目需要一定的递归和回溯的思维技巧，理解了这两者的结合后，就能轻松解决类似问题。

希望这个总结能帮助你更好地理解整个过程！





###### 实现代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

import java.util.*;

class Solution {
    // 主方法：返回所有可能生成该二叉搜索树的序列
    public List<List<Integer>> BSTSequences(TreeNode root) {
        // 如果根节点为空，返回一个空序列
        if (root == null) {
            List<List<Integer>> result = new ArrayList<>();
            result.add(new ArrayList<>());
            return result;
        }

        // 最终结果列表
        List<List<Integer>> result = new ArrayList<>();

        // 前缀序列，包含当前的根节点值
        List<Integer> prefix = new LinkedList<>();
        prefix.add(root.val);

        // 递归获取左子树和右子树的所有可能序列
        List<List<Integer>> leftSeq = BSTSequences(root.left);
        List<List<Integer>> rightSeq = BSTSequences(root.right);

        // 遍历左右子树的所有序列，进行交错合并
        for (List<Integer> left : leftSeq) {
            for (List<Integer> right : rightSeq) {
                List<List<Integer>> weaved = new ArrayList<>();
                // 交错合并左右序列
                weaveLists(left, right, weaved, prefix);
                // 将合并结果加入最终结果中
                result.addAll(weaved);
            }
        }

        return result;
    }

    // 辅助方法：交错合并两个序列
    private void weaveLists(List<Integer> left, List<Integer> right, List<List<Integer>> result, List<Integer> prefix) {
        // 如果左序列或右序列为空，将剩余序列加到结果中
        if (left.isEmpty() || right.isEmpty()) {
            List<Integer> res = new LinkedList<>(prefix);
            res.addAll(left);
            res.addAll(right);
            result.add(res);
            return;
        }

        // 从左序列取第一个元素，递归处理剩余部分
        int headLeft = left.remove(0);
        prefix.add(headLeft);
        weaveLists(left, right, result, prefix);
        prefix.remove(prefix.size() - 1);
        left.add(0, headLeft);

        // 从右序列取第一个元素，递归处理剩余部分
        int headRight = right.remove(0);
        prefix.add(headRight);
        weaveLists(left, right, result, prefix);
        prefix.remove(prefix.size() - 1);
        right.add(0, headRight);
    }
}
```

