
---













算法与数据结构
===







树
---





### 相关算法



#### (1).递归

递归使一种算法设计技术，它让函数在其定义中调用自己。

通过一系列的图像来展示递归构建二叉树的过程。我们将从一个有序数组开始，并逐步构建一棵高度最小的二叉搜索树。

假设我们有一个有序数组：[1, 2, 3, 4, 5, 6, 7]

##### 第一步：选择中间元素作为根节点

首先，我们选择数组的中间元素作为根节点。在这种情况下，4 是中间元素。

```
      4
     / \
```

##### 第二步：递归构建左子树

对于左子树，我们将数组左半部分（[1, 2, 3]）继续递归。

###### 选择中间元素 2 作为左子树的根节点

```
      4
     / \
    2   
   / \
```

###### 递归构建 2 的左子树（数组 [1]）

1 是中间元素，作为左子树的根节点。

```
      4
     / \
    2   
   / \
  1   
```

###### 递归构建 2 的右子树（数组 [3]）

3 是中间元素，作为右子树的根节点。

```
      4
     / \
    2   
   / \
  1   3
```

##### 第三步：递归构建右子树

对于右子树，我们将数组右半部分（[5, 6, 7]）继续递归。

###### 选择中间元素 6 作为右子树的根节点

```
      4
     / \
    2   6
   / \ / \
  1   3
```

###### 递归构建 6 的左子树（数组 [5]）

5 是中间元素，作为左子树的根节点。

```
      4
     / \
    2   6
   / \ / \
  1   3 5
```

###### 递归构建 6 的右子树（数组 [7]）

7 是中间元素，作为右子树的根节点。

```
      4
     / \
    2   6
   / \ / \
  1   3 5  7
```

这样，我们就完成了整个二叉搜索树的构建。以下是每一步的图示：

1. **初始数组和选择中间元素作为根节点：**

   

   

   

2. **构建左子树：**

   

   

   

3. **构建右子树：**

   

   

   

通过这几步递归地选择中间元素，我们最终得到了高度最小的二叉搜索树。







### 1.二叉树



#### (1).二叉搜索树(BST)

对于BST中的每个节点，其左子树中的所有节点值都小于该节点值，其右子树中的所有节点值都大于该节点值。
$$
左子树的节点值 < 当前节点值 < 右子树的所有节点值
$$












四、图
---



### 1.基础概念







### 2.表示方法





#### 邻接表

邻接表是一种图的表示方法，它使用一个列表来存储每个节点的邻居节点。相比邻接矩阵，邻接表更节省空间，尤其是在稀疏图的情况下。下面我们将基于您提供的代码示例，使用邻接表来实现无向图的表示和遍历。





##### 示例代码

```java
import java.util.*;

/**
 * @author: LiHao
 * @program: interview
 * @description: 无向图G1的邻接表表示，遍历边的方法
 * @Date: 2024-06-20-19:12:31
 */
public class GraphG1FromAdjList {
    public static void main(String[] args) {
        // 定义图G1的邻接矩阵
        int[][] adjMatrix = {
                {0, 1, 0, 0, 1},
                {1, 0, 1, 1, 1},
                {0, 1, 0, 1, 0},
                {0, 1, 1, 0, 1},
                {1, 1, 0, 1, 0}
        };

        // 将邻接矩阵转换为邻接表
        Map<Integer, List<Integer>> adjList = convertToAdjList(adjMatrix);

        // 打印邻接表
        printAdjList(adjList);

        // 提取边列表
        List<int[]> edges = extractEdges(adjList);

        // 打印边列表
        System.out.println("图 G1 的边列表:");
        for (int[] edge : edges) {
            System.out.println("(" + edge[0] + "," + edge[1] + ")");
        }
    }

    /**
     * 将邻接矩阵转换为邻接表
     *
     * @param adjMatrix 邻接矩阵
     * @return 邻接表
     */
    public static Map<Integer, List<Integer>> convertToAdjList(int[][] adjMatrix) {
        Map<Integer, List<Integer>> adjList = new HashMap<>();
        for (int i = 0; i < adjMatrix.length; i++) {
            adjList.put(i, new ArrayList<>());
            for (int j = 0; j < adjMatrix[i].length; j++) {
                if (adjMatrix[i][j] == 1) {
                    adjList.get(i).add(j);
                }
            }
        }
        return adjList;
    }

    /**
     * 从邻接表中提取边列表
     *
     * @param adjList 邻接表
     * @return 边列表
     */
    public static List<int[]> extractEdges(Map<Integer, List<Integer>> adjList) {
        List<int[]> edges = new ArrayList<>();
        for (int node : adjList.keySet()) {
            for (int neighbor : adjList.get(node)) {
                if (node < neighbor) { // 只添加一次边，避免重复
                    edges.add(new int[]{node, neighbor});
                }
            }
        }
        return edges;
    }

    /**
     * 打印邻接表
     *
     * @param adjList 邻接表
     */
    public static void printAdjList(Map<Integer, List<Integer>> adjList) {
        System.out.println("图 G1 的邻接表表示:");
        for (int node : adjList.keySet()) {
            System.out.print(node + ": ");
            for (int neighbor : adjList.get(node)) {
                System.out.print(neighbor + " ");
            }
            System.out.println();
        }
    }
}
```

1. **convertToAdjList**:
    - 将邻接矩阵转换为邻接表。
    - 遍历邻接矩阵中的每一个元素，如果`adjMatrix[i][j] == 1`，则表示节点`i`和节点`j`之间有边连接，将`j`添加到`i`的邻居列表中。
2. **extractEdges**:
    - 从邻接表中提取所有边。
    - 遍历每个节点的邻居列表，并且只添加`node < neighbor`的边，避免重复添加无向图的边。
3. **printAdjList**:
    - 打印邻接表的内容。



> 输出结果

```
图 G1 的邻接表表示:
0: 1 4 
1: 0 2 3 4 
2: 1 3 
3: 1 2 4 
4: 0 1 3 
图 G1 的边列表:
(0,1)
(0,4)
(1,2)
(1,3)
(1,4)
(2,3)
(3,4)
```











#### 邻接矩阵











### 3.相关算法





#### DFS(深度优先搜索)



##### 基本概念

- 深度优先搜索是一种用于遍历或搜索图或树数据结构的算法。
- 从起始节点开始，沿着某条路径尽可能深的搜索下去，直到不能再前进为止，然后回溯到前一个节点，继续搜索下一条路径。



##### 示例代码



###### 使用递归实现

```java
import java.util.*;

class DFSExample {
    public static void main(String[] args) {
        // 创建图的邻接表表示
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(0, Arrays.asList(1, 2));
        graph.put(1, Arrays.asList(2));
        graph.put(2, Arrays.asList(0, 3));
        graph.put(3, Arrays.asList(3));

        // 调用DFS
        boolean result = dfs(graph, 2, 1);
        System.out.println("是否存在路径: " + result);
    }

    public static boolean dfs(Map<Integer, List<Integer>> graph, int start, int target) {
        Set<Integer> visited = new HashSet<>();
        return dfsHelper(graph, start, target, visited);
    }

    private static boolean dfsHelper(Map<Integer, List<Integer>> graph, int current, int target, Set<Integer> visited) {
        if (current == target) {
            return true;
        }
        visited.add(current);
        for (int neighbor : graph.getOrDefault(current, new ArrayList<>())) {
            if (!visited.contains(neighbor)) {
                if (dfsHelper(graph, neighbor, target, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

**代码说明**:

- `graph`是图的邻接表表示，用于存储每个节点和它的邻居节点。
- `dfs`函数初始化一个`visited`集合来记录访问过的节点，并调用`dfsHelper`函数。
- `dfsHelper`是递归函数，从当前节点开始搜索，如果当前节点是目标节点，返回`true`。否则，继续递归搜索其邻居节点。





#### BFS(广度优先搜索)



##### 基本概念

- 广度优先搜索是一种用于遍历或搜索图或树数据结构的算法。
- 从起始节点开始，首先访问所有相邻节点，然后再访问这些相邻节点的相邻节点，依此类推，逐层搜索。





##### 示例代码

```java
import java.util.*;

class BFSExample {
    public static void main(String[] args) {
        // 创建图的邻接表表示
        Map<Integer, List<Integer>> graph = new HashMap<>();
        graph.put(0, Arrays.asList(1, 2));
        graph.put(1, Arrays.asList(2));
        graph.put(2, Arrays.asList(0, 3));
        graph.put(3, Arrays.asList(3));

        // 调用BFS
        boolean result = bfs(graph, 2, 1);
        System.out.println("是否存在路径: " + result);
    }

    public static boolean bfs(Map<Integer, List<Integer>> graph, int start, int target) {
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> visited = new HashSet<>();

        queue.offer(start);
        visited.add(start);

        while (!queue.isEmpty()) {
            int current = queue.poll();
            if (current == target) {
                return true;
            }
            for (int neighbor : graph.getOrDefault(current, new ArrayList<>())) {
                if (!visited.contains(neighbor)) {
                    queue.offer(neighbor);
                    visited.add(neighbor);
                }
            }
        }

        return false;
    }
}
```

**代码说明**:

- `graph`是图的邻接表表示，用于存储每个节点和它的邻居节点。
- `bfs`函数使用队列`queue`来进行广度优先搜索，并使用集合`visited`记录访问过的节点。
- 将起始节点加入队列和`visited`集合，然后依次访问队列中的节点，如果当前节点是目标节点，返回`true`。否则，将其邻居节点加入队列和`visited`集合。





### 3.总结



> 图的算法中主要用到的就是DFS和BFS：

- **DFS**适用于需要**访问图中的每一个节点的情况**，例如**检测图中是否有环**。
- **BFS**适用于寻找**最短路径**的情况，例如**在无权图中寻找两个节点之间的最短路径**。































































