

图(Graph)
===



> 相关视频链接：

​	https://www.bilibili.com/video/BV1D5411c71o/?spm_id_from=333.337.search-card.all.click&vd_source=1417dbca37956548f440924ee6faaa76



在图论中，图（Graph）是一种数学结构，用于描述一组对象之间的关系。图分为有向图（Directed Graph）和无向图（Undirected Graph）。表示图的方法有多种，最常用的是邻接矩阵和邻接表。下面将详细阐述图的算法以及图的表示方法，并提供相应的代码示例。



### 图的基本概念

1. **图（Graph）**：由顶点（Vertices）和边（Edges）构成。
2. **无向图（Undirected Graph）**：边没有方向。
3. **有向图（Directed Graph）**：边有方向。
4. **邻接矩阵（Adjacency Matrix）**：使用二维数组表示图。
5. **邻接表（Adjacency List）**：使用链表数组表示图。







#### 无向图





##### (1)不带权无向图



![](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202406191939104.png)





##### (2)带权无向图



![image-20240619194112248](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202406191941424.png)

- **不连通顶点之间的边权重是正无穷**：表示两顶点之间无法到达！
- 对角线位置**值是0**：表示某顶点到自己的边长是0。







#### 有向图







##### (1).不带权有向图





![image-20240612194716749](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202406121947961.png)











### 图的算法

1. **遍历算法**：
   - 深度优先搜索（Depth First Search, DFS）
   - 广度优先搜索（Breadth First Search, BFS）
2. **最短路径算法**：
   - Dijkstra算法
   - Bellman-Ford算法
   - Floyd-Warshall算法
3. **最小生成树算法**：
   - Prim算法
   - Kruskal算法
4. **拓扑排序**（适用于有向无环图）：
   - Kahn算法
   - DFS算法













### 邻接表表示方法

邻接表是一种常用的图表示方法，适合稀疏图。每个顶点对应一个链表，链表中的节点表示与该顶点相连的其他顶点。



#### (1)无向图的邻接表表示

```java
import java.util.LinkedList;
import java.util.List;

class Graph {
    private int vertices; // 顶点数
    private List<Integer>[] adjList; // 邻接表

    public Graph(int vertices) {
        this.vertices = vertices;
        adjList = new LinkedList[vertices];
        for (int i = 0; i < vertices; i++) {
            adjList[i] = new LinkedList<>();
        }
    }

    // 添加边
    public void addEdge(int src, int dest) {
        adjList[src].add(dest);
        adjList[dest].add(src); // 无向图添加双向边
    }

    // 打印邻接表
    public void printGraph() {
        for (int i = 0; i < vertices; i++) {
            System.out.print("Vertex " + i + ":");
            for (Integer vertex : adjList[i]) {
                System.out.print(" -> " + vertex);
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Graph graph = new Graph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);

        graph.printGraph();
    }
}
```





#### (2)有向图的邻接表表示

```java
import java.util.LinkedList;
import java.util.List;

class DirectedGraph {
    private int vertices; // 顶点数
    private List<Integer>[] adjList; // 邻接表

    public DirectedGraph(int vertices) {
        this.vertices = vertices;
        adjList = new LinkedList[vertices];
        for (int i = 0; i < vertices; i++) {
            adjList[i] = new LinkedList<>();
        }
    }

    // 添加边
    public void addEdge(int src, int dest) {
        adjList[src].add(dest); // 有向图添加单向边
    }

    // 打印邻接表
    public void printGraph() {
        for (int i = 0; i < vertices; i++) {
            System.out.print("Vertex " + i + ":");
            for (Integer vertex : adjList[i]) {
                System.out.print(" -> " + vertex);
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        DirectedGraph graph = new DirectedGraph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);

        graph.printGraph();
    }
}
```







### 邻接矩阵表示方法

邻接矩阵使用一个二维数组表示图，适合稠密图。



#### (1)无向图的邻接矩阵表示

示例图()：

![image-20240619194633334](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202406191946453.png)

- 此无向图的邻接矩阵表示是以0-0,1-1,2-2之间的对角线对称的。



##### G1示例代码

```java
public class GraphG1 {

    public static void main(String[] args) {
        // 定义图 G1 的顶点数量
        int n = 5;

        // 初始化一个 n x n 的零矩阵
        int[][] adjMatrix = new int[n][n];

        // 定义图 G1 的边
        int[][] edges = {
            {0, 1},
            {0, 4},
            {1, 2},
            {1, 3},
            {1, 4},
            {2, 3},
            {3, 4}
        };

        // 遍历所有边并填充邻接矩阵
        for (int[] edge : edges) {
            int i = edge[0]; // 获取边的第一个顶点
            int j = edge[1]; // 获取边的第二个顶点
            adjMatrix[i][j] = 1; // 设置矩阵中的对应位置为1，表示有边相连
            adjMatrix[j][i] = 1; // 因为是无向图，对称位置也要设置为1
        }

        // 打印邻接矩阵
        System.out.println("图 G1 的邻接矩阵表示:");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(adjMatrix[i][j] + " ");
            }
            System.out.println(); // 换行
        }
    }
}
```

代码解释：

1. **定义顶点数量**：`int n = 5;` 表示图 G1 有 5 个顶点。
2. **初始化邻接矩阵**：`int[][] adjMatrix = new int[n][n];` 创建一个 5x5 的矩阵，初始值都为0。
3. **定义边列表**：`int[][] edges = {...};` 使用一个二维数组定义图的所有边。
4. **填充邻接矩阵**：遍历边列表，对应位置设置为1，表示顶点之间有边相连。因为是无向图，矩阵是对称的，因此同时设置 `adjMatrix[i][j]` 和 `adjMatrix[j][i]`。
5. **打印邻接矩阵**：嵌套循环遍历矩阵，逐行打印。



运行该代码将输出图 G1 的邻接矩阵：

```
0 1 0 0 1 
1 0 1 1 1 
0 1 0 1 0 
0 1 1 0 1 
1 1 0 1 0 
```

这表示了图 G1 中各个顶点之间的连接关系。







##### 边说明

对于无向图的邻接矩阵，`adjMatrix[i][j] == 1` 表示顶点 `i` 和顶点 `j` 之间有边相连。因为无向图的邻接矩阵是对称的，所以如果 `adjMatrix[i][j] == 1`，则 `adjMatrix[j][i] == 1` 也必然为 1。

根据给定的邻接矩阵：

```
0 1 0 0 1
1 0 1 1 1
0 1 0 1 0
0 1 1 0 1
1 1 0 1 0
```

有边相连的元素如下（包括对称位置）：

```bash
[0][1], [0][4], 
[1][0], [1][2], [1][3], [1][4], 
[2][1], [2][3], 
[3][1], [3][2], [3][4], 
[4][0], [4][1], [4][3]
```

为了**==确保边的列表只包含一次每个边对==**（例如 **`[0][1]` 和 `[1][0]` 只算一次**），**通常只遍历邻接矩阵的上三角部分（`i < j`）**，以避免重复记录。



以下是根据提供的邻接矩阵生成边列表的Java代码示例，带有详细注释：

```java
import java.util.ArrayList;
import java.util.List;

public class GraphG1FromMatrix {

    public static void main(String[] args) {
        // 定义邻接矩阵
        int[][] adjMatrix = {
            {0, 1, 0, 0, 1},
            {1, 0, 1, 1, 1},
            {0, 1, 0, 1, 0},
            {0, 1, 1, 0, 1},
            {1, 1, 0, 1, 0}
        };

        // 定义图 G1 的边列表
        int n = adjMatrix.length; // 顶点数量
        int[][] edges = extractEdges(adjMatrix, n);

        // 打印提取的边
        System.out.println("图 G1 的边列表:");
        for (int[] edge : edges) {
            System.out.println("(" + edge[0] + ", " + edge[1] + ")");
        }
    }

    public static int[][] extractEdges(int[][] adjMatrix, int n) {
        // 初始化一个动态数组来存储边
        List<int[]> edgeList = new ArrayList<>();

        // 遍历上三角部分的邻接矩阵
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (adjMatrix[i][j] == 1) {
                    edgeList.add(new int[]{i, j});
                }
            }
        }

        // 将动态数组转换为二维数组
        int[][] edges = new int[edgeList.size()][2];
        for (int i = 0; i < edgeList.size(); i++) {
            edges[i] = edgeList.get(i);
        }

        return edges;
    }
}
```



**代码解释**：

1. **定义邻接矩阵**：使用给定的邻接矩阵。
2. **提取边列表**：
   - `extractEdges` 方法遍历邻接矩阵的上三角部分（`i < j`），以避免重复记录对称位置的边。
   - 如果发现 `adjMatrix[i][j] == 1`，则将 `(i, j)` 加入边列表。
3. **打印边列表**：遍历边列表并打印每一条边。

**输出**：

运行该代码将输出提取的边列表：

```
图 G1 的边列表:
(0, 1)
(0, 4)
(1, 2)
(1, 3)
(1, 4)
(2, 3)
(3, 4)
```

这与您最初提供的边列表一致。这样，边列表中每条边只出现一次，避免了重复记录对称位置的边。









##### 最终示例代码

未参照上述图中的示例

```java
class MatrixGraph {
    private int vertices;
    private int[][] adjMatrix;

    public MatrixGraph(int vertices) {
        this.vertices = vertices;
        adjMatrix = new int[vertices][vertices];
    }

    // 添加边
    public void addEdge(int src, int dest) {
        adjMatrix[src][dest] = 1;
        adjMatrix[dest][src] = 1; // 无向图添加双向边
    }

    // 打印邻接矩阵
    public void printGraph() {
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                System.out.print(adjMatrix[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        MatrixGraph graph = new MatrixGraph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);

        graph.printGraph();
    }
}
```





#### (2)有向图的邻接矩阵表示

```java
class DirectedMatrixGraph {
    private int vertices;
    private int[][] adjMatrix;

    public DirectedMatrixGraph(int vertices) {
        this.vertices = vertices;
        adjMatrix = new int[vertices][vertices];
    }

    // 添加边
    public void addEdge(int src, int dest) {
        adjMatrix[src][dest] = 1; // 有向图添加单向边
    }

    // 打印邻接矩阵
    public void printGraph() {
        for (int i = 0; i < vertices; i++) {
            for (int j = 0; j < vertices; j++) {
                System.out.print(adjMatrix[i][j] + " ");
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        DirectedMatrixGraph graph = new DirectedMatrixGraph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);

        graph.printGraph();
    }
}
```







### 总结

上述代码展示了如何使用邻接表和邻接矩阵表示无向图和有向图。选择哪种表示方法取决于具体应用场景。如果图比较稀疏，邻接表更节省空间；如果图比较稠密，邻接矩阵更适合快速查找边的存在性。













