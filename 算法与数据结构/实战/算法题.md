

















#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

中等



相关标签



给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

 

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`



##### 暴力递归(超时)

```java
/**暴力递归(超出时间限制)
DFS:
    1. 前置条件：
       - 如果 nums 总和 sum 是奇数，必然无法分成两个等和子序列。
       - 目标问题可转化为：是否能找到一个子序列，其和为 target = sum / 2。
    2. 状态定义：
       - index 表示当前处理到的元素下标。
       - target 表示剩余需要凑的和。
    3. 递归边界：
       - target == 0 → 找到合法子序列，返回 true。
       - index >= n 或 target < 0 → 不可能成立，返回 false。
    4. 状态转移：
       - dfs(index + 1, target - nums[index]) → 选择当前元素。
       - dfs(index + 1, target) → 不选择当前元素。
       - 只要有一个为 true，则返回 true。
    5. 复杂度分析：
       - 时间复杂度：O(2^n)，每个元素有「选/不选」两种分支。
       - 空间复杂度：O(n)，主要为递归栈深度。
 */
class Solution {
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for(int num : nums){
            sum += num;
        }
        //等和两个子集先决条件不成立
        if(sum % 2 != 0) return false;
        int target = sum / 2, n = nums.length;
        return dfs(nums, 0, target, n);
    }
    private static boolean dfs(int[] nums,int index, int target, int n){
        if(target == 0) return true;
        if(index >= n || target < 0) return false;
        //选择当前元素 + 不选
        return dfs(nums, index + 1, target - nums[index], n) || dfs(nums, index + 1, target, n);
    }
}
```



##### 回溯+记忆优化

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // 前置判断: 数组为空或长度小于2，无法分割
        if (nums == null || nums.length < 2) return false;
        int sum = 0, n = nums.length;
        for (int num : nums) {
            sum += num;
        }
        // 如果总和为奇数，则无法分成两个和相等的子集
        if (sum % 2 != 0) return false;
        int target = sum / 2;
        // dp[i][j] 用于记忆化，避免重复计算 dfs(i, j)
        Boolean[][] dp = new Boolean[n][target + 1];
        return dfs(nums, 0, target, dp);
    }

    /**
     * 回溯(优化) + 记忆化
     *
     * 思路：
     * 1. 每个元素有选或者不选两种选择
     * 2. 如果当前 index 超过数组长度或 target < 0，则返回 false
     * 3. 如果 target == 0，则找到了一个子集和为目标，返回 true
     * 4. 使用 dp[i][target] 记录已经计算过的状态，避免重复递归
     * 5. 递归两条路径：选当前元素或者不选当前元素
     *
     * 时间复杂度: O(n * target)  (n = 数组长度, target = sum/2)
     * 空间复杂度: O(n * target)  (用于存储记忆化数组 dp)
     *
     * @param nums   原数组
     * @param index  当前递归下标
     * @param target 目标和
     * @param dp     记忆化数组
     * @return result
     */
    private static boolean dfs(int[] nums, int index, int target, Boolean[][] dp) {
        // 终止条件: 数组越界或 target < 0
        if (index >= nums.length || target < 0) return false;
        // 找到子集和为目标
        if (target == 0) return true;
        // 已经计算过当前状态，直接返回
        if (dp[index][target] != null) return dp[index][target];
        // 递归两种选择：选或不选当前元素
        boolean result = dfs(nums, index + 1, target - nums[index], dp) 
                      || dfs(nums, index + 1, target, dp);
        // 记录状态，避免重复递归
        dp[index][target] = result;
        return result;
    }
}
```



