算法上午学完,下午晚上kafka(一半),50单词+语法(模板后面要开始背起来了)，看下能不能找到编译原理的老师答疑。





![image-20210828093025221](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108280930318.png)





总览图：







![image-20211112205915665](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122059730.png)

**跳过**



复杂度
===

常数操作
---

常数时间的操作

一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作







时间复杂度
---

时间复杂度：一个算法流程中，常熟操作数量的一个指标，常用O来表示。

具体来说，先要对一个算法流程非常熟悉，然后去**写出这个算法流程中，发生了多少常数操作**，进而**总结出常数操作数量的表达式**



在表达式中，==**只要高阶项，不要低阶项，也不要高阶项的系数**==，**剩下的部分如果为f(N),那么时间复杂度为O(f(N)).**



评价一个算法流程的好坏，**先看时间复杂度的指标，再分析不同数据样本的实际运行时间**，也就是“**常数项时间**”。



### 选择排序

示例：选择排序算法的时间复杂度

![image-20210824214057238](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108242140396.png)











System.arraycopy()
---

方法

System.arraycopy的函数原型是：



```java
public static void arraycopy(Object src,
                             int srcPos,
                             Object dest,
                             int destPos,
                             int length)
//其中：src表示源数组，srcPos表示源数组要复制的起始位置，desc表示目标数组，length表示要复制的长度。
```




原文链接：https://blog.csdn.net/qq_32440951/article/details/78357325







空间复杂度
---





#### 位运算

| 对于二进制位x有：                   |
| ----------------------------------- |
| 异或运算： x ^ 0 = x,	x ^ 1 = ~x |
| 与运算： x & 0 = 0 , x & 1 = x      |





### 异或运算

![image-20210824220603986](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108242206038.png)



![image-20210824220905474](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108242209538.png)







例：

| 有一个int数组，所有元素中，只有一个元素s出现了奇数次，其余都是偶数次，求s? |
| ------------------------------------------------------------ |

```java
//由题意可知，在数组中，有一个3元素出现了奇数次，而其它都是偶数次
int[] nums = {1,1,2,2,3,3,4,5,5,4,3};
//将第一个元素赋值给s，并与其它所有元素异或，异或同位为0
int　s = nums[0];
//偶数次都抵消，剩下的就是那个剩余的奇数次的元素了！！！
for(int i = 1;i < nums.length;i++) s^=nums[i];
//返回
return s;
```



| 一个int数组，所有元素中，只有两个元素都出现了奇数次，其余都是偶数次，求这两个元素? |
| ------------------------------------------------------------ |

思路：
	由于异或运算的同位与，相同为0

​	那么，可以假设所有个数为偶数的元素，提前都异或完毕，也就都为0了

​	就剩下最后的两个个数为奇数的两个元素

​	不妨设这两个数为a和b。既然它们是两个不同的数，那么得出：

​	1.它们一定存在某一位结果不同，分别为0和1。

​	2.假设a^b=c，那么c肯定!=0，所以，关键在于设一个变量s=它们结果不同的那个位的其中一个，让它去火拼那一个，假设火拼了a，那么同位相同为0，最后s也就等于b了

​	所以求出s=b，那么剩下的就让这个s^c不就=a了嘛



**重要步骤：取到a^b的结果的最右侧的1**

![image-20210825002453372](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108250024791.png)

```java
//eor = a ^ b
//eor != 0
//eor必然至少有一个位置是1
int rightOne = eor & (~eor + 1);
```

总代码：

```java
public class num2 {
    public static void main(String[] args) {
        int[] nums = {1,1,2,2,3,3,4,5,5,4,3,4};
        printOddNum2(nums);//a = 3 b = 4
    }
    public static void printOddNum2(int[] arr){
        /**定义一个eor去获取数组中所有的元素
        假设所有的偶数次都在前面，最后就剩下两个奇数次的那两个元素
        最后这个元素得到的结果就是最后两个奇数次的元素异或的结果a^b*/
        int eor = 0;
        for (int i : arr){
            eor ^= i;
        }
        //eor = a ^ b; && eor != 0
        //eor必定有一个位置上是1；

        /**提取出最右边的1
         1.先取反，用取反后的结果+1，就是在最右侧那个1假如是1就会不断相加进1
         2.直到取到最右侧进了一位的1由于此时这个是取反数运算的结果，此时取反数这个位置肯定不为1，所以：
         3.再与原来那个~eor &一下，就刚刚得到相同位上，最靠右为1的那个数。
         4.又因为，原来eor没有取反这一位肯定是1，所有因为eor是a^b的结果，可得出，此时a或者b这一位就是=1
         5.由此分为此位为1的就是a，此位为0的就是b。
         */
        int rightOne = eor & (~eor + 1);
        //eor'
        int onlyOne = 0;

        //遍历所有元素
        for(int cur : arr){
            //【重点】获取a^b得到的eor所有数组中其它偶数次可忽略不计， 此位数为1的那个a 再去用onlyOne得到它。
            if ((cur & rightOne) == 1){
                onlyOne ^= cur;
            }
        }
        //得出这个a了，那么就让这个a去异或这个总的eor，不就得到另外一个b了？
        System.out.println("a = "+onlyOne + " " +"b = "+(eor ^ onlyOne));
    }
}
```











### 插入排序

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251913120.gif" alt="1" style="zoom:80%;" />

对于一个数组，例如num={5,6,3,2,8,7,1,4};

使用插入排序的算法呢，就是

| 排序步骤                                                     |
| ------------------------------------------------------------ |
| 1.【0-1范围排序】数组的nums[0]=5,与nums[1]=6,那么，两个元素对比，不需要交换，再往前看，前面没有数了，所以，第一次选择排序还是{5,6,3,2,8,7,1,4} |
| 2.【0-2范围排序】nums[1]=6,nums[2]=3 需要交换,换完nums[1]=3再与nums[0]交换，最终结果为{3,5,6,2,8,7,1,4}实现0-2范围排序 |
| …                                                            |

所以，它的判断就是，0-1,0-2,0-3,0-4,0-5,0-6….所以，它的时间复杂度判断就是



但是：在判断时间复杂度的时候，选择排序中

​	1.假如按照最好的情况下来判断就是{1,2,3,4,5,6,7,8,9}那么，使用选择排序这个过程只需要看一遍即可，所以，这种情况的时间复杂度是o(n)级别的。

​	2.但是假如，它按照最差的情况下来判断就是{9,8,7,6,5,4,3,2,1}每次都需要0-0，0-1,0-2，0-3…很明显它的时间复杂度是一个等差数列所以时间复杂度就是O(n^2)

​	在同样的算法下，有不同的情况的时间复杂度，但是，实际统计这个算法的时间复杂度，就==**按照最差的情况**==也就是——O(n^2)才是选择排序的时间复杂度













































### 递归



#### 概述

![image-20210828152919894](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281529998.png)

​											==一切符合子规模等规的递归，都适用于master公式==



#### 递归二分求最大值

![image-20210828152838033](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281528146.png)





上述代码满足**master公式**：
$$
T(N) = a * T(N/b) + O(N^d)
$$
**1)log(b,a) > d -> 复杂度为O(N^log(b,a))**
**2)log(b,a) = d -> 复杂度为O(N^d * logN)**
**3)log(b,a) < d -> 复杂度为O(N^d)**



![image-20210828153235694](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281532777.png)



例如

![image-20210828153919300](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281539397.png)

![image-20210828154158724](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281541828.png)

**两个子规模不相等**







#### 归并排序

| 思路： 	假设需要排序的数组为nums，设nums={2,5,8,2,3,6}    |
| ------------------------------------------------------------ |
| 1.先将数组分两个部分开始分别排好序                           |
| nums1{2,5,8}       nums2{2,3,6}                              |
| 2.设两个指针q,h分别指向两个子数组的初始位                    |
| 3.开辟一个与nums等长的一个数组空间int[] z = new int [nums.length]; |
| 4.nums1[q] 和 nums2[h]进行比较，相等则默认从左边子数组添加，谁小谁先放，其中一个放完了，则其它的自行补齐！ |

![image-20210828160730883](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281607987.png)

符合master公式第二个条件判断log(b,a) = d -> 复杂度为O(N^d * logN)也就是==>**O(N * logN)**



时间复杂度

![image-20210828161700745](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281617830.png)





![image-20210828163431361](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281634460.png)





![image-20210828163820542](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108281638606.png)





































































排序
===

![image-20210901171554144](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109011715390.png)













哈希表简介

![image-20210901172304322](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109011723495.png)

![image-20210901172456269](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109011724395.png)











快速排序
---

高快省的排序算法
---

有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。

假设我们现在对“6 1 2 7 9 3 4 5 10 8”这个10个数进行排序。首先在这个序列中随便找一个数作为**基准数**（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：

3 1 2 5 4 6 9 7 10 8

在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？

排序算法显神威
---

方法其实很简单：分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从**右**往**左**找一个小于6的数，再从**左**往**右**找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。



![这里写图片描述](https://i.loli.net/2021/11/03/R7xzMQeVX9nJTFG.jpg)
首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。
![这里写图片描述](https://i.loli.net/2021/11/03/jEnqPdeAx9prbt5.jpg)
![这里写图片描述](https://i.loli.net/2021/11/03/fJF2Bk6yilpdtLx.jpg)
现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：

6 1 2 **5** 9 3 4 **7** 10 8

![这里写图片描述](https://i.loli.net/2021/11/03/3OeDjcN6g8kMbh7.jpg)
![这里写图片描述](https://i.loli.net/2021/11/03/9rsatOJeqUgfipb.jpg)
到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求)之后停了下来。此时再次进行交换，交换之后的序列如下：

> 6 1 2 5 **4** 3 **9** 7 10 8

第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：

> **3** 1 2 5 4 **6** 9 7 10 8

![这里写图片描述](https://i.loli.net/2021/11/03/5nMF7CRPVgpzQlv.jpg)
![这里写图片描述](https://i.loli.net/2021/11/03/VKGPoEMaT6xOpUm.jpg)
![这里写图片描述](https://i.loli.net/2021/11/03/XY692zS5GjwbEOL.jpg)

到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。

OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3 1 2 5 4”，右边的序列是“9 7 10 8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。

左边的序列是“3 1 2 5 4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧

如果你模拟的没有错，调整完毕之后的序列的顺序应该是：

> 2 1 **3** 5 4

OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：

1 2 3 4 5 6 9 7 10 8

对于序列“9 7 10 8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下

1 2 3 4 5 6 7 8 9 10

到此，排序完全结束。细心的同学可能已经发现，快速排序的每一轮处理其实就是将这一轮的基准数归位，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。
![这里写图片描述](https://i.loli.net/2021/11/03/z2w9Gg4CfOth38I.jpg)

这是为什么呢？

快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。其实快速排序是基于一种叫做“二分”的思想。我们后面还会遇到“二分”思想，到时候再聊。先上代码，如下

```java
public class QuickSort {
    public static void quickSort(int[] arr,int low,int high){
        int i,j,temp,t;
        if(low>high){
            return;
        }
        i=low;
        j=high;
        //temp就是基准位
        temp = arr[low];
 
        while (i<j) {
            //先看右边，依次往左递减
            while (temp<=arr[j]&&i<j) {
                j--;
            }
            //再看左边，依次往右递增
            while (temp>=arr[i]&&i<j) {
                i++;
            }
            //如果满足条件则交换
            if (i<j) {
                t = arr[j];
                arr[j] = arr[i];
                arr[i] = t;
            }
 
        }
        //最后将基准为与i和j相等位置的数字交换
         arr[low] = arr[i];
         arr[i] = temp;
        //递归调用左半数组
        quickSort(arr, low, j-1);
        //递归调用右半数组
        quickSort(arr, j+1, high);
    }
 
 
    public static void main(String[] args){
        int[] arr = {10,7,2,4,7,62,3,4,2,1,8,9,19};
        quickSort(arr, 0, arr.length-1);
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
    }
}
```













链表
===

打印两个有序链表的公共部分

![image-20210901174152503](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109011741609.png)





![image-20210901174218639](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109011742697.png)









**判断一个链表是否为回文结构**

**回文**

| 回文 | 正着念和反着念一样 |
| ---- | ------------------ |

![image-20210901174503133](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109011745197.png)



![image-20210901184831426](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109011848524.png)

笔试应对思路：
方法一(栈)：
	遍历链表中所有元素将其不断装入到栈中之后

​	再用指针从链表的头节点开始，从头开始，每次与栈的pop出来的元素比较，都相同就返回true



方法二(快慢双指针)



==注意：根据不同的题目的要求，快慢双指针可以定义不同的定制版！==



```java
方式一：
    使用栈空间实现
    1.定义一个栈空间用于不断存储从链表中遍历的所有元素
    2.用一个指针s,从链表的初始位置开始不断将元素放入栈中
    3.然后再将s指向链表的头节点
    4.然后开始比较s指向的链表元素值 与 栈中 pop出来的值
    5.有一个不一样的返回false,全部完成且相同返回true
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        //定义栈空间
        Stack stack = new Stack();
        //指针变量s
        ListNode s = head;
        //循环
        while(s.val != null){
            stack.push(s.val);
            if(s != null) s = s.next;
        }
        //再将指针指向链表的头节点
        s = head;

        //不断比较
        while(s != null){
            if(s.val != stack.pop()) return false;
            if(s.next != null) s = s.next;
        }
        //到这里都是相同的返回true
        return true;
    }
}
```















![image-20210902172259546](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109021722627.png)

题目大意：链表除了按照单链表的普通结构，每个节点还多了一个随机指针，可能指向任意节点，也可能指向null，要求返回和这个链表一样的一个新节点



思路：

​	1.使用HashMap实现，将旧链表old，从头开始遍历，将它的每一个节点都放在key中，而value部分则是放它不断克隆出来的新节点，并且与之对应起来

​	2.开始复制它的指针,old.next指向的是它的下一个节点，直接将new.next = map.get(old.next)

随机指针也是一样的，如果old节点的随机指针指向的是哪个节点，那么new.random =map.get(old.random)















![image-20210902210923267](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109022109368.png)





有环的链表的，怎么判断第一个入环节点(转圈的第一个交点)？

>思路：
>		可以使用HashSet集合不断装入节点到集合中，每次装入的时候都先判断集合中是否有这个元素，没有再装入。
>
>​		第一次一旦发现有就直接返回。这个就是要找的第一个入环交点

注意：单向链表不可能出现入环成圈了再绕出来的，入环了它就会一直在环的范围循环。

![image-20210906210225518](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109062102700.png)



方式二：快慢双指针

>使用快慢双指针解决：
>	q走1，h走2当一直遍历，一个有环的链表，那么它们一定能够相遇，且一般在环中循环的次数不会大于两圈就相遇
>
>!!!:然后它们都停下：
>	1.让快指针h回到链表的初始位置，而慢指针继续待在原地：
>	2.然后它们都开始每次走一步，然后**接着相遇的地方就一定就第一个入环节点**



![image-20210906211045122](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109062110428.png)











​															**两个单链表几种可能相交的情况**

| ![image-20210906221238163](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109062212539.png) | ![image-20210906212715659](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109062127881.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20210906212527988](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109062125184.png) | **两个单链表最后都为null，且相交那么它们从相交的节点开始的这一段一定是它们的公共部分** |
| ![image-20210906213208199](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109062132372.png) | 把两个单链表都遍历一遍分别都保存头节点(head1和2)最后一个节点end1和2还有长度len1和2判断：如果end1节点的内存地址和end2的节点的内存地址不相同则判定两条链表不相交.                                    情况二：当两个链表一个最后到null，一个不为null，那么它们也决对不会相交 |
| **总结：==长链表先走差值部分，然后短链表一起走，两个都一步一步走下去=** | 因为上左图(2372.png)  len1-len2=20让head1先走20，然后再一起走,那么它们两个一定会在第一个相交处的节点相遇!!! |



![image-20210906221916349](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109062219690.png)















































树
===











## 二叉树

### 术语

**树的示意图**

![image-20210825121839517](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251218890.png)



| 根节点   | root，开始的节点           | ![image-20210825121924375](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251219594.png) |
| -------- | -------------------------- | ------------------------------------------------------------ |
| 叶子节点 | 没有子节点的节点           | H/E/F/G                                                      |
| 节点的权 | 节点的值                   |                                                              |
| 路径     | 从root节点找到该节点的路线 |                                                              |
| 层       | 相对高度的一个平衡序列     | ![image-20210825122015297](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251220486.png) |
| 树的高度 | 最大层数                   |                                                              |
| 森林     | 多颗子树构成的森林         |                                                              |



### 概念

**二叉树**

  每个节点**<u>最多只能有两个子节点</u>**的一种形式称为二叉树(可以为1也可以为2)

![image-20210825122118096](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251221402.png)





**满二叉树**

  **所有叶子节点都在最后一层**，并且节点总数=**2^n(层数)-1**

![image-20210825122137977](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251221238.png)







**完全二叉树**

完全二叉树的**所有叶子节点都在最后一层或者倒数第二层**，而且**最后一层的叶子节点在左边连续**，**倒数第二层的叶子节点在右边连续**

![1628848372167](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251221303.png)







### 遍历

| 前序遍历 | 先输出父节点，再遍历左子树和右子树       |
| -------- | ---------------------------------------- |
| 中序遍历 | 先遍历左子树，再输出父节点，再遍历右子树 |
| 后序遍历 | 遍历左子树，再遍历右子树，最后输出父节点 |

小结：判断哪个序就看**输出父节点的顺序**







### 步骤

 分析二叉树的前序，中序，后序的遍历步骤

![1628850282010](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251221860.png)

```
1.创建一颗二叉树

2.前序遍历
2.1先输出当前节点(初始的时候是root)
2.2如果左子节点不为空，则递归继续前序遍历
2.3如果右子节点不为空，则递归继续前序遍历

3.中序遍历
3.1如果当前节点的左子节点不为空，则递归继续中序遍历
3.2输出当前节点
3.3如果当前节点的右子节点不为空，则递归继续中序遍历

4.后序遍历
4.1如果当前节点的左子节点不为空，则递归继续后序遍历
4.2如果当前节点的右子节点不为空，则递归继续后序遍历
4.3输出当前节点。
```

注意：无论哪一种遍历，**都是从root节点开始的**。



##### 示例代码

依照上述遍历步骤图及思路形成的代码：

```java
import lombok.Data;
/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2021/8/13 18:39
 * @TODO：二叉树的前序、中序、后序遍历
 * @Thinking:
 */
public class Binary_tree {
    public static void main(String[] args) {
        //创建一颗二叉树
        BinaryTree binaryTree = new BinaryTree();
        //创建所需节点
        //根节点
        HeroNode root = new HeroNode(1,"宋江");
        HeroNode node2 = new HeroNode(2,"吴用");
        HeroNode node3 = new HeroNode(3,"卢俊");
        HeroNode node4 = new HeroNode(4,"林冲");
		//新加节点关胜
        HeroNode node5 = new HeroNode(5,"关胜");
        //先手动创建
        root.setLeft(node2);
        root.setRight(node3);
        //注意：此时节点是从第三个开始
        //新加节点关胜在卢俊左子节点
        node3.setLeft(node5);
        
        node3.setRight(node4);
        //将root节点传给BinaryTree
        binaryTree.setRoot(root);
        //前序遍历
        System.out.println("前序遍历");//1,2,3,4
        binaryTree.preOrder();

        System.out.println("中序遍历");//2,1,3,4
        binaryTree.infixOrder();

        /**原本以为2,3,4,1实际上后序遍历的顺序是2,4,3,1
          因为后序遍历的本质就是先处理左子树，再去处理右子树，最后再处理父子树
          本次后序遍历中：
         1.它先从root节点找到左子树，发现接下来的左子树下面并没有节点了
         2.然后找到root下面的右子树卢俊，发现卢俊的左子树并没有，就找右子树，右子树，下面并没有了，所以最后打印卢俊父子树
        */
        System.out.println("后序遍历");
        binaryTree.postOrder();

    }
}



//定义二叉树
class BinaryTree{
    //定义根节点
    private HeroNode root;

    public void setRoot(HeroNode root){
        this.root = root;
    }

    //前序遍历
    public void preOrder(){
        if (this.root != null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为空，无法遍历！");
        }
    }

    //中序遍历
    public void infixOrder(){
        if (this.root != null){
            this.root.infixOrder();
        }else {
            System.out.println("二叉树为空，无法遍历！");
        }
    }

    //后序遍历
    public void postOrder(){
        if (this.root != null){
            this.root.postOrder();
        }else {
            System.out.println("二叉树为空，无法遍历！");
        }
    }
}




//先创建HeroNode节点
@Data//代表getter,setter
class HeroNode{
    private int no;
    private String name;
    //默认为null
    private HeroNode left;
    //默认为null
    private HeroNode right;

    //有参构造
    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    @Override
    public String toString() {
        return "HeroNode[no="+no+",name="+name +"]";
    }

    //前序遍历
    public void preOrder(){
        //先输出当前节点
        System.out.println(this);
        //如果左子树不为空，递归继续前序遍历
        if (this.left != null){
            this.left.preOrder();
        }
        //如果右子树不为空，递归继续前序遍历
        if(this.right!=null){
            this.right.preOrder();
        }
    }

    //中序遍历
    public void infixOrder(){
        //先判断左子树是否为空
        if (this.left!=null){
            this.left.infixOrder();
        }
        //输出父节点
        System.out.println(this);
        //判断右子树是否为空
        if(this.right!=null){
            this.right.infixOrder();
        }
    }

    /**后序遍历*/
    public void postOrder(){
        //先判断当前节点左子树是否为空
        if(this.left != null){
            this.left.postOrder();
        }
        //判断当前节点的右子树是否为空
        if(this.right != null){
            this.right.postOrder();
        }
        //输出当前节点
        System.out.println(this);
    }
}
```









##### 三序遍历

![image-20211104194312628](https://i.loli.net/2021/11/04/CTfczmh5P87Q1Lo.png)

输入root节点：

1、判断root节点是否为null，不为null继续下面的计算:



2、if(root.left != null) queue.offer(root.left)这样的结果就是将整条左边界(1、2、4)入栈





3、如果上述条件为null的时候，此时已经到了最左边的节点(4)了，就弹出该节点并且判断剩下的存在queue中的节点的右子节点是否为null，是null就再弹，不是就





##### 非递归遍历





![](https://i.loli.net/2021/10/31/dA3rgBZUMsQuqYo.png)





###### 后序非递归遍历

![image-20211104235743704](https://i.loli.net/2021/11/04/kpSrcFxyLs9RbB3.png)







##### 练习题

要求如下：
	1.在前上图的3号节点卢俊，增加一个左子节点[5,关胜]

​	2.使用前序，中序，后序遍历，请写出各自输出的顺序是什么？
![1628856024630](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251222377.png)





输出结果为：

前序：1,2,3,5,4

中序：2,1,5,3,4

后序：2,5,4,3,1







### 查找

利用前序、中序、后序来查找指定节点

![1628857411406](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251222617.png)

思路：

利用前序中序后序查找

##### **前序查找思路**

````
1.先判断当前节点是否=no  如果是，则返回当前节点
2.如果不是就判断当前节点的左子节点是否为null，如果!= null，则递归前序查找
3.如果左递归前序查找，找到节点，则返回，没有找到则继续判断，当前节点的右子节点是否为null。不为null则继续向右子节点递归前序查找。
4.找到了返回，没有找到则返回null
````

##### 中序查找思路

```
1.先判断当前节点的左子节点是为null，如果不为空向左递归中序查找，找到返回，如果没有找到
2.判断当前节点是否为target，是就返回当前节点
3.不是就继续判断当前节点的右子节点是否为null，不为null就继续递归中序查找
4.查找找到了就返回，没有找到就返回null
```

##### 后序查找思路

```
1.判断当前节点的左子节点是否为null,不为null就向左递归后序查找
2.如果找到返回，找不到就判断当前节点的右子节点是否为null不为null继续向右递归后序查找
3.向右递归找到了返回，找不到，判断当前节点是否=target，如果等于返回当前节点，不等于返回null
```



注意：

在判断遍历的次数时，在方法中写遍历次数为什么要在刚好比较是否==no前输出System.out.println(“已进入”)，才**与实际查找的次数准确**？

因为中序和后序的方法中，前面有的是在判断左子节点和右子节点是否为空，这个步骤实际上并没有进行比较，所有，需要放在比较语句this.no==no前。



查找示例代码(插入上面代码中即可)：

HeroNode中的代码插入的代码

```java
/**前序查找
no 查找no  如果找到就返回该Node,如果没有就返回null*/
public HeroNode preOrderSearch(int no){
    //进入查找
    System.out.println("进入查找!");
    //1.先判断当前节点是否=no  如果是，则返回当前节点
    if(this.no==no){
        return this;
    }
    HeroNode resNode = null;
    //2.如果不是就判断当前节点的左子节点是否为null，如果!= null，则递归前序查找
    if (this.left != null){
        resNode = this.left.preOrderSearch(no);
    }
    //说明找到了,返回
    if (resNode != null){
        return resNode;
    }
    //3.没有找到则继续判断，当前节点的右子节点是否为null。不为null则继续向右子节点递归前序查找。
    if (this.right != null){
        resNode = this.right.preOrderSearch(no);
    }
    //4.由于resNode的默认值为null，所以找到了就是返回，找不到返回的也是它的默认值null
    return resNode;
}


/**中序查找
 no 查找no  如果找到就返回该Node,如果没有就返回null*/
public HeroNode infixOrderSearch(int no){

    HeroNode resNode = null;
    //如果不是就判断当前节点的左子节点是否为null，如果!= null，则递归前序查找
    if (this.left != null){
        resNode = this.left.infixOrderSearch(no);
    }
    //说明找到了,返回
    if (resNode != null){
        return resNode;
    }
    System.out.println("进入中序遍历！");
    //判断当前节点是否=no  如果是，则返回当前节点
    if(this.no==no){
        return this;
    }
    //3.没有找到则继续判断，当前节点的右子节点是否为null。不为null则继续向右子节点递归前序查找。
    if (this.right != null){
        resNode = this.right.infixOrderSearch(no);
    }
    //4.由于resNode的默认值为null，所以找到了就是返回，找不到返回的也是它的默认值null
    return resNode;
}



/**后序查找
 no 查找no  如果找到就返回该Node,如果没有就返回null*/
public HeroNode postOrderSearch(int no){
    HeroNode resNode = null;
    //如果不是就判断当前节点的左子节点是否为null，如果!= null，则递归前序查找
    if (this.left != null){
        resNode = this.left.postOrderSearch(no);
    }
    //说明找到了,返回
    if (resNode != null){
        return resNode;
    }
    //3.没有找到则继续判断，当前节点的右子节点是否为null。不为null则继续向右子节点递归前序查找。
    if (this.right != null){
        resNode = this.right.postOrderSearch(no);
    }
    //注意，在此处查找完之后需要判断是否找到！
    //说明找到了,返回
    if (resNode != null){
        return resNode;
    }

    System.out.println("进入方法了！");
    //判断当前节点是否=no  如果是，则返回当前节点
    if(this.no==no){
        return this;
    }
    //4.由于resNode的默认值为null，所以找到了就是返回，找不到返回的也是它的默认值null
    return resNode;
}
```



BinaryTree中插入的代码~

```java
//前序遍历查找
public HeroNode preOrderSearch(int no){
    if (root != null){
        return root.preOrderSearch(no);
    }else {
        return null;
    }
}

//中序遍历查找
public HeroNode infixOrderSearch(int no){
    if (root != null){
        return root.infixOrderSearch(no);
    }else {
        return null;
    }
}

//后序遍历查找
public HeroNode postOrderSearch(int no){
    if (root != null){
        return root.postOrderSearch(no);
    }else {
        return null;
    }
}
```



测试代码：

```java
 //前序遍历查找
System.out.println("中序遍历查找");
HeroNode resNode = binaryTree.postOrderSearch(5);
if (resNode != null){
    System.out.printf("找到了，信息为 no=%d name=%s",resNode.getNo(),resNode.getName());
}else {
    System.out.printf("没有找到 no = %d 的英雄",5);
}
```











### 删除

##### 思路

![image-20210822144536001](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251222953.png)



```
完成删除结点的操作：
规定：
1.如果删除的是叶子结点，则删除结点
2.如果删除的是非叶子结点，则删除该子树

思路：
前置判断：
	1.如果树是空树，root==null那么就返回
	2.如果此树只有一个root结点，那么将此树置空

/**然后进行下面的步骤
1.二叉树是单项的，所以我们是判断当前结点的子结点，是不是需要删除的节点，而不能去判断当前结点是不是要删除的，那就迟了！
2.如果当前结点的左子结点不为空，并且左子结点就是要删除的结点，那么就将this.left = null并返回
3.如果结点的右子结点不为空，并且右子节点就是要删除的节点，那么就讲this.right = null并返回(结束递归删除)。
4.如果第2和第3步没有删除结点，那么我们就需要向左子结点进行递归删除
5.如果第4步也没有删除结点，则应当向右子树进行递归删除。
*/
```





### 代码实现

###### 前置条件

1.前置条件代码实现在定义树的BinaryTree方法中

```java
//删除方法的前置判断
public void delNode(int no){
    //首先，要判断它是否等于空
    if (root != null){
        //判断一下root是否等于no,就制空
        if(root.getNo() == no){
            root = null;
        }else {
            //不是就递归删除
            root.delNode(no);
        }
    }else {
        //否则就是空树了
        System.out.println("树为空，不可删除~");
    }
}
```





###### 方法实现

2.实现功能主要代码

```java
public void delNode(int no){
    //1.二叉树是单项的，所以我们是判断当前结点的子结点，是不是需要删除的节点，而不能去判断当前结点是不是要删除的，那就迟了！
    if (this.left != null && this.left.no == no){
        this.left = null;
        return;
    }

    //2.如果当前结点的左子结点不为空，并且左子结点就是要删除的结点，那么就将this.left = null并返回
    if (this.right != null && this.right.no == no){
        //3.如果结点的右子结点不为空，并且右子节点就是要删除的节点，那么就讲this.right = null并返回(结束递归删除)。
        this.right = null;
        return;
    }
    //4.如果第2和第3步没有删除结点，那么我们就需要向左子结点进行递归删除
    if (this.left != null){
        this.left.delNode(no);
    }

    //5.如果第4步也没有删除结点，则应当向右子树进行递归删除。
    if (this.right != null){
        this.right.delNode(no);
    }
```





###### 测试代码

```java
//测试删除结点是否成功

System.out.println("删除结点前的前序遍历");//12354
binaryTree.preOrder();

binaryTree.delNode(5);

System.out.println("删除结点后的前序遍历");//1234
binaryTree.preOrder();
```





#### 存储

**顺序存储二叉树**



##### 概念

基本说明

从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组，示意图如下：

![image-20210822155956696](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251223429.png)

##### 特点

顺序存储二叉树的特点：
1.顺序二叉树通常只考虑完全二叉树

2.第n个元素的左子结点的位置为2*n+1

3.第n个元素的右子结点的位置为2*n+2

4.第n个元素的父结点为(n-1)/2

**n**:表示二叉树中的第几个元素(按0开始编号如上图所示)







##### 问题

顺序存储二叉树遍历

需求：给你一个数据{1,2,3,4,5,6,7},要求以二叉树前序遍历的方式进行遍历

前序遍历的结果应当为1,2,4,5,3,6,7，还有中序和后序遍历

![image-20210822174036702](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/20210822174036.png)

###### 前序

示例代码：

```java
package Tree;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2021/8/22 16:14
 * @TODO：顺序存储二叉树
 * @Thinking:
 */
public class ArrBinaryTreeDemo {
    public static void main(String[] args) {
        //测试
        int [] arr = {1,2,3,4,5,6,7};
        //实例化对象
        ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
        //传入数组的第一个位置，开始
        arrBinaryTree.preOder(0);
    }
}

class ArrBinaryTree{
    //存储数据结点的数据
    private int[] arr;

    public ArrBinaryTree(int[] arr){
        this.arr = arr;
    }

    //编写一个方法，完成顺序存储二叉树的前序遍历,index:数组下标
    public void preOder(int index){
        //如果数组为空，或者arr.length = 0
        if (arr == null || arr.length ==0){
            //输出提示信息，否则输出此元素
            System.out.println("数组为空,不能按二叉树前序遍历");
        }
        //不为空则输出此元素
        System.out.println(arr[index]);

        //接着向左递归遍历,并且，每次递归传入的参数要比对数组长度来
        if((index * 2 + 1) < arr.length){
            preOder(2 * index + 1);
        }
        //向右递归遍历
        if ((index*2 +2)<arr.length){
            preOder(2 * index +2);
        }
    }
}
```



中序后和后序将输出

```java
 //不为空则输出此元素
        System.out.println(arr[index]);
```

的位置相应调换即可









#### 线索

**线索化二叉树**



##### 引入

先看一个问题

将数组{1,3,6,8,10,14}构建成一颗二叉树。

![image-20210822175709286](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/20210822175709.png)









##### 介绍

线索二叉树基本介绍

1.   n个结点的二叉链表中含有n+1【公式2n - (n - 1) = n + 1】个空指针域。
2. **利用二叉链表中的空指针域**，存放指向**该**结点在**某种遍历次序下的前驱和后继结点的指针**(这种==**附加的指针**==称为“线索”)
3. 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序/中序/后序 线索二叉树这三种。
4. 一个结点的前一个结点，称为**前驱结点**
5. 一个结点的后一个结点，称为**后继结点**







##### 应用

线索二叉树应用案例

![image-20210822180717618](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/20210822180717.png)









![image-20210822180751606](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/20210822180751.png)





![image-20210822225045910](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/20210822225046.png)











![image-20210913191602131](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109131916291.png)















递归序
---

![image-20210913192107898](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109131921999.png)

![image-20210913193230747](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109131932298.png)





![image-20210913194038010](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109131940378.png)

左头右

4,2,5,1，3,6,7



![image-20210913194357977](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109131943376.png)









### 非递归序

![image-20210913195255565](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109131952924.png)





倒序打印二叉树

```java
思路：
	1.前序遍历，定义两个栈,一个栈
用于不断接收结果集,本来就是s1要弹出的
元素也就是要输出的元素，它暂时不输出，保存
在栈s2中,最后再打赢输出栈中保存的所有
结果集，
	这也使得前序遍历变成了后序遍历!!!
```

![image-20210913200306072](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109132003305.png)









如何完成二叉树的**宽度**优先遍历(常见题目：求一颗二叉树的宽度)





方法口诀
---

==**宽度遍历用队列，头部进,尾部出**==

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109132054330.png" alt="image-20210913205431239" style="zoom:67%;" />

示例代码：

```java
public void w(Node head){
    if(head == null){
       //1.遍历到头节点为null的时候没就返回
        return;
    }
    //2.linkedList本来就是队列
    Queue<Node> queue = new LinkedList<>();
    //3.到了这里,头节点不为空,就加入到集合中
    queue.add(head);
    //4.定义一个循环，只要集合不为null就加入
    while(!queue.isEmpty()){
       	//5.将节点一个一个弹出打印
        Node cur = queue.poll();
        System.out.println(cur.value);
       
        //6.遍历加入左右子树的节点
    	if(cur.left != null){
            queue.add(cur.left);
        }
        if(cur.right != null){
            queue.add(cur.right)
        }
    }
    
}
```





**二叉树的最大宽度**

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109132111010.png" alt="image-20210913211128865" style="zoom:50%;" />

关键点就是：**在遍历到一个结点的时候，要知道这个结点在第几层。**











#### [662. 二叉树最大宽度](https://leetcode-cn.com/problems/maximum-width-of-binary-tree/)

难度中等250

给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与**满二叉树（full binary tree）**结构相同，但一些节点为空。

每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的`null`节点也计入长度）之间的长度。

**示例 1:**

```
输入: 

           1
         /   \
        3     2
       / \     \  
      5   3     9 

输出: 4
解释: 最大值出现在树的第 3 层，宽度为 4 (5,3,null,9)。
```

**示例 2:**

```
输入: 

          1
         /  
        3    
       / \       
      5   3     

输出: 2
解释: 最大值出现在树的第 3 层，宽度为 2 (5,3)。
```

**示例 3:**

```
输入: 

          1
         / \
        3   2 
       /        
      5      

输出: 2
解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。
```

**示例 4:**

```
输入: 

          1
         / \
        3   2
       /     \  
      5       9 
     /         \
    6           7
输出: 8
解释: 最大值出现在树的第 4 层，宽度为 8 (6,null,null,null,null,null,null,7)。
```

**注意:** 答案在32位有符号整数的表示范围内。

通过次数27,497

提交次数67,488



???

按照上课思路示例代码!!!

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
思路：
    关键点在于:怎么去标识每个节点所代表的是在第几层,而且当遍历到下一层的时候,怎么知道它就是在下层了
	你可以去判断它的行数的前提就是你已经将它的行数记录到了map中了,所以你才可以去判断当前你到底到了第几层
 * }
 */
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        //判断树的宽度，用队列左进右出
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);

        //1.前置判断
        if(root == null) return 0;
        //2.定义几个变量,一个用于表示第几层(层级) level,统计每一层的节点数(当前层节点总数) sumNode,还有最终的最大保存全局变量max
        //保存每个结点对应的层级的集合levelMap
        HashMap<TreeNode,Integer> levelMap = new HashMap();
        int level = 1,sumNode = 0, max = Integer.MAX_VALUE;
        //3.这头节点肯定在第一层的唯一一个咯
        levelMap.put(root,1);
        
        while(!queue.isEmpty()){
            TreeNode cur = queue.poll();
            //定位当前到第几层了
            int danglevel = levelMap.get(cur);
            if(danglevel == level){
                //如果当前层数没有变，层里元素一直++
                sumNode++;
            }else{
                //到这里就证明已经到下一层了，并且上一层统计完毕了，该清算了
                max = Math.max(max,sumNode);
                //新一层到了
                level++;
                //重新统计新一层元素个数
                danglevel = 1;
            }
            // System.out.println(cur.value);
            if(cur.left != null){
                queue.add(cur.left);
            }
            if(cur.right != null){
                queue.add(cur.right);
            }
        }
        return max;
    }
}
```



正确代码：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }

 思路：
    用一个队列一进一出的去判断层级和元素总和，注意此处由于这个二叉树与满二叉树结构相同
    定义一个树的结构用于陈述
 */
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        //1.前置判断
        if(root == null) return 0;

        //2.定义队列,泛型就是三个变量的包装节点Node
        Queue<Node> queue = new LinkedList();
        //3.先把root节点放到第一个位置上咯
        queue.add(new Node(root, 0, 0));

        //4.定义一个max变量用于不断统计出来最大的那个宽度,level = 表示当前层数, 当前层最左边的那个节点
        int maxSum = 0, level = 0,sumleft = 0;
        
        //5.循环开始,当队列元素为null结束
        while(!queue.isEmpty()){
            
            //6.弹出一个元素
            Node c = queue.poll();

            //7.这个弹出的元素有值的话就证明有下一层，因为如题所属，此可等同于满二叉树，就当它节点都是满的
            if(c.node != null){
                //6.1左子树:当前节点的左子树,当前节点等级也需要再加1了,跳到下一个级别了,一个子数节点有两个,这里可当它是满的
                queue.add(new Node(c.node.left,c.levels + 1,c.sum * 2));
                //6.2右子树:当发现
                queue.offer(new Node(c.node.right,c.levels + 1,c.sum * 2 + 1));

                //8.如果深度不一样，就调整左边的位置
                if(level != c.levels){
                    //更新最新的层级
                    level = c.levels;
                    //让左子树 = 弹出这个节点的统计完的总数
                    sumleft = c.sum;
                }
            //这里就要统计最大的层数了(每个节点出栈的时候都会比较统计一次)
                maxSum = Math.max(maxSum,c.sum - sumleft + 1);
            }
        }
        return maxSum;
    }
}
//此处用于陈述树结构
    class Node{
    //包装一下,主要是为了加上下面的参数
    TreeNode node;

    //levels = 层级深度,sum表示当前层数统计到的元素个数
    int levels ,sum;
    Node(TreeNode a,int b,int c){
        node = a;
        levels = b;
        sum = c;    
    }
}

```







思路二：不使用集合，但是需要使用队列

>思路：
>	定义变量,使用curend表示当前层的最后一个结点
>
>​		      使用nextend表示下一层的最后一个结点
>
>​		      调用cahevel表示当前在此层共统计到了多少元素
>
>​		      max用于统计当前捕获的最多元素的层中的元素和

![image-20210915214959040](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109152149117.png)

>开始：
>1.定义当前root结点 放到curend变量中，并且置下一层最后一个结点,变量nextend = null,和cuHevel = 0













![image-20210917221842459](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109172218824.png)





| 搜索二叉树 | 对于每一棵子树来说，左树的节点都比它小，右树的节点都比它大(经典的二叉树可以被认为是没有重复值的)且每一个子树节点都要满足此条件![image-20210917223007147](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109172230682.png) | 使用中序遍历一遍！假如一直都是==递增==的，那么它肯定是搜索二叉树 |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
|            |                                                              |                                                              |
|            |                                                              |                                                              |
|            |                                                              |                                                              |

![image-20210918110353323](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202109181103418.png)



















红黑树
---





本词条由[“科普中国”科学百科词条编写与应用工作项目](https://baike.baidu.com/science) 审核 。

红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在[计算机](https://baike.baidu.com/item/计算机)科学中用到的一种[数据结构](https://baike.baidu.com/item/数据结构/1450)，典型的用途是实现[关联数组](https://baike.baidu.com/item/关联数组/3317025)。 [1] 

红黑树是在1972年由[Rudolf Bayer](https://baike.baidu.com/item/Rudolf Bayer/3014716)发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。 [2] 

红黑树是一种特化的AVL树（[平衡二叉树](https://baike.baidu.com/item/平衡二叉树/10421057)），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。 [2] 

它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。 [2] 

- 中文名

  红黑树

- 外文名

  RED-BLACK-TREE

- 别  名

  对称二叉B树

- 性  质

  [平衡二叉查找树](https://baike.baidu.com/item/平衡二叉查找树/22991078) [3] 

- 用  途

  实现[关联数组](https://baike.baidu.com/item/关联数组) [1] 

- 发明人

  [鲁道夫·贝尔](https://baike.baidu.com/item/鲁道夫·贝尔/957695)

- 发明时间

  1972年

- 学  科

  计算机

目录
---

1. 1 [简介](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#1)
2. 2 [特征](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#2)
3. 3 [树的旋转](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#3)
4. ▪ [1.结点插入算法](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#3_1)
5. ▪ [2.结点删除算法](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#3_2)

1. 4 [操作](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#4)
2. 5 [用途](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#5)
3. ▪ [1.Linux非实时任务调度中的应用](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#5_1)
4. ▪ [2.Linux虚拟内存中的应用](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#5_2)

1. ▪ [3.检测树的平衡性上的应用](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#5_3)
2. 6 [数据结构简述](https://baike.baidu.com/item/红黑树/2413209?fr=aladdin#6)

简介
---

[编辑](javascript:;)[ 语音](javascript:;)

红黑树是一种特定类型的[二叉树](https://baike.baidu.com/item/二叉树)，它是在计算机科学中用来组织数据比如数字的块的一种结构。 [4] 

红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的[平衡二叉树](https://baike.baidu.com/item/平衡二叉树/10421057)（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。 [2] 

由于每一棵红黑树都是一颗[二叉排序树](https://baike.baidu.com/item/二叉排序树/10905079)，因此，在对红黑树进行查找时，可以采用运用于普通二叉排序树上的查找算法，在查找过程中不需要颜色信息。 [5] 

特征
---

[编辑](javascript:;)[ 语音](javascript:;)

红黑树是每个结点都带有颜色属性的二叉查找树，颜色或红色或黑色。 [3] 在[二叉查找树](https://baike.baidu.com/item/二叉查找树/7077965)强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:

性质1. 结点是红色或黑色。 [3] 

性质2. 根结点是黑色。 [3] 

性质3. 所有叶子都是黑色。（叶子是NIL结点） [3] 

性质4. 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）

性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。 [3] 

这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。 [3] 

是性质4导致路径上不能有两个连续的红色结点确保了这个结果。最短的可能路径都是黑色结点，最长的可能路径有交替的红色和黑色结点。因为根据性质5所有最长的路径都有相同数目的黑色结点，这就表明了没有路径能多于任何其他路径的两倍长。 [3] 

因为红黑树是一种特化的[二叉查找树](https://baike.baidu.com/item/二叉查找树/7077965)，所以红黑树上的只读操作与普通二叉查找树相同。 [2] 

树的旋转
---

[编辑](javascript:;)[ 语音](javascript:;)

[![树的左旋](https://bkimg.cdn.bcebos.com/pic/86d6277f9e2f0708cdb73039ed24b899a901f25d?x-bce-process=image/resize,m_lfit,w_220,limit_1/format,f_auto)树的左旋(2张)](https://baike.baidu.com/pic/红黑树/2413209/1379342726/86d6277f9e2f0708cdb73039ed24b899a901f25d?fr=lemma&ct=cover)当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性质。

为了保持红黑树的性质，我们可以对相关结点做一系列的调整，通过对树进行旋转（例如左旋和右旋操作），即修改树中某些结点的颜色及指针结构，以达到对红黑树进行插入、删除结点等操作时，红黑树依然能保持它特有的性质（五点性质）。 [3] 

如右图。

### 1.结点插入算法

插入过程首先是根据一般二叉查找树的插入步骤， 把新结点 插入到 某个叶结点的位置上，然后将 z 着 为红色。 为了保证红黑树的性质能继续保 持，再对有关结点重点着色并旋转，其插入算法如下： [2] 

RB-INSERT (T,z) {

1 按二叉查找树的插入步骤将结点 z 插入到 T 中；

2 color[z]=RED；

3 while(z 不是根结点 &&color[z->parent]= =RED) {Insert-Fixup(T,z);}

4 color[root[T]]=BLACK； } [2] 

对上述算法分析，如果新插入的是黑色结点，那么它所在的路径上就多出一个黑色的结点，所以新插入的结点一定要设成红 色。 但是如果 z 的父结点也是红色，这就违反了每个红色结点的两个子结点都黑色的性质。 [2] 

### 2.结点删除算法

与红黑树的的插入算法一样，对一个结点的删除算法要花 O(log n)时间，只是删 除算法略微复杂些，删除算法如下： [2] 

RB-DELETE(T,z) {

1 if (z 的左右子结点均为 NIL)

2 { NIL 结点代替 z 的位置； delete(z); }

3 else if (z 有一个子结点为 NIL)

4 {z 的非 NIL 子结点代替 z 的位置；delete(z); }

5 else

6 {将红黑树中序遍历中 z 的后继结点 s 的值赋给 z; delete(s); }

7 if (删除的结点是黑色的) Delete-Fixup(T,x); /*x 指向代替删除结点的结点 */ } [2] 

对以上算法分析，若删除的结点是红色，则不做任何操作，红黑树的任何属性都不会被破坏；若删除的结点是黑色的，显然它所 在的路径上就少一个黑色结点，红黑树的性质就被破坏了，这时执行一个 Delete-Fixup（）来修补这棵树。 一个结点被删除之后，一定 有一个它的结点代替了它的位置，即使是叶结点被删除后，也会有一个空结点来代替它的位置。 设指针 x 指向这个代替位置的结点，同时引入指向 x 兄弟的指针 w，这里均假设 x 是 x->parent 的左子结点，则 w 是 x->parent 的右子结点，如果实际遇到相反的情 况，只要把所有操作中的左、右 互反一下就可以了。

（图一图二如下）

[![图2    Delete-Fixup（T，x）修补过程示意图](https://bkimg.cdn.bcebos.com/pic/203fb80e7bec54e7f5738147b6389b504ec26ac8?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/红黑树/2413209/0/203fb80e7bec54e7f5738147b6389b504ec26ac8?fr=lemma&ct=single)图2 Delete-Fixup（T，x）修补过程示意图

[![图1   Insert-Fixup(T,z)修补过程示意图](https://bkimg.cdn.bcebos.com/pic/9358d109b3de9c823b9c62d66381800a18d843ea?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/红黑树/2413209/0/9358d109b3de9c823b9c62d66381800a18d843ea?fr=lemma&ct=single)图1 Insert-Fixup(T,z)修补过程示意图

操作
---

[编辑](javascript:;)[ 语音](javascript:;)

在红黑树上只读操作不需要对用于二叉查找树的操作做出修改，因为它也是二叉查找树。但是，在插入和删除之后，红黑属性可能变得违规。恢复红黑属性需要少量(O(log n))的颜色变更（这在实践中是非常快速的）并且不超过三次[树旋转](https://baike.baidu.com/item/树旋转)（对于插入是两次）。这允许插入和删除保持为 O（log n)）次，但是它导致了非常复杂的操作。 [3] 

用途
---

[编辑](javascript:;)[ 语音](javascript:;)

### 1.Linux非实时任务调度中的应用

Linux 的稳定内核版本在 2． 6． 24 之后，使用了新的调度程序 CFS，所有非实时可运行进程都以虚拟运行时间为 key 值挂在一棵红黑树上，以完成更公平高效地调度所有任务。CFS 弃用 active /expired 数组和动态计算优先级，不再跟踪任务的睡眠时间和区别是否交互任务，并且在调度中采用基于时间计算键值的红黑树来选取下一个任务，根据所有任务占用 CPU 时间的状态来确定调度任务优先级。 [3] 

### 2.Linux虚拟内存中的应用

32 位 Linux 内核虚拟地址空间划分 0 － 3G 为用户空间，3 － 4G 为内核空间，因此每个进程可以使用 4GB的虚拟空间。同时，Linux 定义了虚拟存储区域( VMA) 以便于更好表示进程所使用的虚拟空间，每个 VMA是某个进程的一段连续虚拟空间，其中的单元具有相同的特征，所有的虚拟区域按照地址排序由指针链接为一个链表。当发生缺页中断时搜索 VMA 到指定区域时，则需要频繁操作，因此选用了红黑树以减少查找时间。 [3] 

### 3.检测树的平衡性上的应用

红黑树是一种自[平衡二叉搜索树](https://baike.baidu.com/item/平衡二叉搜索树/3316105)，它的每个结点都被“着色”为红色或者黑色，这些结点的颜色被用来检测树的平衡性。红黑树作为[嵌入式数据库](https://baike.baidu.com/item/嵌入式数据库/6484152)中的索引机制，可以获得更好的性能，对于SQLite数据库，可以采用红黑树实现索引机制的优化。 [6] 

数据结构简述
---

[编辑](javascript:;)[ 语音](javascript:;)

[![红黑树](https://bkimg.cdn.bcebos.com/pic/e4dde71190ef76c641326b589d16fdfaae5167e5?x-bce-process=image/resize,m_lfit,w_440,limit_1/format,f_auto)](https://baike.baidu.com/pic/红黑树/2413209/0/8cf0d513af89ac60dc540106?fr=lemma&ct=single)红黑树

它的统计性能要好于[平衡二叉树](https://baike.baidu.com/item/平衡二叉树)（有些书籍根据作者姓名，Adelson-Velskii和Landis，将其称为AVL-树），因此，红黑树在很多地方都有应用。目前，基于拥有上述特性，红黑树已广泛应用Linux 的进程管理、内存管理，设备驱动及虚拟内存跟踪等一系列场景中。 [3] 其他[平衡树](https://baike.baidu.com/item/平衡树)还有：[AVL](https://baike.baidu.com/item/AVL)，[SBT](https://baike.baidu.com/item/SBT)，[伸展树](https://baike.baidu.com/item/伸展树)，[TREAP](https://baike.baidu.com/item/TREAP)等等。

















图
===

1、基本概念
---

在图论中，图(Graph)是一种数学结构，用于描述一组对象之间的关系。图分为有向图(Directed Graph)和无向图(Undirected Graph)。表示图的方法有多种，最常用的是`邻接矩阵`和`邻接表`。



1. 图(Graph)：由顶点(Vertices)和边(Edges)构成。
2. 无向图(Undirected Graph)：边没有方向。
3. 有向图(Undirected Graph)：边有方向。
4. 路径(Path)：从一个节点到另一个节点的序列。
5. 邻接矩阵(Adjacency Matrix)：使用二维数组表示图。
6. 邻接表(Adjacency List)：使用链表数组表示图。







![image-20211112213308349](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122133438.png)





> 可以理解为所有的图结构都是有向图，只是无向图相当于两点之间有两条有向边！

![image-20211112214719717](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122147823.png)







2、图的算法
---

>自己画个图不难，但是要怎么表达这张图呢?



无向图：

![image-20211112235951538](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122359893.png)



1. 遍历算法：
   - 深度优先搜索(Depth First Search,DFS)
   - 广度优先搜索(Breadth First Search BFS)
2. 最短路径算法：
   - Dijkstra算法
   - Bellman-Ford算法
   - FIoyd-Warshall算法
3. 最小生成树算法：
   - Prim算法
   - Kruskal算法
4. 拓扑排序(适用于有向无环图)：
   - Kahn算法
   - DFS算法



### 1、邻接表法

邻接表是一种常用的图的表示方法，适合稀疏图。每个顶点对应一个链表，链表中的节点表示与该顶点相连的其它顶点。

邻接表(Adjacency List)：**使用数组或链表的列表来表示图**，**每个节点都有一个链表，链表中存储与该节点相邻的所有节点**。

在表中定义的每个节点之间定义长度，在表中不但存储节点还会在节点中伴随节点之间到达的长度

![image-20211113000416705](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111130004145.png)





#### (1).无向图的邻接表

```java
import java.util.LinkedList;
import java.util.List;

class Graph {
    private int vertices; // 顶点数
    private List<Integer>[] adjList; // 邻接表

    public Graph(int vertices) {
        this.vertices = vertices;
        adjList = new LinkedList[vertices];
        for (int i = 0; i < vertices; i++) {
            adjList[i] = new LinkedList<>();
        }
    }

    // 添加边
    public void addEdge(int src, int dest) {
        adjList[src].add(dest);
        adjList[dest].add(src); // 无向图添加双向边
    }

    // 打印邻接表
    public void printGraph() {
        for (int i = 0; i < vertices; i++) {
            System.out.print("Vertex " + i + ":");
            for (Integer vertex : adjList[i]) {
                System.out.print(" -> " + vertex);
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Graph graph = new Graph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);

        graph.printGraph();
    }
}
```







#### (2).有向图的邻接表表示

```java
import java.util.LinkedList;
import java.util.List;

class DirectedGraph {
    private int vertices; // 顶点数
    private List<Integer>[] adjList; // 邻接表

    public DirectedGraph(int vertices) {
        this.vertices = vertices;
        adjList = new LinkedList[vertices];
        for (int i = 0; i < vertices; i++) {
            adjList[i] = new LinkedList<>();
        }
    }

    // 添加边
    public void addEdge(int src, int dest) {
        adjList[src].add(dest); // 有向图添加单向边
    }

    // 打印邻接表
    public void printGraph() {
        for (int i = 0; i < vertices; i++) {
            System.out.print("Vertex " + i + ":");
            for (Integer vertex : adjList[i]) {
                System.out.print(" -> " + vertex);
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        DirectedGraph graph = new DirectedGraph(5);
        graph.addEdge(0, 1);
        graph.addEdge(0, 4);
        graph.addEdge(1, 2);
        graph.addEdge(1, 3);
        graph.addEdge(1, 4);
        graph.addEdge(2, 3);
        graph.addEdge(3, 4);

        graph.printGraph();
    }
}
```















### 2、邻接矩阵

​	邻接矩阵是一个二维数组，矩阵中的元素表示图中顶点之间的连接关系。对于一个有向图，矩阵中的每个元素`A[i][j]`表示从顶点`i`到顶点`j`的边的权重。如**果没有边，则这个元素为0(或使用一个特定的符号如`∞`表示无穷大)**，适合稠密图。



![image-20211113000621620](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111130006181.png)





#### (1)无向图的邻接矩阵表示

```java
/**
 * @author: LiHao
 * @program: interview
 * @description: 无向图G1的邻接矩阵，遍历边的方法
 * thinking:
 * 定义邻接矩阵：直接使用给定的邻接矩阵。
 * 提取边列表：
 * extractEdges 方法遍历邻接矩阵的上三角部分。
 * 如果发现 adjMatrix[i][j] == 1，则将 (i, j) 加入边列表。
 * 打印边列表：遍历边列表并打印每一条边。
 * <p>
 * <p>
 * 原始G1:
 * {0, 1, 0, 0, 1},
 * {1, 0, 1, 1, 1},
 * {0, 1, 0, 1, 0},
 * {0, 1, 1, 0, 1},
 * {1, 1, 0, 1, 0}
 * <p>
 * <p>
 * 输出：
 * 图 G1 的边列表:
 * (0, 1)
 * (0, 4)
 * (1, 2)
 * (1, 3)
 * (1, 4)
 * (2, 3)
 * (3, 4)
 */
public class GraphG1FromMatrix {
    public static void main(String[] args) {
        int[][] adjMatrix = {
                {0, 1, 0, 0, 1},
                {1, 0, 1, 1, 1},
                {0, 1, 0, 1, 0},
                {0, 1, 1, 0, 1},
                {1, 1, 0, 1, 0}
        };

        //定义图G1的边列表
        int length = adjMatrix.length;
        int[][] edges = extractEdges(adjMatrix, length);

        //打印提取的边
        System.out.println("图 G1 的边列表:");

        for (int[] edge : edges) {
            System.out.println("(" + edge[0] + "," + edge[1] + ")");
        }

        /**
         * 1.初始化邻接矩阵
         * 首先，创建一个n X n的矩阵(其中n是顶点数量)，初始值全部设置为0。
         *
         * 2.遍历边列表
         * 对于边列表中的每条边(i,j)，在邻接矩阵中将对应位置设置为1。由于是无向图，还需将对称位置(j,i)设置为1。
         *
         * 详细步骤：
         * 1.创建一个n x n的零矩阵
         *  假设图G1有5个顶点，所以创建一个5 X 5的零矩阵
         *
         * 2.遍历边列表并更新邻接矩阵：
         * 图 G1 的边列表:
         * (0,1)
         * (0,4)
         * (1,2)
         * (1,3)
         * (1,4)
         * (2,3)
         * (3,4)
         *
         * 对于每条边(i,j),设置adjMatrix[i][j] = 1 和 adjMatrix[j][i] = 1。
         */
        //示例代码
        //顶点数量 = length,边列表 = edges

        int[][] adjMatrixResult = getAdjMatrix(edges, length);
        printAdjMatrix(adjMatrixResult, length);
    }

    /**
     * 从给定的邻接矩阵中提取无向图的所有边，并以二维数组的形式返回这些边。
     * 每条边由两个整数表示，分别是边的起点和终点在邻接矩阵中的索引（假设节点索引从0开始）。
     *
     * @param adjMatrix 一个二维整型数组，表示图的邻接矩阵。adjMatrix[i][j]=1表示节点i与节点j之间存在边。
     * @param length    图中节点的数量，用于确定邻接矩阵的遍历范围。
     * @return 一个二维整型数组，其中每个一维数组表示一条边，包含两个元素分别表示边的起点和终点索引。
     */
    public static int[][] extractEdges(int[][] adjMatrix, int length) {
        //初始化一个动态数组来存储边
        List<int[]> edgeList = new ArrayList<>();

        //遍历上三角部分的邻接矩阵
        for (int i = 0; i < length; i++) {
            for (int j = i + 1; j < length; j++) {
                if (adjMatrix[i][j] == 1) {
                    //如果存在边，则将其添加到边列表中
                    edgeList.add(new int[]{i, j});
                }
            }
        }
        //将动态数组转换为二维数组
        int[][] edges = new int[edgeList.size()][2];
        for (int i = 0; i < edgeList.size(); i++) {
            edges[i] = edgeList.get(i);
        }

        return edges;
    }

    /**
     * 根据边集构建无向图的邻接矩阵。
     * 无向图中的每条边连接两个顶点，邻接矩阵是一个二维数组，其中的每个元素表示对应顶点之间是否有边相连。
     * 如果顶点i和顶点j之间有边相连，则邻接矩阵中的adjMatrix[i][j]和adjMatrix[j][i]的值为1，否则为0。
     *
     * @param edges  表示无向图边集的二维数组，每个元素是一个长度为2的数组，表示一条边的两个顶点的索引。
     * @param length 无向图中顶点的数量，即邻接矩阵的维度。
     * @return 返回构建的无向图的邻接矩阵。
     */
    public static int[][] getAdjMatrix(int[][] edges, int length) {
        //初始化一个length x length的零矩阵
        int[][] adjMatrix = new int[length][length];

        //遍历边列表并更新邻接矩阵
        for (int[] edge : edges) {
            int i = edge[0];
            int j = edge[1];
            //设置矩阵对应位置为1,表示有边相连，因为是无向图,对称位置也要设置为1
            adjMatrix[i][j] = 1;
            adjMatrix[j][i] = 1;
        }
        return adjMatrix;
    }

    /**
     * 打印给定图的邻接矩阵表示。
     * 邻接矩阵是一个二维数组，其中的每个元素表示图中对应节点之间的连接状态。
     * 如果两个节点之间有边相连，则邻接矩阵中的对应元素值通常为1；若无连接，则为0。
     *
     * @param adjMatrix 图的邻接矩阵表示。
     * @param length    图中节点的数量，用于确定邻接矩阵的大小。
     */
    public static void printAdjMatrix(int[][] adjMatrix, int length) {
        //打印邻接矩阵
        System.out.println("图G1的邻接矩阵表示:");
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                System.out.print(adjMatrix[i][j] + "  ");
            }
            System.out.println();
        }
    }
}

```





#### (2)有向图的邻接矩阵表示



##### 示例

假设我们有一个有向图如下所示：

```css
A → B → C
↑    ↘
└───→ D
```

顶点为 `A`, `B`, `C`, `D`，并假设所有边的权重都是1。



##### 邻接矩阵表示

```css
     A  B  C  D
  A  0  1  0  1
  B  0  0  1  1
  C  0  0  0  0
  D  1  0  0  0
```



##### Java代码

```java
/**
 * @author: LiHao
 * @program: interview
 * @description: 无向图邻接矩阵
 * thinking:
无向图如下:
A → B → C
↑    ↘
└───→ D

 最终输出
邻接矩阵：
0 1 0 1
0 0 1 1
0 0 0 0
1 0 0 0
图中的边:
从顶点 A 到顶点 B 的边，权重: 1
从顶点 A 到顶点 D 的边，权重: 1
从顶点 B 到顶点 C 的边，权重: 1
从顶点 B 到顶点 D 的边，权重: 1
从顶点 D 到顶点 A 的边，权重: 1
 */
public class GraphAdjacentMatrixExample {
    public static void main(String[] args) {
        //定义邻接矩阵
        int[][] adjacencyMatrix = {
                //A  B  C  D
                {0, 1, 0, 1}, //A
                {0, 0, 1, 1}, //B
                {0, 0, 0, 0}, //C
                {1, 0, 0, 0}  //D
        };

        //打印邻接矩阵
        printAdjacentMatrix(adjacencyMatrix);

        //打印图中的所有边
        printEdges(adjacencyMatrix);
    }

    //打印邻接矩阵的函数
    public static void printAdjacentMatrix(int[][] matrix) {
        System.out.println("邻接矩阵：");
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[i].length; j++) {
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }

    // 打印图中所有边的函数
    public static void printEdges(int[][] matrix) {
        int size = matrix.length;

        System.out.println("图中的边:");

        // 打印所有的边
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (matrix[i][j] != 0) {
                    System.out.println("从顶点 " + getVertexLabel(i) + " 到顶点 " + getVertexLabel(j) + " 的边，权重: " + matrix[i][j]);
                }
            }
        }
    }

    // 辅助函数，用于将顶点索引转换为顶点标签 (例如: 0 -> A, 1 -> B)
    public static String getVertexLabel(int index) {
        return String.valueOf((char) ('A' + index));
    }
}

```







#### (3)基于邻接矩阵的有向图和无向图区别

在图论中，有向图(Directed Graph)和无向图(Undirected Graph)是两种不同类型的图，它们的主要区别在于边的方向性。基于邻接矩阵表示，这些区别具体表现如下：



> **有向图(Directed Graph)**

1. **边有方向**：在有向图中，边是有方向的，从一个顶点指向另一个顶点。
2. 邻接矩阵表示：邻接矩阵中的元素`A[i][j]`表示从顶点`i`到顶点`j`的边的权重。**如果没有边，则该元素为0(或其它特定符号如`∞`)。**
3. 矩阵**非对称**：对于有向图，邻接矩阵通常是非对称的。即`A[i][j]`不一定等于`A[j][i]`。





>无向图(Undireced Graph)

1. **边无方向**：在无向图中，边没有方向性，连接两个顶点的边可以从任意一端到达另一端。
2. 邻接矩阵表示：邻接矩阵中的元素`A[i][j]`表示顶点`i`和顶点`j`**之间的边的权重**。如果没有边，则该元素为0(或其它特定符号如`∞`)。
3. **矩阵对称**：对于无向图，邻接矩阵是对称的，即`A[i][j]`等于`A[j][i]`。









常见图的算法题表示形式：

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111142333628.png" alt="image-20211114233316955" style="zoom:67%;" />





![image-20211114233425911](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111142334055.png)





> 注意

由于图的算法及表现形式千变万化，有一种方式就是将算法A，算法B，算法C，算法D，在遇到面/笔试相关图的算法时候，将它所表示的形式转换为你比较熟悉的这种表示形式。

这样的话你就必须要知道别的表示形式如何才能转换你熟悉的这种表示形式，还有就是要将你熟悉的表示形式的图算法题目刷到滚瓜烂熟。





例如用**点描述方法**来表示图的中的一个点：

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111142354753.png" alt="image-20211114235407421" style="zoom: 67%;" />

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111142353413.png" alt="image-20211114235338150" style="zoom: 80%;" />

长度术语为：权重



> 那么如何将不熟悉的图的表示类型转换为自己熟悉的例如点from形式呢？

如果是邻接矩阵的话，遍历矩阵，当遍历到的当前表格中存储的是有效值就为它们之间建立一条长度相同的边

可以编写一个转换方法的接口，每次编写的时候，直接调用转换即可

![image-20211116213744321](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111162137423.png)

![image-20211116213752506](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111162137595.png)

![image-20211116213806643](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111162138764.png)

如此一来，当遇到不熟悉的图的表示形式，直接转换此点form方法的表示形式再来编写操作对应的代码即可实现！

![image-20211116214110456](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111162141516.png)

![image-20211116214026361](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111162140426.png)

图的算法，先行跳过。









>指定一个节点作为原点，统计从原点到有向图中所有的节点的最优路线，也就是到达各节点的权重累加最短。如果到达不了就记为(正无穷)*。

![image-20211117114503215](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111171145399.png)















> 例题：给出加权连通图中一个顶点，称之为起点，找出起点到其它所有顶点之间的最短距离。

![image-20211117155655454](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111171556558.png)

```java
/**
    Dijkstra算法功能：给出加权连通图中一个顶点，称之为起点，找出起点到其它所有顶点之间的最短距离。
Dijkstra算法思想：采用贪心法思想，进行n-1次查找（n为加权连通图的顶点总个数，除去起点，则剩下n-1个顶点），第一次进行查找，找出距离起点最近的一个顶点，标记为已遍历；下一次进行查找时，从未被遍历中的顶点寻找距离起点最近的一个顶点， 标记为已遍历；直到n-1次查找完毕，结束查找，返回最终结果。
思路(类似贪心)：
    1.先建立表，假设A为原点
    2.A到其它所有元素的权重都先默认是正无穷(不可达)
    3.然后再去根据具体位置数值再进行更新
    4.【固定A】先固定原点A，然后看看，从A到其它点的距离看看能不能更新,与A原点之间可以走向B,C,D三点
      已知刚开始的时候，B,C,D下面对应的三个数值都是正无穷A到B,C,D之间的距离都会比正无穷要小，所以，对应	  全部都更新，所以：
      4.1.B点下面更新为：1，C点下面更新为7，D点下面更新为6，更新完毕,A点已经使用过了,将它锁定为不可更改
        !现在的表对应数值应该是[A,0],[B,1],[C,7],[D,6]
    5.【固定B】最左边的A处理完了，接下来就该处理B了,然后如上图可以看出，B可以到达的点为:C,E
      5.1由于A到C的距离是7所以上一次C对应的数值是7,但是发现一个问题：
        从A-B距离权重的是1,再从B到C是2,也就是从A-B-C = 1 + 2  = 3 < 原来的7,更新数值,C下面就对应的		  是3了
        B到E是170再加上A-B的1，也就是171了，也比E下面的正无穷要小，所以更新，由此固定B不再动了
        !现在的表数值[A,0],[B,1],[C,3],[D,6],[E,171]
    6.【固定C】C可到达D,E对比一下,由于上次表C更新的路径是从A-B-C这样就是3所以直接拿3对比
      [A-B-C]-D = 3 + 2 = 5 < 原来的6,更新D对应5
      A-C-E = 7 + 23 = 30 < 171 更新：此时E对应30了,将C固定
      !现在的表数值[A,0],[B,1],[C,3],[D,5],[E,30]

    7.【固定D】D可达E点对比
        D-E = A-B-C-D-E = 1 + 2 + 2 + 4 = 9 < 30 更新
        !现在的表数值[A,0],[B,1],[C,3],[D,5],[E,9]
    8.【固定E】由于E无路可走可走,都认为是正无穷，就无需更新了。所以最终固定结果集合为
      [A,0],[B,1],[C,3],[D,5],[E,9]
    注意：如果对应的更新的路径长度权重与原表中记录相同，可根据题意选择，更新还是不更新,默认还是选择不更新
         且整个图并没有负数的边，所以这么跳一定是对的。
*/
```



<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111171630112.png" alt="image-20211117163053986" style="zoom:50%;" />



代码实现：
![image-20211117174525309](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111171745458.png)

![image-20211117174629607](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111171746703.png)



















![image-20211117180313751](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111171803862.png)



















在图中找到从原点到指定的每个节点之间的最小路径，并制定成表



> 思路

刚开始，指定从原点位置为0，将其固定不改变值，然后遍历其它节点，并且遍历到当前节点时，除了从A起始点到此节点是固定长度以为，到其它路线是否比刚开始存起来的从原点到该节点的长度要短，相同就不更新，不同，并且这样子的长度比原来的要短，就更新。



![image-20211019195141379](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110191951844.png)

也就是拿当前最优路线的节点，下一个节点的长度是否可以优化！











![image-20211019201150394](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110192011707.png)







![image-20211019201317256](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110192013468.png)



示例代码：
![image-20211020083258260](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110200832526.png)

![image-20211020083333904](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110200833073.png)



由于每次都需要遍历很多集合，所以，需要改进一下上述代码！



> 利用小根堆来实现优化：

思路：
	小根堆要实现三大功能：

1. 添加对应路径值，按照值的大小，递增排序
2. 更新更短的路径长度值
3. 拒绝更新功能：也就是要判断更短的路径长度确实能更短就更新，大于或者等于已经保存的长度了，就拒绝更新此路径长度。



示例代码：
	![image-20211020084944344](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110200850389.png)



![image-20211020085140435](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110200851582.png)

如上述：如果是没有此路径节点值，就add，如果是更短的路径就Update，如果是A,0或者比原表的更长/相等的路径就Ignore(当做无意义，跳过)。























































贪心算法
===



![image-20211021233716199](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212337756.png)



![image-20211021233857779](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212338304.png)



![image-20211021234212479](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212342927.png)

例如需要支付14元，那么按照贪心算法的要求来，一定是先选择一张10元的钞票，接下来就是4张1元的钞票

贪心算法就不成立了。





![image-20211021234509970](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212345515.png)



![image-20211021234701371](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212347939.png)



![image-20211021235211166](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212352721.png)

![image-20211021235547539](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212355038.png)

![image-20211022001515486](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110220018860.png)



![image-20211022001811378](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110220018002.png)



![image-20211022002011732](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110220020103.png)















![image-20211022003317449](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110220033840.png)



![image-20211022105634197](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221056615.png)









![image-20211022175852312](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221758687.png)



























暴力递归
===



递归思路
---

**暴力递归就是尝试**

1. 把问题转化为规模缩小了的同类问题的子问题
2. 有明确的不需要继续进行递归的条件(base case)
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解

注意：不记录每一个子问题的解就是暴力，记录每一个子问题的解就是动态规划











例题
---

**汉诺塔问题描述**：

> 大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。



![image-20211117181144496](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111171811625.png)



> 打印n层汉诺塔从最左边移动到最右边的全部过程(只能小压大)



三层汉诺塔

![image-20211117191740533](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111171917682.png)

```java
/**
1.【1~n-1移动到中间】想办法如上[1,2]或者为[1,n-1]层的圆盘想办法移动到中间,然后最下面的第3或者是n层就可以移动到右柱了
2.【n从左柱移到右柱】将n移动从左移动到右
3.再将中间的[1,2]或者是1~n-1层的圆盘移动到右柱上就可以完成任务了
注意：第n层圆盘想要出来就必须要想办法把它上面的所有圆盘都移走才可以动
*/
```



三层汉诺塔每一步解析：

![image-20211117202817774](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111172028876.png)







#### [08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

难度简单117

在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

**示例1:**

```
 输入：A = [2, 1, 0], B = [], C = []
 输出：C = [2, 1, 0]
```

**示例2:**

```
 输入：A = [1, 0], B = [], C = []
 输出：C = [1, 0]
```

**提示:**

1. A中盘子的数目不大于14个。

通过次数24,851

提交次数37,890



![image-20211117204022349](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111172040744.png)



```java
/**100 + 6.81
思路：
    1.将1~n-1层的圆盘从左柱移动到中柱(为的是给左柱腾出位置)
    2.将第n层圆盘从左到右
    3.再将1~n-1从中间移动到右边
 */
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        int num=A.size();
        RA(num, A, B, C);
    }

    private void RA(int num, List<Integer> a, List<Integer> b, List<Integer> c) {
        if (num==1){
            //当num == 1的时候直接移就完了
            c.add(a.remove(a.size()-1));
        }else{
            //1.给n腾位置将1~n-1从a柱到b柱
            RA(num-1,a,c,b);
            //2.将a柱上的最后一个先行移动到c柱上
            c.add(a.remove(a.size()-1));
            //3.将剩余的从1~n-1从b柱移动到最后的c柱上
            RA(num-1,b,a,c);
        }
    }
}
```







> 汉诺塔问题总结

$$
T(N) = T(N-1) + 1 + T(N-1)
$$

$$
T(N) = 2^N - 1 步
$$















![image-20211118094333449](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111180943863.png)

![image-20211118095446849](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111180954065.png)

```java
/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2021/11/18 10:30
 * @TODO：给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数，如何实现？
 * @Thinking:
 */
public class f {
    public static void main(String[] args) {
        //测试数据：定义一个栈依次装入3,2,1
        Stack<Integer> stack = new Stack<>();
        stack.push(3);
        stack.push(2);
        stack.push(1);
        
//        f(stack);//1 2
        
        reverse(stack);
        while (!stack.isEmpty()){
            
            //3 2 1 
            System.out.print(stack.pop() + " ");
        }
    }

    public static void reverse(Stack<Integer> stack){
        if (stack.isEmpty()){
            return;
        }
        int i = f(stack);
        reverse(stack);
        stack.push(i);
    }

    //1.实现返回3出来,栈中从上往下剩1,2
    public static int f(Stack<Integer> stack){

        int result = stack.pop();
        if(stack.isEmpty()){
            return result;
        }else{
            int last = f(stack);
            stack.push(result);
            return last;
        }

    }
}
```













递归
---

> 打印一个字符串的全部子序列

拆分问题：

1.打印一个字符串的全部子串(从头开始,以不断++的i号位置的字符为起始点)。

用for循环来实现一下。

![image-20211118213248219](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111182132339.png)









2.每个位置的字符==要和不要==都走一遍

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111181909082.png" alt="image-20211118190929268" style="zoom: 50%;" />



![image-20211118203618101](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111182036236.png)

```java
package string.String2;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @TODO：输入一个非空字符串s,求它的所有子序列的集合
 * @Thinking:
 对应字符串中的每一个下标位都有两种可能就是选和不选,然后递推得出并保存所有的结果集
    注意：好马不吃回头草

 输入格式：
 1.就是字符串的长度
 接下来输入的字符的每一个字符
 */
public class f {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        String s = "";
        int len = 1;
        while (len > 0){
            s += sc.nextLine();
            len--;
        }
        result(s);


    }

    //获取结果集并打印
    public static void result(String s){
        char[] c = s.toCharArray();
        List<String> list = new ArrayList<>();
        //定义空串传入
        String s1 = "";
        fc(c, 0 , s1 , list);
        for (int i = 0; i < list.size(); i++) {
            if(i == list.size() - 1){
                System.out.print("[" + list.get(i) + "]");
                break;
            }
            System.out.print("[" + list.get(i) + "]" + ",");
        }
    }


    //字符数组c固定不变，此时来到当前位置index两种选择：要或不要
    //如果index都走完了字符数组c，就将这一步一路走来的答案保存
    //之前的要或者不要就是下一次的path;
    public static void fc(char[] c,int index,String path,List<String> list){
        //到了最后一个字符就结算
        if(index == c.length){
            list.add(path);
            return;
        }

        //不要
        String no = path;
        fc(c,index + 1,no,list);

        //需要
        String yes = path + String.valueOf(c[index]);
        fc(c,index + 1,yes,list);
    }
}
```







> 打印一个字符串的全部子序列，要求不要出现重复字面值得子序列

在上一步的基础上利用set的无法存储重复的值来做就好





> 打印一个字符串的全部排列



![image-20211118195849831](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111181958972.png)

关于为什么替换完成之后还需要恢复原来没有替换的样子呢？

- 首先看**下图中黄色部分**(递归执行的顺序)，如果不把它每次都恢复过来，那么怎么下一步操作，就必然会影响最终结果集！回到某个位置，必然需要将它恢复到那个位置的排列才可以正确执行下一步操作结果集。

![image-20211118200838997](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111182008092.png)







![image-20211118201414351](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111182014506.png)





> 打印一个字符串的全部排列，要求不要出现重复的排列

方法一：可以在上题实现中，将ArrayList集合替换为HashSet集合即可完成去重。







方法二：分支限界

人为的给它增加限制，也就是说，在出现没有必要的过程的时候，在源头处将它杀死！

![image-20211118202553426](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111182025559.png)



















>###### 手撕字符串全排列

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/1/24 17:00
 * @TODO：手撕字符串的全排列
 * @Thinking:
   1.输入一个字符串
   2.将字符串从i位置与后面的所有元素不断进行交换实现全排列
 */
public class mian {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //输入一个字符
        int s = 1;
        String str = "";
        while(s > 0){
            str = sc.nextLine();
            s--;
        }
        //所有排列的总集合
        List<String> Lists = new ArrayList<>();
//        String str = "abc";

        //前置判断
        if(str == null || str.length() == 0){
            System.out.println("请输入有效字符!");
            return;
        }

        //将字符串转换为char型数组
        char[] chars = str.toCharArray();
        //递归全排列
        process(chars,0,Lists);

        for (int i = 1; i < Lists.size(); i++) {
            System.out.print(Lists.get(i) + " ");
            //当%10的时候，实际上已经到了第11位,所以最开始就是到第9号位,后面的情况都是一致的
            if(i == 10){
                System.out.println();
                continue;
            }
            if (i % 10 == 0 && i != 0){
                System.out.println();
            }
        }

    }


    //递归全排列
    public static void process(char[] str, int i, List<String> list){
        //1.递归终止条件,当递归到字符串最后一个字符
        //也就是说,当前i位置后面的已经全部替换。
        if(i == str.length){
            list.add(String.valueOf(str));
        }


        for (int j = i; j < str.length; j++) {
            swap(str,i,j);
            //递归下一次
            process(str,i+1,list);
            //恢复
            swap(str,i,j);
        }
    }

    //交换
    public static void swap(char[] str,int i,int j){
        char c = str[i];
        str[i] = str[j];
        str[j] = c;
    }
}
```





##### 怎么祛除全排列中重复的部分呢？



>将ArrayList集合替换成HashSet集合

利用HashSet本身就具有不可重复的特点进行去重。尽管这样可以去除重复，但是本身利用集合的特性，还是用到了额外的空间资源消耗，所以，显然并不是最优解。

```java
import java.util.*;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/1/24 17:00
 * @TODO：手撕字符串的全排列(利用HashSet去除重复)
 * @Thinking:
   1.输入一个字符串
   2.将字符串从i位置与后面的所有元素不断进行交换实现全排列
   3.利用HashSet集合不可重复特性去除全排列的重复值
 */
public class mian {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //输入一个字符
        int s = 1;
        String str = "";
        while(s > 0){
            str = sc.nextLine();
            s--;
        }
        //所有排列的总集合
        Set<String> Lists = new HashSet<>();
//        String str = "abc";

        //前置判断
        if(str == null || str.length() == 0){
            System.out.println("请输入有效字符!");
            return;
        }

        //将字符串转换为char型数组
        char[] chars = str.toCharArray();
        //递归全排列
        process(chars,0,Lists);
        int start = 1;
        for (String ss : Lists){
            System.out.print(ss + " ");
            if (start % 10 == 0 && start != 0){
                System.out.println();
            }
            start++;
        }
    }


    //递归全排列
    public static void process(char[] str, int i, Set<String> list){
        //1.递归终止条件,当递归到字符串最后一个字符
        //也就是说,当前i位置后面的已经全部替换。
        if(i == str.length){
            list.add(String.valueOf(str));
        }


        for (int j = i; j < str.length; j++) {
            swap(str,i,j);
            //递归下一次
            process(str,i+1,list);
            //恢复
            swap(str,i,j);
        }
    }

    //交换
    public static void swap(char[] str,int i,int j){
        char c = str[i];
        str[i] = str[j];
        str[j] = c;
    }
}
```











>分支限界去重

大意：分支限界也是暴力递归，但是是提前杀死无用之路的递归，也就是在没有必要的线路在源头处就杀死，效率非常高。

利用全字符boolean数组进行分支限界去除重复排列

```java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/1/24 17:00
 * @TODO：手撕字符串的全排列(分支限界去除重复值)
 * @Thinking:
    1.输入一个字符串
    2.将字符串从i位置与后面的所有元素不断进行交换实现全排列
    3.在全排列的基础上分支限界去除重复值
    4.利用26位全字符数组进行判断,默认全部为false
        4.1.当前遍历的到的字符出现过一次,对应在全字符数组中就变为true,当此字符再次出现时,杀死此分支!
 */
public class mian {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //输入一个字符
        int s = 1;
        String str = "";
        while(s > 0){
            str = sc.nextLine();
            s--;
        }
        //所有排列的总集合
        List<String> Lists = new ArrayList<>();
//        String str = "abc";

        //前置判断
        if(str == null || str.length() == 0){
            System.out.println("请输入有效字符!");
            return;
        }

        //将字符串转换为char型数组
        char[] chars = str.toCharArray();
        //递归全排列
        process(chars,0,Lists);

        for (int i = 1; i < Lists.size(); i++) {
            System.out.print(Lists.get(i) + " ");
            //当%10的时候，实际上已经到了第11位,所以最开始就是到第9号位,后面的情况都是一致的
            if(i == 10){
                System.out.println();
                continue;
            }
            if (i % 10 == 0 && i != 0){
                System.out.println();
            }
        }

    }


    //递归全排列
    public static void process(char[] str, int i, List<String> list){
        //1.递归终止条件,当递归到字符串最后一个字符
        //也就是说,当前i位置后面的已经全部替换。
        if(i == str.length){
            list.add(String.valueOf(str));
        }

        //26位全字符串数组对应每个字符串进行-'a'后对应的位置分支限界
        boolean[] visit = new boolean[26];
        
        for (int j = i; j < str.length; j++) {
            if(!visit[str[j] - 'a']){
                //出现第一次,将对应位置置为true
                visit[str[j] - 'a'] = true;
                
                
                swap(str,i,j);
                //递归下一次
                process(str,i+1,list);
                //恢复
                swap(str,i,j);
            }
        }
    }

    //交换
    public static void swap(char[] str,int i,int j){
        char c = str[i];
        str[i] = str[j];
        str[j] = c;
    }
}
```

















![image-20211112210446238](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122104360.png)





![image-20211112210821477](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122108571.png)

















































































































































































































### 递归、回溯、分治题







![image-20211022182826690](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221829970.png)













![](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221838976.png)







![image-20211022184629240](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221846663.png)

![image-20211022184856716](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221848034.png)



![image-20211022185202823](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221852204.png)

![image-20211022185226609](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221852062.png)

![image-20211022190045853](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221900288.png)



![image-20211022190326396](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221903783.png)

![image-20211022190439742](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221904182.png)



![image-20211022192338867](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110221923221.png)



```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        //大小两集合，小集合由于需要递归不断添加后面也会不断remove()不选的元素，出来不同的集合
        List<List<Integer>> Lists = new ArrayList();
        //回溯时，产生各个子集的数组
        List<Integer> list  = new ArrayList();

        //添加空集合(这属于特殊情况)
        Lists.add(list);
        //传入参数
        dfs(0,nums,list,Lists);
        
        return Lists;
    }

    public void dfs(int i,int[] nums,List<Integer> list,List<List<Integer>> Lists){
        //判断递归结束条件
        if(i >= nums.length) return;
        //小鱼吃虾米,大鱼吃小鱼
        list.add(nums[i]);
        Lists.add(list);
        
        //第一次递归调用,有当前参数的情况
        dfs(i+1,nums,list,Lists);

        //将此元素删除,递归出来此元素不存在的情况
        list.remove(list.size()-1);
        
        dfs(i+1,nums,list,Lists);

    }
}
```























从暴力递归到动态规划
===









四种模型
---

动态规划这四种模型就已经可以处理绝多大数的面试题。也就是，当遇到动态规划类型的面试题，哪怕没有思路，利用这四种模型，硬套也能套出来。









### 从左往右尝试模型







#### 例题一

例如：全排列，是从左往右的递归模型，分为要和不要两种情况

主要是从左往右递归的模型。







> 前Facebook面试题

规定**1和A**对应、**2和B**对应、3和C对应…

那么一个数字字符串比如“111”就可以转为：

**“AAA”、”KA“和”AK“**

给定一个**只有数字字符组成的字符串str**,返回有多少种转化结果。

**注意**：0则是无法转换的，因为没有哪个字符与之替换。





思路：根据递归画多大来决定的

例如输入：

```
11111
```

按照从左往右枚举

1. 查看一个1是否可以：可以——> A 剩下1111继续递归
2. 查看一个11是否可以：可以——>K 剩下111继续递归
3. 查看一个111是否可以：不可以——> X无后续递归

当上游分支无法转换的时候，也就是后面的无需再判断，一定是无法转换的。

所以直到上游之前转换了多少，就返回多少种。

当然，也可以理解为分支限界。





> 如：10用来做转换即

1. 第一个位置的1可以转换为A，接下来就看第二个位置的0，它无法转换，即此时没有将两个位置全部转换，返回0种
2. 第一个位置的1和第二个位置的0，组合而成就是10—>J，它是有效的，全部位置都使用完毕，返回1种。
3. 而当这个0是在第一个位置的时候，此时任务已终止，无法转换。也可以理解为分支限界，当上游都已经终止了，下游自然是无法转换了。

![image-20220211171722088](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202111717247.png)









完整实现代码：

```java
import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/1/30 3:28
 规定**1和A**对应、**2和B**对应、3和C对应…
 那么一个数字字符串比如“111”就可以转为：
 **“AAA”、”KA“和”AK“**
 给定一个**只有数字字符组成的字符串str**,返回有多少种转化结果。
传入一个正整数和一个转换的char型数组
 * @TODO： * @Thinking:
思路：
    从左至右递归模型
    1.传入参数
 */
public class FacebookStr {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //输入一个正整数
        String s = sc.nextLine();

        //前置判断
        if(s == null || s.length() == 0){
            System.out.println("输入无意义，请重新输入!");
            return;
        }

        //递归
        int num = dfs(s.toCharArray(), 0);

        System.out.println("总共有"+ num +"种拼接表示形式!");

    }

    public static int dfs(char[] str,int i){
        if(i == str.length){
            return 1;
        }
        //上句已排除终止位置,所以到这里就是i并不是终止位置，出现了0
        //由题意可知，并没有字符与0对应的，所以无法替换。
        if(str[i] == '0'){
            return 0;
        }

        /**
            i没有到终止位置
            str[i]字符不是‘0’
         */
        if(str[i] == '1'){
            //i自己作为单独的部分，后续有多少种方法
            int res = dfs(str,i + 1);

            //(i 和 i+ 1)作为单独的部分，后续有多少种方法
            if(i + 1 < str.length) {
                res += dfs(str, i + 2);
            }
            return res;
        }


        if(str[i] == '2'){
            //i自己作为单独的部分，后续有多少种方法
            int res = dfs(str,i + 1);

            //(i和i+1)作为单独的部分并且没有超过26，后续有多少种方法
            //如果前面是2,那么最高拼成的就是26，最小则为20
            if(i + 1 < str.length && (str[i + 1] >= '0' && str[i + 1] <= '6')){
                //(i和i+1)作为单独的部分，后续有多少种方法
                res += dfs(str,i + 2);
            }
            return res;
        }

        //当后续有多少种方法
        //str[i] == '3' ~ '9'
        return dfs(str,i + 1);
    }
}
```





修改为动态规划

```java
    //只有一个可变参数，也就是只是一维
    public static int dpDfs(String s){
        if(s == null || s.length() == 0){
            return 0;
        }
        char[] str = s.toCharArray();
        int N = str.length;
        int[] dp = new int[N + 1];
        dp[N] = 1;
        for (int i = N - 1; i >= 0; i--) {
//            dp[i] = ?;

            if(str[i] == '0'){
                dp[i] = 0;
            }


            /**
             i没有到终止位置
             str[i]字符不是‘0’
             */
            if(str[i] == '1'){
                //i自己作为单独的部分，后续有多少种方法
                dp[i] = dp[i + 1];

                //(i 和 i+ 1)作为单独的部分，后续有多少种方法
                if(i + 1 < str.length) {
                    dp[i] += dp[i + 2];
                }
            }


            if(str[i] == '2'){
                //i自己作为单独的部分，后续有多少种方法
                dp[i] = dp[i + 1];

                if(i + 1 < str.length && (str[i + 1] >= '0' && str[i + 1] <= '6')){
                    //(i和i+1)作为单独的部分，后续有多少种方法
                    dp[i] += dp[i + 2];
                }
            }

        }

        return dp[0];
    }

}
```







所有return的时刻，都是去设置dp[i]的时刻。





此尝试过程是再度抽象化的表达。



















#### 例题二

>经典背包问题

给定两个长度都为N的数组`weights`和`values`,weights[i] 和 values[i]分别代表i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装回的物品不能超过这个重量。返回你能装下的最多的价值是多少？







方法一(并不是特别好理解)：

```java
/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/2/20 18:36
 * @TODO：描述
 * @Thinking:

说明：
    1.输入一个w[]数组,值对应表示为物品重量                当前w[i]表示为当前方格物品的重量
    2.输入一个v[]数组，值对应表示为物品价值                 当前v[i]表示为当前方格物品的价值
    3.输入一个bag值,装物品的袋子可容纳的重量
    4.变量：alreadyW表示在 0 —— index-1 上已经做了的货物选择且在没有超过bag的前提下，使得你已经达到的重量是多少alreadyW。
    5.如果返回 -1 则表示没有方案，反之，返回值为真实的价值。
 */
public class bag {
    public static void main(String[] args) {

        //物品重量数组
        int[] w = {1,2,3};
        //对应物品价值
        int[] v = {1,2,3};
        
        //袋子最大容量
        int bag = 3;

        if(w.length != v.length || w.length == 0 || v.length == 0){
            System.out.println("输入值无意义，请输入有效值!");
        }
        int s = process(w,v,0,0,bag);
        System.out.println("当前可组合容纳最大有效重量为：" + s);
    }

    //其中w和v数组,bag袋子容量为不变值
    public static int process(int[] w,int[] v,int index,int alreadyW,int bag){
        //当可承受重量大于袋子最大容量时，可以将所
        if(alreadyW > bag){
            return -1;
        }

        //如果递归完最后一个方格了,重量还是没有超的话
        //那就可以认为这个放置方案是可行的。返回0表示方案可行。
        if(index == w.length){
            return 0;
        }

        int p1 = process(w,v,index + 1,alreadyW,bag);
        int p2next = process(w,v,index + 1,alreadyW + w[index],bag);
        int p2 = -1;
        //判断当前方格物品添加后是否还是满足条件的有效重量
        if (p2next != -1){
            p2 = v[index] + p2next;
        }

        //对比出可放置物品的最大值。
        return Math.max(p1,p2);

    }
}
```



换成剩余空间来表达的方法

```java
		process1(w,v,0,bag);
        
		System.out.println("当前可组合容纳最大有效重量为：" + s);
    }


/**
     * 说明：
     * @param W 当前方格中物体的重量
     * @param V 当前方格中物体的价值
     * @param index 当前从第index开始遍历
     * @param rest  表示当前背包还剩下rest大小的空间可以用来装东西。
     * @return
     */
    public static int process1(int[] W,int[]V,int index,int rest){
        //如果剩余空间是小于0表示此方案不成立
        if(rest < 0){ //base case 1
            return -1;
        }

        //rest > 0的时候才是有可能成立,而 = 0则表示是成立的
        if(index == W.length){ //base case 2
            return 0;
        }

        //有货也有空间
        int p1 = process1(W,V,index + 1, rest);

        //初始化p2
        int p2 = -1;
        
        //传入rest = rest - 已经被占用的空间W[index]
        int p2Next = process1(W,V,index + 1,rest - W[index]);
        if(p2Next != -1){
            //当还符合题意时，让当前物品的价值 + 剩余所有的价值
            p2 = V[index] + p2Next;
        }

        return Math.max(p1,p2);

    }
}
```





动态规划(记忆化搜索)：利用缓存的方式将重复解的出现缓存，以后不重复的去求。

修改过程代码

```java
public class bag {
    public static void main(String[] args) {

        //物品重量数组
        int[] w = {1,2,3};
        //对应物品价值
        int[] v = {1,2,3};

        //袋子最大容量
        int bag = 3;

        if(w.length != v.length || w.length == 0 || v.length == 0){
            System.out.println("输入值无意义，请输入有效值!");
        }


        int s = process1(w,v,0,bag);
        int dp = dpWay(w,v,bag);
        System.out.println("当前可组合容纳最大有效重量为：" + s);
        System.out.println("dp结果为：" + dp);
    }


    /**
     * 说明：
     * @param W 当前方格中物体的重量
     * @param V 当前方格中物体的价值
     * @param index 当前从第index开始遍历
     * @param rest  表示当前背包还剩下rest大小的空间可以用来装东西。
     * @return
     */
    public static int process1(int[] W,int[]V,int index,int rest){
        //如果剩余空间是小于0表示此方案不成立
        if(rest < 0){ //base case 1
            return -1;
        }

        //rest > 0的时候才是有可能成立,而 = 0则表示是成立的
        if(index == W.length){ //base case 2
            return 0;
        }

        //有货也有空间
        int p1 = process1(W,V,index + 1, rest);

        //初始化p2
        int p2 = -1;

        //传入rest = rest - 已经被占用的空间W[index]
        int p2Next = process1(W,V,index + 1,rest - W[index]);
        if(p2Next != -1){
            //当还符合题意时，让当前物品的价值 + 剩余所有的价值
            p2 = V[index] + p2Next;
        }

        return Math.max(p1,p2);
    }



    //修改为动态规划
    public static int dpWay(int[] W,int[] V,int bag){
        int N = W.length;
        //多给一个格子
        int[][] dp = new int[N + 1][bag + 1];

        //dp[N][...] = 0;最后一行无需填，因为设定最后一行其实是下标N + 1的,默认都是0
        for (int index = N - 1; index >= 0; index--) {
            for (int rest = 0; rest <= bag; rest++) {//rest < 0
                //将原始的暴力递归过程，拆解成动态规划
                //有货也有空间
//                int p1 = process1(W,V,index + 1, rest);
                  int p1 = dp[index + 1][rest];
//                //初始化p2
//                int p2 = -1;
                  int p2 = -1;

                //保证p2next值不越界也就是 rest - W[index]不越界
                  if(rest - W[index] >= 0){
                      //传入rest = rest - 已经被占用的空间W[index]
                      //int p2Next = process1(W,V,index + 1,rest - W[index]);
                      p2 = V[index] + dp[index + 1][rest - W[index]];
                  }
                  dp[index][rest] = Math.max(p1,p2);


                  //保证p2next值不越界也就是 rest - W[index]不越界,第92行代码开始判断
//                if(p2Next != -1){
//                    //当还符合题意时，让当前物品的价值 + 剩余所有的价值
//                    p2 = V[index] + p2Next;
//                }

//                return Math.max(p1,p2);
//

            }
        }
        return dp[0][bag];
    }

}
```

最主要就是动态转移方程





















### 范围上尝试的模型

​	给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，

​	但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。



![image-20220220205433482](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202202054783.png)











##### 先后手

>假设你是后手

临界情况：如果是后手，剩下最后一张牌，那你一定是拿不到，最后取的值一定是0。

也就是：

```java
if(L == R){
    return 0;
}
```



分两种情况：

一、假设先手拿走的是arr[L]那么你的可选为：

```java
f(arr,L + 1, R);
```

二、假设先手拿走的是arr[R]那么你的可选为：

```java
f(arr,L ,R - 1);
```





而且身为后手，对手只能留给你两个中对你最不利的值

```java
Math.min(f(arr,i + 1, j),f(arr,i ,j + 1));
```





暴力递归解：

```java
/**
思路：
	先手在两端选牌，一定是先选大的那张也就是取最大
		先手在先选的时候，也就是两种情况：（假设最左边为Left【L】，最右边为right【R】）
			1.选最左边的那张牌 + 剩余给后手选
				arr[L] + S(L + 1, R);
			2.选最右边那张牌 + 剩余给后手选
				arr[R] + S(L ,R - 1);
			以上两种情况取最大的情况。
	后手在选牌的时候，一定是选择后选的那张两端相对较小的那张，
	临界问题：
		当来到最后一张牌的时候一定是先手拿走了，后手一定是拿不到return 0
		

*/
public class intelligent {
    public static void main(String[] args) {
        //输入一组牌
        int [] arr = {1,2,3,4};
        
        //前置判断
        if(arr == null || arr.length == 0){
            System.out.println("请输入有效数组!");
            return;
        }
        
        int num = f(arr,0,arr.length - 1);
        System.out.println("获胜者的最大值为："+ num);
    }

	
    //设定f为先手
    public static int f(int[] arr,int L,int R){
        //终止条件：当剩下最后一张牌，自然而言是先手的。
        if(L == R){
            return arr[L];
        }


        //先手绝顶聪明自然是拿可选两张边界牌中的最大
        return Math.max(
                //后手只能选择
                arr[L] + S(arr, L + 1,R),
                arr[R] + S(arr, L, R - 1)
        );

    }


    //后手
    public static int S(int[] arr,int i ,int j){
        //如果到了最后一张牌，肯定被先手拿了后手没份。
        if(i == j){
            return 0;
        }

        //当先手先拿，后手拿到的只能是相对小的另外一张了。
        return Math.min(
                f(arr,i + 1,j),
                f(arr, i,j - 1)
        );
    }
}
```









注意：任何范围上的尝试，正方形的左下角是无用的。

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202261638965.png" alt="image-20220226074627926" style="zoom:50%;" />



 







在尝试改为动态规划的时候，先要梳理出来空间，再标注最后return的星位。

![image-20220226075048022](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202261641580.png)



修改为动态规划

```java
//修改为动态规划
public static int WinDp(int[] arr){
    //前置判断
    if(arr == null || arr.length == 0){
        System.out.println("请输入有效数组!");
        return -1;
    }

    int len = arr.length;
    int[][] f = new int[len][len];
    int[][] s = new int[len][len];

    //对角线
    for (int i = 0; i < len; i++) {
        f[i][i] = arr[i];
    }

    //由于数组空间建立默认都是0，无需再次赋值
    //s[i][i] = 0;

    for (int i = 1; i < len; i++) {
        int L = 0;
        int R = i;

        while (L < len && R < len){
//                dp[L][R] = ?;
            //先手绝顶聪明自然是拿可选两张边界牌中的最大
//                return Math.max(
//                        //后手只能选择
//                        arr[L] + S(arr, L + 1,R),
//                        arr[R] + S(arr, L, R - 1)
//                );
            f[L][R] = Math.max(
                    arr[L] + s[L + 1][R],
                    arr[R] + s[L][R - 1]
            );


//                //当先手先拿，后手拿到的只能是相对小的另外一张了。
//                return Math.min(
//                        f(arr,i + 1,j),
//                        f(arr, i,j - 1)
//                );
            //后手最后一张没得拿
            s[L][R] = Math.min(
                    f[L + 1][R],
                    f[L][R - 1]
            );
            L++;
            R++;
        }
    }

    return Math.max(f[0][len - 1],s[0][len - 1]);
}

```



















##### N皇后

N个皇后放置在N * N的方格中，规定任意皇后之间：不同行，不同列，并且还要不同斜线，共有多少种放置方法？







> 怎么尝试呢？



如下：4皇后，则是每一行每一行的不断尝试。在尝试的时候就是每一行只放一个皇后。

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202261641912.png" alt="image-20220221112708292" style="zoom:50%;" />

那么N皇后问题,4皇后的另一种解则是将上述棋牌反转一下的另一面。







> code

当走到第i行的时候，尝试每一个方格，往后递归，如果站在此方格中符合条件就算一次解。

也就是当走到第i行，第1,2,3，…,i必须按照这样的放置的情况下，接下来的n - i还有多少种放置的方法是符合题意的。

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202211148948.png" alt="image-20220221114826750" style="zoom: 50%;" />





判断当前第i行的放置位置不达标

假设有两个皇后之间怎么判断他们是否冲突呢？

皇后1在：(a,b)

皇后2在：(c,d)

```java
if(b == d || |a-c| == |b-d|)
```



整体代码：

```java
import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/2/21 11:51
 * @TODO：N皇后问题
 * @Thinking:

 说明：
    1.用数组record，下标表示到了地几行，对应值表示皇后放置在第几列
      也就是record[0..i-1]表示之前的行，放了的皇后的位置
    2.n表示整体一共有多少行,0 ~ n-1行
    3.返回值是，摆完所有的皇后，合理的摆法有多少种。

 */
public class Nempress {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if(n < 1){
            System.out.println("请输入有效值!");
            return ;
        }
        //用数组record存放在每一行的皇后的具体列位置
        int[] record = new int[n];

        int num = process1(0,record,n);

        System.out.println("符合题意的皇后位置放置方案有：" + num + "种!");

    }


    public static int process1(int i,int[] record,int n){
        //递归终止条件为到了最后一行执行完，表示此放置方案成立
        if(i == n){
            return 1;
        }

        //到此处则认为还有皇后要摆，并没有到达终止位置。
        int res = 0;
        for (int j = 0; j < n; j++) {
            //当前i行的皇后，放在j列，会不会和之前(0..i-1)的皇后，不共行共列或者共斜线。
            //如果是，认为有效
            //如果不是，认为无效
            //isValid()方法表示在record中找出所有皇后与第i行第j列放置的皇后进行对比看是否冲突：
            //如果冲突则下一列
            //如果有效,将此位置添加，再去统计接下来行的放置位置。
            if(isValid(record,i,j)){

                //如果不冲突，保存位置到record中,再看接下来的位置。
                record[i] = j;
                res += process1(i + 1,record, n);
            }
        }
        return res;

    }


    public static boolean isValid(int[] record,int i,int j){
        for (int k = 0; k < i; k++) {

            //同列和共斜线
            if(j == record[k] || Math.abs(record[k] - j) == Math.abs(i - k)){
                return false;
            }
        }
        return true;
    }
}

```



常数项加速(位运算)优化

也就是将皇后放置在二进制位上

```
注意方法二不能超过总位数32
```

```java
//请不要超过32皇后问题
public static int num2(int n){
    if(n < 1 || n > 32){
        System.out.println("超过范围");
        return 0;
    }

    //如果是13皇后问题，limit最右13个1，其它都是0
    int limit = n == 32 ? -1 : (1 << n) -1;

    return process2(limit,0,0,0);

}


//limit 划定了问题的规模 —> 固定

//colLim 列的限制，1的位置不能放皇后，0的位置可以放
//leftDiaLim 左斜线的限制，1的位置不能放皇后，0的而为之可以
//rightDiaLim 右斜线的限制，1的位置不能放皇后，0的位置可以

public static int process2(int limit,int colLim,int leftDiam,int rightDiam){
    if(colLim == limit){
        return 1;
    }


    // colLim(列限制) | leftDiam(左限制) | rightDiam(右限制) =》 总限制
    //所有候选皇后的位置，都在pos |
    int pos = limit & ( ~(colLim | leftDiam | rightDiam) );
    int mostRightOne = 0;
    int res = 0;
    while (pos != 0){
        mostRightOne = pos & (~pos + 1);

        //每次比较完之后都让pos减去这个最右侧的1
        pos = pos - mostRightOne;

        //传入接下来递归里面的行限制，和递归里面左斜线的限制，还有右斜线的限制。
        //把所有放皇后的可能性结果都累加到最终的res中去并返回
        res += process2(limit,
                        colLim | mostRightOne,
                       (leftDiam | mostRightOne) << 1,
                      (rightDiam | mostRightOne) >>> 1
        );
    }
    return res;
}
```









暴力递归总结
---



>什么暴力递归可以继续优化？

有重复调用同一个子问题的解，这种递归可以优化

如果每一个子问题都是不同的解，无法优化也不用优化。







>阿里真题

假设一有排成一行的N个位置，记为1 ~ N，N一定大于或等于2

开始时机器人在其中的M位置上(M一定是1 ~ N 种的一个)

如果机器人来到1位置，那么下一步只能往右来到2位置；

如果机器人来到N位置，那么下一步只能往左来到N -1 位置；

如果机器人来到中间位置，那么下一步可以往左或者往右走；

规定机器人必须走K步，最终能来到P位置(P也是1~N中的一个)的方法有多少种

给定四个参数N，M，K，P，返回方法数。





方法一：暴力递归

```java
/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/2/21 19:08
 * @TODO：行走的机器人
 * @Thinking:
 */
public class StepNumber {
    public static void main(String[] args) {
        //输入当前机器人可以移动的位置范围
        int N = 10;

        //当前所在1 ~ N中的具体起始位置
        int M = 1;

        //输入机器人行走的最终站立位置
        int P = 2;

        //输入机器人能量可维持行走的步数
        int K = 1;
        
        //上述其中N和P的值一般都固定。
        
        
        int num = ways1(N, M, P, K);
        System.out.println("机器人行走方案数为：" + num + "种!");
    }


    public static int ways1(int N,int M,int K,int P){
        //参数无效直接返回0
        if(N < 2 || K < 1 || M < 1 || M > N || P < 1 || P > N){
            return 0;
        }

        //总共有N个位置，从M点出发，还剩K步,返回最终能到达P的方法数
        return walk(N, M, K, P);
    }

    // N：位置为1 ~ N，固定参数
    // cur ：当前在cur位置，可变参数
    // rest ：还剩res步没有走，可变参数
    // P : 最终目标位置是P，固定参数
    // 该函数的含义：只能在1 ~ N这些位置上移动，当前在cur位置,走完rest步之后,停在P位置的方法
    public static int walk(int N,int cur,int rest,int P){
        //如果没有剩余步数了，当前cur位置就是最后的位置。
        //如果最后的位置停在P上，那么之前做的移动是有效的。
        //如果最后的位置没有P上，那么之前做的移动是无效的。
        if(rest == 0){
            //如果当前没有能量再走了,如果当前位置不在最终点P上,此方法肯定是无效的
            //如果在最终点P上表示此方法成立。
            return cur == P ? 1 : 0;
        }

        //如果走到左边界值1位置的话，那么你这一步只能从1走向2,
        //后续的过程就是,来到2位置上，还剩rest - 1步要走
        if(cur == 1){
            return walk(N,2,rest - 1,P);
        }
        //如果还有rest步要走，而当前的cur位置在N位置上,那么当前这步只能从N走向N - 1的
        //后续则是来到N - 1位置上,还剩rest - 1步要走
        if(cur == N){
            return walk(N,N - 1,rest - 1,P);
        }


        //在中间
        //如果还有rest步要走,而当前的cur位置在中间位置上,那么当前这步可以走向左,也可以走向右
        //走到左之后，后续的过程就是,来到cur - 1位置上,还剩rest - 1步要走
        //走到右之后，后续的过程就是,来到cur + 1位置上,还剩rest - 1步要走
        //走向左,走向右是截然不同的方法,所以总方法数要都算上。
        return walk(N,cur + 1,rest - 1,P) + walk(N,cur - 1,rest - 1,P);

    }
}

```





方法二：利用缓存，缓存重复值，再次遇一样的情况则直接在缓存中取值，无需重复递归

其实这也就是简单的动态规划(记忆化搜索)

```java
public static int ways1(int N,int M,int K,int P){
    //参数无效直接返回0
    if(N < 2 || K < 1 || M < 1 || M > N || P < 1 || P > N){
        return 0;
    }

    //缓存数组dp
    int[][] dp = new int[N + 1][K + 1];
    for (int row = 0; row <= N; row++) {
        for (int col = 0; col <= K; col++) {
            dp[row][col] = -1;
        }
    }


    //总共有N个位置，从M点出发，还剩K步,返回最终能到达P的方法数
    return walk(N, M, K, P,dp);
}

public static int walk(int N,int cur,int rest,int P,int [][] dp){
    
        //判断是否存在于缓存,存在则直接取出结果
        if(dp[cur][rest] != -1){
            return dp[cur][rest];
        }


        if(rest == 0){
            //每次提交前先将结果加入到缓存中
            dp[cur][rest] = cur == P ? 1 : 0;
            return dp[cur][rest];
        }


        if(cur == 1){
            dp[cur][rest] =  walk(N,2,rest - 1,P,dp);
            return dp[cur][rest];
        }

        if(cur == N){
            dp[cur][rest] = walk(N,N - 1,rest - 1,P,dp);
            return dp[cur][rest];
        }

        dp[cur][rest] =  walk(N,cur + 1,rest - 1,P,dp) +
                         walk(N,cur - 1,rest - 1,P,dp);
        return dp[cur][rest];
    }
}

```



经典的动态规划(区别出缓存的是一张什么表？)

上述中间刚好两个可变参数，所以这就是一张二维数组表，所有组合都有可能发生。



也就是当前格的值等于左上格 + 左下格的值

<img src="https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202212103128.png" alt="image-20220221210352544" style="zoom:50%;" />



**动态规划**：**其实就是把参数结构化，转换为一个缓存**



注意：

> 不是所有的暴力递归都可以改成动态规划，是所有的动态规划都来自于某个暴力递归





































































从暴力递归到动态规划总结
---





### 核心思想

![image-20220226155502043](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202262239364.png)











### 整体转换过程例题





#### 例题一(凑硬币)



输入一组硬币，数组下标i表示为第i枚硬币，对应值表示硬币的面值

为了简便，输入的arr数组都为正整数，且无重复值。

给定一个aim目标值(钱数)

也就是利用所有硬币的面值有多少种凑的方法可以使得选定各种面值的所有硬币总和 = aim？

可以任意使用各种面值的硬币，且每种面值的硬币可以使用N张



方法一：暴力递归尝试

arr = [10,11,12,13...]          aim = 1000
以第一张面值硬币为起点，不断尝试多个面值
以点汇线
1.f(0张，1000)；
2.f(1张，990)；
3.f(2张，980)；
...

```java
import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/2/26 17:14
 * @TODO：凑硬币
    输入一组硬币面值arr (arr中都是正数且无重复值)
    输入一个目标值aim
    可选择各种面值的硬币，且面值硬币可以选择任意个
    使得最终所有选出来的硬币的总和 = aim
    有多少种方法？
 * @Thinking:
 思路：
    f(0,aim);
    arr = [10,11,12,13...]          aim = 1000
    以第一张面值硬币为起点，不断尝试多个面值
    以点汇线
    1.f(0张，1000)；
    2.f(1张，990)；
    3.f(2张，980)；
    ...

 */

//可以自由使用arr[index...]所有的面值，每一种面值的硬币都可以使用任意张
//组成aim，有多少种方法
public static int process(int[] arr,int index,int aim){
    //递归结束条件
    if(index == arr.length){
        //当到了最后一个结束的时候
        //如果此时aim并没有 = 0表示此方法不成立，返回0;,反之成立
        return aim == 0 ? 1 : 0;
    }

    int result = 0;

    //可取刚好 = aim为最终结果
    for (int zhang = 0; zhang <= aim; zhang++) {
        //从0张开始选，aim - 当前已经凑出来的硬币总数
        result += process(arr,index + 1,aim - (zhang * arr[index]));
    }

    return result;
}
```



第一步：分析有无重复解

重复示例

例如：arr = [10,100,50...]          aim = 1000

1. 假设用了5张10元，0张100,1张50 => f(3,900);
2. 假设用了0张10元，1张100,0张50 => f(3,900);
3. 注：f(3,900)：表示从arr的下标第三个开始，900是1000-已经凑出来的硬币总数。
4. 此时其实已经出现了，重复求。

而重复求意味着 => 动态规划(记忆化搜索)

```java
package string.String01;

import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/2/26 17:14
 * @TODO：凑硬币
输入一组硬币面值arr (arr中都是正数且无重复值)
输入一个目标值aim
可选择各种面值的硬币，且面值硬币可以选择任意个
使得最终所有选出来的硬币的总和 = aim
有多少种方法？
 * @Thinking:
思路：
f(0,aim);
arr = [10,11,12,13...]          aim = 1000
以第一张面值硬币为起点，不断尝试多个面值
以点汇线
1.f(0张，1000)；
2.f(1张，990)；
3.f(2张，980)；
...

 */


public class Collect_Coins {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //输入aim
        System.out.println("请输入目标值aim：");
        int aim = sc.nextInt();

        //输入具体值
        System.out.println("请依次输入硬币个数，和具体硬币的面值：");
        int n = sc.nextInt();
        int[] arr = new int[n];
        int i = 0;
        //输入具体每个硬币的面值
        while (n > 0){
            arr[i] = sc.nextInt();
            i++;
            n--;
        }


        if (arr == null ||arr.length == 0 || aim < 0){
            System.out.println("输入的参数有误或无效，请重新输入!");
            return;
        }
        System.out.println("凑成aim的方法有"+ process(arr, 0, aim) + "种!");

    }

    //可以自由使用arr[index...]所有的面值，每一种面值的硬币都可以使用任意张
    //组成aim，有多少种方法
    public static int process(int[] arr,int index,int aim){
        //递归结束条件
        if(index == arr.length){
            //当到了最后一个结束的时候
            //如果此时aim并没有 = 0表示此方法不成立，返回0;,反之成立
            return aim == 0 ? 1 : 0;
        }

        int result = 0;

        //可取刚好 = aim为最终结果
        for (int zhang = 0; zhang <= aim; zhang++) {
            //从0张开始选，aim - 当前已经凑出来的硬币总数
            result += process(arr,index + 1,aim - (zhang * arr[index]));
        }

        return result;
    }




    public static int dpProcess(int[] arr,int index, int aim) {
        //前置判断
        if (arr == null || arr.length == 0 || aim < 0) {
            System.out.println("请输入有效参数!");
            return -1;
        }

        //利用HashMap空间存储值，f(3,900)
        //index = 3, aim = 900, map?? key = "3_900" int 具体对应的值
//        HashMap<String,Integer> map = new HashMap<>();
        //为简洁方便使用,dp数组空间
        int[][] dp = new int[arr.length + 1][aim + 1];

//        dp[index][aim - dp[0][index]] = ?

        //递归结束条件
        if (index == arr.length) {
            //当到了最后一个结束的时候
            //如果此时aim并没有 = 0表示此方法不成立，返回0;,反之成立
            return aim == 0 ? 1 : 0;
        }

        int result = 0;

        //可取刚好 = aim为最终结果
        for (int zhang = 0; zhang <= aim; zhang++) {
            //从0张开始选，aim - 当前已经凑出来的硬币总数
            result += process(arr, index + 1, aim - (zhang * arr[index]));
        }

        return result;
    }
}

```











第二步：建缓存 

```java
    //修改称为自顶向下的动态规划
    public static int dpProcess1(int[] arr,int aim){
        //前置判断
        if (arr == null || arr.length == 0 || aim < 0) {
            System.out.println("请输入有效参数!");
            return -1;
        }
        //利用HashMap空间存储值，f(3,900)
        //index = 3, aim = 900, map?? key = "3_900" int 具体对应的值
//        HashMap<String,Integer> map = new HashMap<>();
        //为简洁方便使用,dp数组空间
        int[][] dp = new int[arr.length + 1][aim + 1];

        //一开始所有的过程，都没有计算
        //dp[..][..] = -1;设置初始值
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                dp[i][j] = -1;
            }
        }

        return dpProcess2(arr,0,aim,dp);
    }


    //没算过这种，我就直接算，算出结果保存到dp，如果算过了就直接拿值
    //如果index和aim的参数组合，是没算过的，dp[index][aim] == -1
    //如果index和aim的参数组合，是算过的，dp[index][aim] > -1

    public static int dpProcess2(int[] arr,int index, int aim,int[][] dp) {
        //表示算过,直接取
        if(dp[index][aim] != -1){
            return dp[index][aim];
        }

        //递归结束条件
        if (index == arr.length) {
            //当到了最后一个结束的时候
            //如果此时aim并没有 = 0表示此方法不成立，返回0;,反之成立
            dp[index][aim] = aim == 0 ? 1 : 0;
            return dp[index][aim];
        }

        int result = 0;

        //可取刚好 = aim为最终结果
        for (int zhang = 0; zhang * arr[index] <= aim; zhang++) {
            //从0张开始选，aim - 当前已经凑出来的硬币总数
            result += dpProcess2(arr, index + 1, aim - (zhang * arr[index]), dp);
        }

        //保存值
        dp[index][aim] = result;
        return result;
    }

```







再次整合分析结构优化

经典动态规划(粗(还存在枚举行为))

```java
//修改为经典动态规划(粗(还存在枚举行为))
    public static int dp1(int[] arr,int aim){
        //前置判断
        if (arr == null || arr.length == 0 || aim < 0) {
            System.out.println("请输入有效参数!");
            return 0;
        }

        int[][] dp = new int[arr.length + 1][aim + 1];
        //dp[arr.length][1...aim] = 0;
        dp[arr.length][0] = 1;
        for (int index = arr.length - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                int result = 0;
                for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
                    //从0张开始选，aim - 当前已经凑出来的硬币总数
                    result +=dp[index + 1][rest - (zhang * arr[index])];
                }
                dp[index][rest] = result;
            }
        }
        return dp[0][aim];
    }

```









经典动态规划

![image-20220226221711494](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202202262217343.png)

```
实际上当前第i号位置只是依赖于前面一个位置i - 1所累加的结果!
```

```java
    //修改为经典动态规划
    public static int dp(int[] arr,int aim){
        //前置判断
        if (arr == null || arr.length == 0 || aim < 0) {
            System.out.println("请输入有效参数!");
            return 0;
        }

        int[][] dp = new int[arr.length + 1][aim + 1];
        //dp[arr.length][1...aim] = 0;
        dp[arr.length][0] = 1;
        for (int index = arr.length - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                
                dp[index][rest] = dp[index + 1][rest];

                //如果剩余需要补上的钱 - 当前面值的钱不越界
                //则认为我可以加上它合成我当前位置的值
                if(rest - arr[index] >= 0){
                    dp[index][rest] += dp[index][rest - arr[index]];
                }
            }
        }
        return dp[0][aim];
    }
```











所有方法整体代码

```java
package string.String01;

import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/2/26 17:14
 * @TODO：凑硬币
输入一组硬币面值arr (arr中都是正数且无重复值)
输入一个目标值aim
可选择各种面值的硬币，且面值硬币可以选择任意个
使得最终所有选出来的硬币的总和 = aim
有多少种方法？
 * @Thinking:
思路：
f(0,aim);
arr = [10,11,12,13...]          aim = 1000
以第一张面值硬币为起点，不断尝试多个面值
以点汇线
1.f(0张，1000)；
2.f(1张，990)；
3.f(2张，980)；
...

 */


public class CollectCoins {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //输入aim
        System.out.println("请输入目标值aim：");
        int aim = sc.nextInt();

        //输入具体值
        System.out.println("请依次输入硬币个数，和具体硬币的面值：");
        int n = sc.nextInt();
        int[] arr = new int[n];
        int i = 0;
        //输入具体每个硬币的面值
        while (n > 0){
            arr[i] = sc.nextInt();
            i++;
            n--;
        }


        System.out.println("暴力递归凑成aim的方法有"+ process1(arr,  aim) + "种!");

        System.out.println("动态规划(粗)(自顶向下记忆化搜索有)" + dpProcess1(arr, aim) + "种");

        System.out.println("经典动态规划(粗)(还存在枚举行为有)" + dp1(arr, aim) + "种");

        System.out.println("经典动态规划有" + dp(arr, aim) + "种");


    }


    public static int process1(int[] arr,int aim){
        if (arr == null ||arr.length == 0 || aim < 0){
            System.out.println("输入的参数有误或无效，请重新输入!");
            return -1;
        }

        return process2(arr,0,aim);
    }

    //可以自由使用arr[index...]所有的面值，每一种面值的硬币都可以使用任意张
    //组成aim，有多少种方法
    public static int process2(int[] arr,int index,int aim){
        //递归结束条件
        if(index == arr.length){
            //当到了最后一个结束的时候
            //如果此时aim并没有 = 0表示此方法不成立，返回0;,反之成立
            return aim == 0 ? 1 : 0;
        }

        int result = 0;

        //可取刚好 = aim为最终结果
        for (int zhang = 0; zhang <= aim; zhang++) {
            //从0张开始选，aim - 当前已经凑出来的硬币总数
            result += process2(arr,index + 1,aim - (zhang * arr[index]));
        }

        return result;
    }






    //修改称为自顶向下的动态规划
    public static int dpProcess1(int[] arr,int aim){
        //前置判断
        if (arr == null || arr.length == 0 || aim < 0) {
            System.out.println("请输入有效参数!");
            return -1;
        }
        //利用HashMap空间存储值，f(3,900)
        //index = 3, aim = 900, map?? key = "3_900" int 具体对应的值
//        HashMap<String,Integer> map = new HashMap<>();
        //为简洁方便使用,dp数组空间
        int[][] dp = new int[arr.length + 1][aim + 1];

        //一开始所有的过程，都没有计算
        //dp[..][..] = -1;设置初始值
        for (int i = 0; i < dp.length; i++) {
            for (int j = 0; j < dp[0].length; j++) {
                dp[i][j] = -1;
            }
        }

        return dpProcess2(arr,0,aim,dp);
    }


    //没算过这种，我就直接算，算出结果保存到dp，如果算过了就直接拿值
    //如果index和aim的参数组合，是没算过的，dp[index][aim] == -1
    //如果index和aim的参数组合，是算过的，dp[index][aim] > -1

    public static int dpProcess2(int[] arr,int index, int aim,int[][] dp) {
        //表示算过,直接取
        if(dp[index][aim] != -1){
            return dp[index][aim];
        }

        //递归结束条件
        if (index == arr.length) {
            //当到了最后一个结束的时候
            //如果此时aim并没有 = 0表示此方法不成立，返回0;,反之成立
            dp[index][aim] = aim == 0 ? 1 : 0;
            return dp[index][aim];
        }

        int result = 0;

        //可取刚好 = aim为最终结果
        for (int zhang = 0; zhang * arr[index] <= aim; zhang++) {
            //从0张开始选，aim - 当前已经凑出来的硬币总数
            result += dpProcess2(arr, index + 1, aim - (zhang * arr[index]), dp);
        }

        //保存值
        dp[index][aim] = result;
        return result;
    }







    //修改为经典动态规划(粗(还存在枚举行为))
    public static int dp1(int[] arr,int aim){
        //前置判断
        if (arr == null || arr.length == 0 || aim < 0) {
            System.out.println("请输入有效参数!");
            return 0;
        }

        int[][] dp = new int[arr.length + 1][aim + 1];
        //对应纵轴为arr.length(index)的最后一行为起始点
        //对应横轴以当前aim不断递增de
        //dp[arr.length][1...aim] = 0;
        dp[arr.length][0] = 1;
        for (int index = arr.length - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {
                int result = 0;
                for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
                    //从0张开始选，aim - 当前已经凑出来的硬币总数
                    result +=dp[index + 1][rest - (zhang * arr[index])];
                }
                dp[index][rest] = result;
            }
        }
        return dp[0][aim];
    }




    //经典动态规划
    /**
     * arr = [10,100,50...]          aim = 1000
     * 假设用了5张10元，0张100,1张50 => f(3,900);
     * 假设用了0张10元，1张100,0张50 => f(3,900);
     * 注：f(3,900)：表示从arr的下标第三个开始
     * 此时可以是f(4,900)：意思也就是我可以选择从后面开始选择将arr[3]取0张
     * 实际上其实也就是f(3,900)的情况了已经累加这种情况了，其实
     * 实际上当前第i号位置只是依赖于前面一个位置i - 1所累加的结果，
     */

    //修改为经典动态规划
    public static int dp(int[] arr,int aim){
        //前置判断
        if (arr == null || arr.length == 0 || aim < 0) {
            System.out.println("请输入有效参数!");
            return 0;
        }

        int[][] dp = new int[arr.length + 1][aim + 1];
        //dp[arr.length][1...aim] = 0;
        dp[arr.length][0] = 1;
        for (int index = arr.length - 1; index >= 0; index--) {
            for (int rest = 0; rest <= aim; rest++) {



//                int result = 0;
//                for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
//                    //从0张开始选，aim - 当前已经凑出来的硬币总数
//                    result +=dp[index + 1][rest - (zhang * arr[index])];
//                }
//                dp[index][rest] = result;

                dp[index][rest] = dp[index + 1][rest];

                //如果剩余需要补上的钱 - 当前所在位置硬币面值不越界
                //则认为我可以加上它合成我当前位置的值
                if(rest - arr[index] >= 0){
                    dp[index][rest] += dp[index][rest - arr[index]];
                }
                
            }
        }
        return dp[0][aim];
    }
}
```











```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = Integer.MAX_VALUE;
        int[] dp = new int[amount + 1];
        //初始化dp数组为最大值
        for (int j = 0; j < dp.length; j++) {
            dp[j] = max;
        }
        //当金额为0时需要的硬币数目为0
        dp[0] = 0;
        for (int i = 0; i < coins.length; i++) {
            //正序遍历：完全背包每个硬币可以选择多次
            for (int j = coins[i]; j <= amount; j++) {
                //只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要
                if (dp[j - coins[i]] != max) {
                    //选择硬币数目最小的情况
                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
                }
            }
        }
        return dp[amount] == max ? -1 : dp[amount];
    }
}
```























#### 例题二(贴字符)



##### [691. 贴纸拼词](https://leetcode-cn.com/problems/stickers-to-spell-word/)

难度困难113

我们有 `n` 种不同的贴纸。每个贴纸上都有一个小写的英文单词。

您想要拼写出给定的字符串 `target` ，方法是从收集的贴纸中切割单个字母并重新排列它们。如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。

返回你需要拼出 `target` 的最小贴纸数量。如果任务不可能，则返回 `-1` 。

**注意：**在所有的测试用例中，所有的单词都是从 `1000` 个最常见的美国英语单词中随机选择的，并且 `target` 被选择为两个随机单词的连接。

 

**示例 1：**

```
输入： stickers = ["with","example","science"], target = "thehat"
输出：3
解释：
我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。
把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。
此外，这是形成目标字符串所需的最小贴纸数量。
```

**示例 2:**

```
输入：stickers = ["notice","possible"], target = "basicbasic"
输出：-1
解释：我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。
```

 

**提示:**

- `n == stickers.length`
- `1 <= n <= 50`
- `1 <= stickers[i].length <= 10`
- `1 <= target <= 15`
- `stickers[i]` 和 `target` 由小写英文单词组成

通过次数4,597

提交次数9,484



解题意

给定一个字符串str，给定一个字符串类型的数组arr。

arr里的每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来。

返回需要至少多少张贴纸可以完成这个任务。

> 例：
> 	str = “babac”, arr = {“ba”, ”c”, “abcd”}

至少需要两张贴纸“ba” 和 “abcd”,因为使用这两张贴纸，把每一个字符单独剪开，含有2个a、2个b、1个c。是可以拼出str的。所以返回2。



解题意：

> 1

**最少**使用多少张贴纸才可以完成这个任务。

假设：
	str = “babca”    arr = {贴纸一：“bba”, 贴纸二：“ccc”，贴纸三：“aaa”}

1. 使用一张贴纸一：“bba”拆开 str(babca) - 贴纸一(bba) = (剩余字符串需要贴)“ca”
2. 由于c字符在特定贴纸二才有，拆开贴纸二“ccc”的一个“c”  ,还剩一个 “a”
3. 最后可以使用一张贴纸一中的a，也可以使用一张贴纸三中的a
4. 所以至少使用3张贴纸。 



> 2

由于**每一个贴纸都可以剪的非常的碎**且每一种贴纸都可以**使用任意张**

==> **原始贴纸拼接的字符串并无意义**。

使用HashMap来存储，其实我并不需要贴纸所代表的字符串是什么，其实就是要知道：
**贴纸中存在哪几个字符的数量**







> 3

排序

第一张贴纸用谁？

我可以假定每一种贴纸都可以作为第一张来用

**取第一张的最佳：最终的str - 当前贴纸中所有包含的字符 = 剩余字符串最短。**





>4

伪代码

```java
    public static int Mins(String str,String[] arr){
        //当str为空字符串的时候无需拼凑返回0张
        if(str.equals("")){
            return 0;
        }


        //搞定str,需要选的第一张贴纸是什么？
        int next = 0;
        for (String first : arr) {

            //str - first(涵盖的所有在str中存在的字符) = nextRest(剩余字符串)

//            int cur = minS(nextRest , arr);
            next = Math.min(next, cur);
        }
        return next + 1;
    }
```















>实现代码



方法一：使用两张表拆分字符串字符和贴纸字符

```java
package string.String01;

import java.util.HashMap;
//import java.util.Scanner;

/**
 * @Project_Name leetCode
 * @Author LH
 * @Date 2022/2/27 14:02
 * @TODO：贴字符串
 * @Thinking:
    找出最少使用几张贴纸可以凑成字符串str
 */
public class minS {
    public static void main(String[] args) {
//        Scanner sc = new Scanner(System.in);
//        System.out.println("请输入拼凑的str:");
//        String str = sc.nextLine();
//
//        System.out.println("请输入共有多少种贴纸:");
//        int n = sc.nextInt();
//
//        String[] arr = new String[n];
//
//        int i = 0;
//        while (n > 0) {
//            arr[i] = sc.next();
//            i++;
//            n--;
//        }
        
        //示例：arr 和 str
        String[] arr = {"aaaa","bbaa","ccddd"};
        String str = "abcccccdddddbbbaaaa";

        System.out.println("最少需要:" + Mins1(str,arr) + "张贴纸!");
    }






    //方法一：记忆化搜索dp
    public static int Mins1(String str,String[] arr) {
        int n = arr.length;

        //从a - z 总共有26个字符，而n对应数组arr中每个贴纸
        //这样实现让每个贴纸的每个字符拆分对应位置，而有一个就在对应位置++。
        int[][] map  = new int[n][26];
        for (int i = 0; i < n; i++) {
            //将字符串贴纸拆分成对应单个字符数组
            char[] chai = arr[i].toCharArray();

            //并用下标表示：拆分出来的每个字符 - 'a',存入到map表中
            for (char c : chai) {
                map[i][c - 'a']++;
            }
        }

        HashMap<String,Integer> dp = new HashMap<>();
        dp.put("",0);
        return  process1(dp,map,str);
    }

    //dp傻缓存，如果t已经算过了，直接返回dp中的值
    //rest 还剩下没贴的字符串
    //0..N每一个字符串所含字符的词频统计
    //返回值是 -1，map中的贴纸是怎么都无法贴出来剩余要贴的rest的。
    public static int process1(HashMap<String,Integer> dp,
                               int[][] map,
                               String rest){
        //如果在dp缓存中算过这种，就直接去表中拿答案
        if(dp.containsKey(rest)){
            return dp.get(rest);
        }

        //没算过就继续算(正式的递归调用过程)

        //result：搞定rest，使用的最少贴纸数量,给予默认值
        int result = Integer.MAX_VALUE;

        //n种贴纸
        int n = map.length;
        //将剩余没贴的rest字符串也转换为和贴纸在表中的同一种形式
        //(对应下标依次为a - z 对应位置的数字表示此字符存在多少个)。
        int[] tmap = new int[26];
        char[] target = rest.toCharArray();
        for(char c: target){
            tmap[c - 'a']++;
        }


        //map -> tmap
        for (int i = 0; i < n; i++) {
            //枚举当前第一张贴纸是谁

            //targer中需要搞定的剩余字符串依次搞定的顺序与最后搞定的结果无关
            //如果map(贴纸所拆分对应的表中形式)
            //如果需要搞定的字符串= ”abc“ 而你这张贴纸是"xyz"你无论怎么搞最后还是原始串"abc"
            //要是不要这句就会出现递归没有结果，导致最终栈溢出错误。
            if(map[i][target[0] - 'a'] == 0){//小贪心
                continue;
            }
            //如果省略上句，那你就必须要保证当前贴纸中的字符必须要保证至少有一种可以组成target中的其中一个字符再去试
            //否则就会出现栈溢出

            StringBuilder sb = new StringBuilder();

            //i 贴纸，j 枚举a~z字符
            for (int j = 0; j < 26; j++) {
                if(tmap[j] > 0){//j这个字符是target需要的
                    /**
                     剩余需要贴的字符target对应的i字符数量 - 将对应在贴纸表map中的i字符数量
                     你减完之后还剩几个就在底下添加多少个这样的字符
                     1.出现 >= 0的情况不用管，直接减去
                     2.出现 < 0 的情况直接将append 0个i字符数即可。i位置的字符够贴的了，也多出了，
                     */
                    for (int k = 0; k < Math.max(0,tmap[j] - map[i][j]); k++) {
                        sb.append((char)('a' + j));
                    }
                }
            }

            String s = sb.toString();
            int tmp = process1(dp,map,s);
            if(tmp != -1){
                result = Math.min(result, 1 + tmp);
            }
        }

        //如果这个result还是默认最大值,那就存入-1表示不可能，正常就存正常值
        dp.put(rest,result == Integer.MAX_VALUE ? -1 : result);
        return dp.get(rest);
        
    }
}

```



> 细粒度化的枚举太多无需再改进经典动态规划

例如枚举剩余需要搞定的字符串rest的情况

```java
“0  0  0      0” //对应剩几个需要搞定
	
 a  b  c  …   z  //对应需要搞定的字符
```



```java
“0  0  0      1” 
	
 a  b  c  …   z 
```



```java
“0  0  1      1” 
	
 a  b  c  …   z 
    
    ...
```

枚举太多情况，不如就使用傻dp即可。

















































































算法题讲解
---





![image-20211020221156648](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202211925.png)





### 概述

![image-20211020221627956](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202216426.png)



![image-20211020222642026](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202226324.png)





![image-20211021154109859](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110211541413.png)



![image-20211021161551988](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110211615495.png)



![image-20211021164636985](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110211646275.png)











#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

难度简单3862

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [0]
输出：0
```

**示例 4：**

```
输入：nums = [-1]
输出：-1
```

**示例 5：**

```
输入：nums = [-100000]
输出：-100000
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

 

**进阶：**如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。

通过次数710,898

提交次数1,285,488



![](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110211852789.png)

![image-20211021191716569](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110211917067.png)





























#### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

难度中等1535

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**示例 4：**

```
输入：coins = [1], amount = 1
输出：1
```

**示例 5：**

```
输入：coins = [1], amount = 2
输出：2
```

 

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

通过次数313,040

提交次数702,907



![image-20211021201952875](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212019329.png)



![image-20211021202935085](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212029514.png)

![image-20211021203008031](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212030396.png)

```java
/**33.27 + 33.53
凑成总金额所需的 最少的硬币个数

思路：
    因为amount = 0的时候的最优解就是0,所以定义的dp数组没有能组成的就返回-1,dp数组所有元素默认都是-1,第一个元素为0
    数组中的任意一个金额的硬币都可以是最优解的最后一张，从1开始遍历一直到amount
    再遍历数组中的硬币面额的所有种类：
        1.要是i - 当前遍历到的面额 >=0,才有可以,又或者说是i - 当前面额有对应的dp数组对应的值呼应,才可以更改优化 
        2.递推公式：dp[i] = dp[i-coins[j]] + 1;(如果当前的dp[i] < dp[i-coins[i]]+1对应的硬币个数才需要换成更少的，否则不需要)
 */
class Solution {
    public int coinChange(int[] coins, int amount) {
        //dp数组就位,并初始化
        int[] dp = new int[amount + 1];
        for(int i =0;i <= amount;i++) dp[i] = -1;
        //0的最优解还是0
        dp[0] = 0;
        
        //从[1到amount]的所有元素都遍历一遍
        for(int i = 1;i <= amount;i++){
            //遍历面额种类
            for(int j = 0;j < coins.length;j++){
                
                //当前数值-当前遍历到的面额种类要>=0才有意义,或者dp中对于当前遍历到的数量-当前对应面额有定义也行
                if(i - coins[j] >= 0 && dp[i - coins[j]] != -1){
                    //确实比我原来的好，我再优化
                    if(dp[i] == -1 || dp[i] > dp[i-coins[j]] + 1) dp[i] = dp[i-coins[j]] + 1;
                }
            }
        }
        return dp[amount];
    }
}
```























![image-20211021213549552](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212135834.png)

![image-20211021221945667](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212219012.png)



![image-20211021222702656](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212227095.png)







![image-20211021223330796](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212233202.png)

示例代码：

```java
/**30.15 + 76.28
思路：
    置地向上递推出最优路径
    每一步只能移动到下一行相邻的结点上，假设最底下一层为n,在n层中选定了第i号元素，那么从第i号元素
    向上在n-1层只能选择同样为第i号元素或者i-1号位上的元素。
    同理：从上往下走，只有对应相同的第i号位置和i+1号位置可以选择。
 */
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        //定义dp数组(三角形第n层就是共有n个元素)
        int[][] dp = new int[triangle.size()][triangle.size()];
        
        //自底向上,将最下面一层的所有元素复制到dp数组的最下面一层
        for(int i = 0;i < dp[dp.length-1].length;i++){
            dp[dp.length-1][i] = triangle.get(dp.length-1).get(i);
        }
        
        //然后从倒数第二层开始遍历
        for(int i = dp.length-2;i >= 0;i--){
            //从第i层的0号位一直到i层的最后一个元素
            for(int j = 0;j < triangle.get(i).size();j++){
                //下面一层只有这两个位置可以移动到当前dp[i][j]这个位置，所以，自底向上选择最优解
                dp[i][j] = Math.min(dp[i+1][j],dp[i+1][j+1]) + triangle.get(i).get(j);
            }
        }
        return dp[0][0];
    }
}
```





















![image-20211021233326470](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110212333814.png)



























































# 打表技巧和矩阵处理技巧【重点】

![image-20211020162718085](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201627323.png)

例：
	想把一个整数数组中每个元素的所有质数因子的个数都加在一起

![image-20211020161936674](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201619875.png)



制作一张表，把从范围内的所有整数的质数因子有几个统计出来(左边为数组元素/右边为质数的数量)，每次遍历到数组元素的时候,就去表中取元素对应的质数因子数量，当然，这样的方法需要是范围并没有很大，很大的话这样的方法不适用。

![image-20211020162249349](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201622525.png)











![image-20211020162746899](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201627167.png)



如果N无法让使用的每个袋子必须装满返回-1



不找规律，暴力方法：
![image-20211020163930897](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201639261.png)

上述举例

> 思路：

​	假设输入100个苹果，要用最少的袋子，取极端都用最大的8号袋，向下取整就是12(这个时候实际上要判断一下它是否有余数)，有余数这样就行不同，那么就遍历，从12一直到0这期间如果有剩下的余数可以被一个或者多个6号袋给装满，就可以。输出此时用了多少个8号袋和6号袋。否则到0个8号袋，一个或者多个6号袋都不能装满，小虎肯定发脾气不买了，返回-1；





>优化

![image-20211020165655952](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201656359.png)

如果发现到了某一步，余数会>=24就没有必要再继续试下去了，直接返回-1。

因为：如上图所述，当余数>=24的时候，这24个你没得选，必然是用三个8号袋装，如上述，遍历到使用9号袋的时候，就是31-24=7个，实际上又到了最上面的剩余7个苹果的循环。

所以才有：当余数>=24的时候，还没有找到就返回-1吧；





> 规律

当到18个苹果开始就有规律了，18个苹果之前特定处理，时间复杂度可以达到O(1);

![image-20211020171115672](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201711031.png)















例题二：

![image-20211020171446757](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201714998.png)



![image-20211020173334156](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201733446.png)









注意：此语句的意思就是

![image-20211020174130126](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201741355.png)

这句递归的意思就是，手上留当前的base一手，判断前面递归传进去是谁赢了，剩下这一手肯定是另外一个赢。











> 关于越界问题

假设有一种情况：
	当此刻还没有*4的时候base并没有越界，与总草数n

还是有点距离，但是有可能这一步*4就已经越界了

![image-20211020175310287](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201753644.png)













> 找规律优化

![image-20211020185527562](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201855812.png)



也就是：
![image-20211020185616226](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201856386.png)













![image-20211020190952559](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201909788.png)



![image-20211020191305610](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201913812.png)

思路：

​	按照上述测试用例输入参数为：100

暴力递归：

1. 从1+2+3…一直加一直判断是否==100，等于就输出从1到目前的这几个数。
2. 但是发现加到后面超过100就说明开始的位置就错了，那么就从2+3+4…开始并不断判断
3. 还是加超了，那么就从3开始…直到找到为止
4. 但是假设找到从100-1也就是99开始都不是那么返回false

示例代码：
   ![image-20211020192348671](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201923939.png)





![image-20211020192335329](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202103148.png)



![image-20211020192635148](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201926351.png)











#### 矩阵处理技巧

![image-20211020193409691](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110201934891.png)











例题一：
	实现绕圈打印如下顺序打印矩阵

![image-20211020202054808](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202020194.png)







> 宏观调度思路

![image-20211020203145564](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202031071.png)

定义两个点，使得B往下走，走到不能走了(不满足这次位置)为止

A往右走，走到不能走了(不满足题意)为止。然后每次就会发现，遍历打印都会出来

一条斜线，每次不是从B往A打印就是从A往B打印。因此只需要编写一个函数从A往B打印或者从B往A打印

即可







![image-20211020210536587](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202105802.png)

![image-20211020210512886](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202105101.png)





解释：

![image-20211020204145769](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202041058.png)





![image-20211020205817472](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202058695.png)

![image-20211020205939350](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202103150.png)

![image-20211020210154294](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202101474.png)

打印的方向也是每次取相反。



















题目二：转圈打印矩阵

![image-20211020210712895](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202107139.png)











































































题目四：

​	输入一个字符数组用来表示灯开(T)或者关(F)的情况，两个人，一个先手一个后手，假设两人都聪明绝顶，两人都可以选择在字符数组中的哪个位置上做从此位置到数组结束之间的所有元素全变的操作，输出最后是谁先将所有的灯泡都打开就是谁赢？

![image-20211020200229147](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202110202103149.png)

```java
/**
暴力递归
思路：
	如果最后一个字符元素是开的话，那么先手是永远不可能赢的,因为他无论从数组中哪一个位置开始，他总会将最后一个灯泡关掉。不过这个题应该问谁永远都不会输才对。因为当先手直到他不可能赢,那就会恶心后手，当后手在操作的时候就在他后面又将先手的操作重置一遍，那么后手也不可能赢
*/
```



















































回溯
===

### 回溯暴力算法

#### 基础



1.回溯与递归相辅相成

2.回溯处于递归函数的下面

3.在处理遇到的一些问题，能使用纯暴力解决出来就很不错了

回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法⾼效⼀些，可以加 ⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。

##### 主要解决的问题

1.组合问题

​	数组有多少种组合方式

​	例如：12的组合有几种？

​			只有一种，那就是12组合在一起

2.切割问题

​	比如字符串的切割问题



3.子集问题

​	子集的排列等问题



4.排列问题

​	强调元素的顺序



5.棋盘问题

​	n皇后问题





#### 对于回溯算法的理解

回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！ 因为回溯法解决的都是在集合中递归查找⼦集，集合的⼤⼩就构成了树的宽度，递归的深度，都构成的 树的深度。 递归就要有终⽌条件，所以必然是⼀颗⾼度有限的树（N叉树）。

可以理解它为n叉树

宽度可以理解为一个for循环

而树的高度可以理解为一个递归





![image-20210803204320368](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108251223957.png)

注意图中，我特意举例集合⼤⼩和孩⼦的数量是相等的！





#### 回溯模板

回溯函数遍历过程伪代码如下： 

void backtracking(参数) 

​		if (终⽌条件) {

​				 存放结果; return;

​		 }

 		for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {

​		 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 

​		} 



for循环就是遍历集合区间，可以理解⼀个节点有多少个孩⼦，这个for循环就执⾏多少次。 backtracking这⾥⾃⼰调⽤⾃⼰，实现递归。 ⼤家可以从图中看出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这 棵树全遍历完了，⼀般来说，搜索叶⼦节点就是找的其中⼀个结果了。 分析完过程，

###### 回溯算法模板框架如下：

```java
void backtracking(参数) {
 if (终⽌条件) {
 存放结果;
 return;
 }
 for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
 处理节点;
 backtracking(路径，选择列表); // 递归
 回溯，撤销处理结果
 }
}
```









对数器

![image-20210826215729230](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108262157642.png)









递归

![image-20210826220848827](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108262208333.png)







log(b,a)

求小和问题(跳过)：

![image-20210830173824047](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108301738122.png)

p3桶排序及排序总结，跳过

![image-20210830174956020](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202108301749138.png)











> 什么是回溯？



回溯其实就是常说的DFS算法，本质上就是一个暴力穷举的算法

在有些复杂的问题中，能够用暴力的方式将它解出就已经很不容易了。







>怎么解决回溯问题，实际上就是决策树的遍历过程。

解决一个回溯问题实际上就是一个决策树的遍历过程，你只需要思考3个问题：

1. 路径：也就是已经做出的选择
2. 选择列表：也就是你当前可以做的选择
3. 结束条件：也就是到达了决策树的底层，无法再做选择的条件。







>算法框架



```java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

在全排列问题中做选择(要)，撤销选择(不要)

如果不撤销选择，就会影响下一次递归的结果。





力扣第 46 题「 [全排列](https://leetcode-cn.com/problems/permutations)」就是这个问题，不过我们在高中的时候就做过排列组合的数学题，我们也知道 `n` 个不重复的数，全排列共有 `n!` 个。

> PS：**为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字**。

​	那么我们当时是怎么穷举全排列的呢？比方说给三个数 `[1,2,3]`，你肯定不会无规律地乱穷举，一般是这样：

先固定第一位为 1，然后第二位可以是 2，那么第三位只能是 3；然后可以把第二位变成 3，第三位就只能是 2 了；然后就只能变化第一位，变成 2，然后再穷举后两位……

其实这就是回溯算法，我们高中无师自通就会用，或者有的同学直接画出如下这棵回溯树：

![img](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203012137065.jpeg)

递归回溯就是将每种情况暴力枚举出来。





































































































































