位运算
---



位运算是计算机科学中的重要知识点之一，有许多与位运算相关的算法题，我们一起来探讨一下。首先，我们需要了解一下常见的位运算符及其含义。

1. **按位与（&）：两个位都为1时结果才为1**
2. **按位或（|）：两个位都为0时结果才为0**
3. **按位异或（^）：两个位相同为0，不同为1**
4. **左移（<<）：将数据的二进制位按需左移，高位丢弃，低位补0**
5. **右移（>>）：将数据的二进制位按需右移，低位丢弃，高位补0或补符号位**
6. **无符号右移（>>>）：将数据的二进制位按需右移，低位丢弃，高位补0**

下面演示两个例子：

假设有一个整数n为5，它的二进制表示为101，那么我们可以通过位运算符进行操作：

1. 将n左移1位，即n<<1，则变为10，二进制表示为1010，等价于将5乘以2
2. 将n右移1位，即n>>1，则变为2，二进制表示为10，等价于将5除以2，取整
3. 将n按位与3，即n&3，则为1，二进制表示为001，等价于将5除以4，取余数
4. 将n按位或1，即n|1，则变为5，二进制表示为101，等价于将5加上1
5. 将n按位异或3，即n^3，则变为6，二进制表示为110，等价于将5加上3



>例题

对于位运算类型的算法题，通常我们需要使用位运算符来进行位操作。下面我们来看一个位运算类型的算法题。

题目描述：给定一个数n，求出从右边数第k位是1还是0。

解题思路：我们可以将n右移k-1位，然后判断它的最后一位是1还是0。



什么是k-1位而不是k位呢？

因为我们是从右边开始数的，而计算机中的二进制数是从右往左数的，即最低位在最右边，所以我们要从右边数第k位，就需要将n右移k-1位，而不是k位。



Java代码实现：

```
public static int getKthBit(int n, int k) {
    return (n >> (k - 1)) & 1;
}
```

代码解释：

1. 将n右移k-1位，即n>>(k-1)；
2. 将结果与1按位与，即(n>>(k-1))&1；
3. 最后返回结果。

希望这个例子可以帮助你理解位运算类型的算法题。当然，位运算不仅在算法题中常用，在实际开发中也有很多用处，如优化代码性能、压缩存储等。



> 01.01. 判定字符是否唯一



相关企业

实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。

**示例 1：**

```
输入: s = "leetcode"
输出: false 
```

**示例 2：**

```
输入: s = "abc"
输出: true
```

**限制：**

- `0 <= len(s) <= 100 `
- `s[i]`仅包含小写字母
- 如果你不使用额外的数据结构，会很加分。



```java
/**
思路(位运算)：
    1.字符串拆分为astr.length()个单个字符
    2.遍历字符串,拿到单个字符进行匹配
    3.核心是将当前字符value - 'a' = moveNum(让1 << moveNum位)即可得到当前位置为1其余位置为0的数字
    4.随后让mark再|= (1 << moveNum)即可录入当前位置数据到mark中
    5.每次遍历不断进行对比看看是否位置上有重复,有的话直接返回false
    6.所有字符都不存在重复则返回true
 */
class Solution {
    public boolean isUnique(String astr) {
        int mark = 0;
        char[] strArray = astr.toCharArray();
        for(char value : strArray){
            int moveNum = value - 'a'; 
            if((mark & (1 << moveNum)) != 0){
                return false;
            }
            else{
                mark |= (1 << moveNum);
            }
        }
        return true;
    }
}
```

















