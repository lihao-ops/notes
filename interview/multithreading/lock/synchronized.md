synchronized
===

一、概念
---

Java 中的锁机制是多种多样的，主要包括 synchronized 关键字、ReentrantLock、ReadWriteLock、StampedLock 等。



### 1.原理

synchronized是Java中最基础的锁机制。

当一个线程进入synchronized代码块或方法时：

> 会尝试获取对象的锁

如果该对象的锁被其它线程持有，则该线程会被阻塞，**直到获取到锁为止**。一旦获取到锁，线程执行完synchronized代码块或方法后会释放锁。



>特点

内置Java语言中，使用方便，但只能通过synchronized方法或代码块来使用，而且锁的获取和释放由JVM自动管理。








二、锁实现
---

synchronized 在底层实现上涉及了偏向锁、轻量级锁和重量级锁的概念。这种锁升级的过程主要是为了在保证程序正确性的前提下，尽量减少锁的竞争，提高并发性能。



### 1.偏向锁

当一个线程访问同步块并持有锁时，会**在对象头上的Mark Word中设置线程ID,以标识这个线程是偏向于该锁的**。这个==过程是无竞争的==，也就是说**在没有其它线程尝试获取锁的情况下，该线程可以独占锁**，并且之后再进入同步块时，不需要重新竞争锁。





### 2.轻量级锁

- **当锁对象处于无竞争状态时(只有线程A在执行)，另一个线程B在进入同步块之前**，会将对象头中的锁记录拷贝到线程的栈帧中的锁记录中。
- 如果这个过程能成功完成，那么**线程A就获得了锁，这个时候被称为轻量级锁**。这个过程是通过CAS操作来实现的。所以是非阻塞的。
- 如果竞争激烈或者锁占用时间过长，导致自旋等待的线程自旋次数达到一个阈值，或者达到 JVM 的指定的一些其他条件，那么轻量级锁就会膨胀为重量级锁。



>轻量级锁为什么也叫自旋锁？

轻量级锁有时候也被称为自旋锁，是因为**在获取锁失败时，线程不会立即被阻塞挂起，而是会进行一定次数的自旋尝试获取锁**。这种自旋的行为是为了**避免线程频繁地进入阻塞状态，因为线程从阻塞状态到就绪状态的切换会带来一定的开销。**在竞争不激烈的情况下，自旋锁可以有效地减少线程被挂起和唤醒的次数，提高程序的性能。

自旋锁的自旋次数是有限的，如果自旋次数达到了限制（比如 JVM 的指定阈值），但仍然没有获取到锁，那么线程会放弃自旋，进入阻塞状态，等待锁可用时再次尝试获取。这种策略可以避免在竞争激烈时浪费过多的 CPU 资源。

总的来说，轻量级锁之所以也称为自旋锁，是因为它在竞争不激烈时会通过自旋尝试获取锁，以减少线程的阻塞次数，提高程序的性能。





#### CAS（Compare and Swap）

CAS（Compare and Swap）是一种并发原语，用于实现多线程环境下的原子操作。它是一种乐观锁，通过比较内存中的值和预期值是否相等来确定是否执行更新操作。CAS 包括三个操作数：需要读写的内存位置（通常是对象的字段）、预期值和新值。

CAS 的基本过程如下：

1. 读取内存位置的当前值。
2. 比较当前值与预期值是否相等。
3. 如果相等，则将内存位置的值更新为新值；如果不相等，则不做任何操作。
4. 返回更新结果，通常是成功或失败的标志。

在 Java 中，CAS 操作通常使用 `sun.misc.Unsafe` 类的相关方法来实现，比如 `compareAndSwapInt()`、`compareAndSwapLong()`、`compareAndSwapObject()` 等。这些方法允许程序员直接操作内存，进行原子性的值比较和更新操作。

CAS 的特点包括：

- **原子性**：CAS 操作是原子的，即使在多线程环境下也可以保证对内存位置的操作是不可分割的，不会被其他线程中断。
- **非阻塞性**：CAS 是一种非阻塞算法，不会因为竞争而导致线程的阻塞。如果 CAS 操作失败，线程可以立即重新尝试操作，而不需要等待其他线程释放锁。
- **ABA 问题**：CAS 只能保证内存位置的值与预期值相等时才会更新，但无法解决 ABA 问题，即当内存位置的值经历了 A->B->A 的变化时，CAS 无法感知到中间的 B 值变化。为了解决 ABA 问题，通常需要结合版本号或者引用的方式来解决。

总的来说，CAS 是一种轻量级的同步原语，适用于多线程环境下的原子操作，可以有效地避免使用锁时的性能开销，提高程序的并发性能。







### 3.重量级锁

**重量级锁是一种悲观锁**，在有竞争的情况下通过操作系统提供的互斥量来实现阻塞等待锁的释放。

由于重量级锁是由操作系统提供的互斥量来实现的，它**会导致线程在获取锁失败时阻塞，直到锁可用为止**。因此，**重量级锁的获取过程是阻塞的**，而不是通过 CAS 操作来实现的。







### 4.总结表述

synchronized 是 Java 中基于 JVM 的锁机制，底层实现分为偏向锁、轻量级锁和重量级锁。会根据实际情况自动进行锁升级操作以提高并发性能。

假设 synchronized 关键字放在了一个方法上：

- 当只有一个线程（比如线程A）执行时，锁会在对象头部记录线程A的ID，此时并没有竞争，因此处于偏向锁状态。
- 当线程B尝试进入同步代码块时，会尝试将对象头中的锁记录拷贝到线程B的栈帧中的锁记录中。如果拷贝成功，线程B就获得了锁，这个时候被称为轻量级锁状态。轻量级锁是通过 CAS 操作来实现的，并且是一种乐观锁。
- 当竞争激烈或者锁占用时间过长时，轻量级锁就会膨胀为重量级锁。重量级锁是由操作系统提供的互斥量来实现的，它会导致线程阻塞，直到锁可用为止。







































































































