# 设计模式学习笔记（24种）

## 创建型模式 (Creational Patterns)

### 1. 工厂方法（Factory Method）
- **意图**：定义一个创建对象的接口，让子类决定实例化哪一个类。
- **关键点**：延迟到子类来决定创建逻辑，避免在客户端硬编码。
- **应用场景**：日志记录器、数据库连接、解析器。

### 2. 抽象工厂（Abstract Factory）
- **意图**：提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。
- **关键点**：解决“产品族”的一致性问题。
- **应用场景**：跨平台 UI 工具包、不同数据库的 DAO 层。

### 3. 单例（Singleton）
- **意图**：确保一个类只有一个实例，并提供全局访问点。
- **关键点**：构造器私有化、线程安全。
- **应用场景**：配置对象、线程池、缓存。

### 4. 原型（Prototype）
- **意图**：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
- **关键点**：通过 clone() 复制对象，避免重复构造。
- **应用场景**：大对象复制、图形编辑器。

### 5. 建造者（Builder）
- **意图**：将一个复杂对象的构建与表示分离，使同样的构建过程可以创建不同的表示。
- **关键点**：一步步构建，最后统一组装。
- **应用场景**：构建复杂对象（如 JSON → 对象）、SQL 语句构造器。

---

## 结构型模式 (Structural Patterns)

### 6. 适配器（Adapter）
- **意图**：将一个类的接口转换成客户端希望的另一个接口。
- **关键点**：解决接口不兼容问题。
- **应用场景**：老接口兼容新系统、第三方 SDK 接入。

### 7. 桥接（Bridge）
- **意图**：将抽象与实现分离，使它们可以独立变化。
- **关键点**：抽象层和实现层分离，通过组合代替继承。
- **应用场景**：图形界面跨平台（Shape + Renderer）。

### 8. 装饰者（Decorator）
- **意图**：动态地给对象添加功能，比继承更灵活。
- **关键点**：包装原对象，保持接口一致。
- **应用场景**：IO 流、策略叠加。

### 9. 组合（Composite）
- **意图**：将对象组合成树形结构表示“部分-整体”。
- **关键点**：统一对待单个对象和组合对象。
- **应用场景**：文件系统、组织架构。

### 10. 外观（Facade）
- **意图**：为子系统提供一个统一的高层接口，简化调用。
- **关键点**：隐藏子系统复杂性。
- **应用场景**：三方 SDK 封装、Spring JdbcTemplate。

### 11. 享元（Flyweight）
- **意图**：运用共享技术有效支持大量细粒度对象。
- **关键点**：内部状态共享，外部状态由客户端维护。
- **应用场景**：字符串常量池、连接池。

### 12. 代理（Proxy）
- **意图**：为其他对象提供一种代理以控制对它的访问。
- **关键点**：间接访问，附加功能（权限、缓存、延迟加载）。
- **应用场景**：AOP、远程代理、动态代理。

---

## 行为型模式 (Behavioral Patterns)

### 13. 模板方法（Template Method）
- **意图**：定义算法框架，把可变部分延迟到子类实现。
- **关键点**：抽象类提供固定流程，子类实现细节。
- **应用场景**：数据处理流程、测试用例框架。

### 14. 命令（Command）
- **意图**：将请求封装为对象，使请求和执行分离。
- **关键点**：可撤销、可排队。
- **应用场景**：操作日志、任务队列。

### 15. 迭代器（Iterator）
- **意图**：提供一种方法顺序访问聚合对象中的元素，而不暴露内部表示。
- **关键点**：统一遍历方式。
- **应用场景**：集合遍历。

### 16. 观察者（Observer）
- **意图**：对象间一对多依赖，一个对象状态改变，通知其他对象。
- **关键点**：解耦观察者和被观察者。
- **应用场景**：事件机制、消息推送、股票行情订阅。

### 17. 中介者（Mediator）
- **意图**：通过中介对象封装对象交互，避免对象间过度耦合。
- **关键点**：集中控制。
- **应用场景**：聊天室、调度中心。

### 18. 备忘录（Memento）
- **意图**：在不破坏封装的前提下捕获对象内部状态，并在对象之外保存。
- **关键点**：保存和恢复状态。
- **应用场景**：撤销操作、游戏存档。

### 19. 解释器（Interpreter）
- **意图**：定义语言的文法，并建立解释器来解释句子。
- **关键点**：语法树 + 解释。
- **应用场景**：规则引擎、表达式计算。

### 20. 状态（State）
- **意图**：允许对象在内部状态改变时改变行为。
- **关键点**：状态和行为绑定。
- **应用场景**：订单状态流转、工作流引擎。

### 21. 策略（Strategy）
- **意图**：定义一系列算法，使它们可互换。
- **关键点**：算法族抽象，运行时选择。
- **应用场景**：支付方式选择、排序算法切换。

### 22. 职责链（Chain of Responsibility）
- **意图**：使多个对象都有机会处理请求，形成处理链。
- **关键点**：解耦请求和处理，顺序传递。
- **应用场景**：过滤器链、审批流程。

### 23. 访问者（Visitor）
- **意图**：表示在不改变元素类的前提下，定义作用于这些元素的新操作。
- **关键点**：将数据结构和操作解耦。
- **应用场景**：编译器 AST 处理、报表生成。

### 24. 解释器（Interpreter）
（已在 #19）

---

# 复习 Checklist ✅

- [ ] 创建型模式（5种）
- [ ] 结构型模式（7种）
- [ ] 行为型模式（11种）
- [ ] 每种模式能用一句话概括
- [ ] 至少能说出1-2个真实项目中的应用场景