SpringCloud
===



官网地址：https://spring.io/projects/spring-cloud





尚硅谷Java全套视频教程
下载地址：https://pan.baidu.com/s/1Kg7UUpO3wwALX6x28cWA7A，提取码：8op3
学习路线及下载导航：http://www.atguigu.com/download.shtml

B站直达在线看：https://space.bilibili.com/302417610
围观尚硅谷Java课程：http://www.atguigu.com/kecheng.shtml





> 核心

微服务模块开发基本步骤：

1. 建module
2. 改pom
3. 写yml
4. 主启动
5. 业务类













基本概念
---





### 负载均衡

关于负载均衡的详细介绍
读完这篇文章，我希望大家能够掌握以下两点知识：

能够彻底的掌握什么是负载均衡，以及为什么要使用负载均衡。
能够清楚的理解实现负载均衡的三种方式，以及每种方式的优缺点。



> 一、什么是负载均衡？为什么要使用负载均衡？

首先来看一下百度百科上对于负载均衡的介绍。

负载均衡：建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。

这样笼统来看，我想有很多人都看不明白，那么下面我将用大白话给大家介绍一下到底什么是负载均衡，如果介绍的不好，还请大家见谅。

现在网站的架构已经从C/S模式转变为B/S模式，对于这两种模式的区别，大家没必要纠结，有兴趣的同学可以给我留言，我会在后面为大家讲解，现在只需要知道C/S模式是有一个专门的客户端，而B/S模式是将浏览器作为客户端。当用户在浏览器上输入一个网址按下回车键后，就会产生一个请求，在远方的服务器会处理这个请求，根据这个请求来生成用户想要的页面，然后将这个页面响应给浏览器，这样用户就能看到他想要看到的东西。我们知道，一台服务器处理数据（请求也是一种数据）的能力是有限的，当有大量的用户同时在浏览器上输入网址并按下回车键后，就会有大量的请求产生，远方的服务器就不得不处理这些请求，由于请求数量过多，服务器处理的效率就会变慢，响应时间就会变长，这样用户就不能在可以忍受的时间内看到自己想看到的东西，严重影响体验效果。更严重一点，如果请求数量超过了这台服务器所能处理的最大请求，服务器就会崩溃，直接导致网站瘫痪。

> 那么，有什么方法能够解决这个问题呢？

答案就是建立一个集群（就是一群服务器），通过集群的力量来提高服务端的数据处理能力，因为一台服务器的处理能力肯定比不上多台服务器的处理能力。

这样我们在来描述一下用户请求页面的过程：

- 首先用户在浏览器输入网址并按下回车键，然后会产生一个请求，远方的服务器会处理这个请求......等等，现在远方有很多服务器，到底哪个服务器来处理这个请求呢，总不能所有的服务器都处理这个请求吧。哪个服务器处理这个请求？
- 大家明白了吧，这就是负载均衡所要解决的问题。回到上边请求页面的过程，这个请求此时会被一台专门的服务器来处理，这台服务器其实就是个集群的老大，他负责把这个请求派给下面哪个小弟（服务器）来处理，处理完之后返回页面用户。当有多个请求同时发生时，集群的老大可以将请求派给不同的小弟，这样处理的效率就会大幅提升，充分发挥集群的力量，至于哪个请求到底派给哪个小弟，这就是调度策略的问题了。

好了，到现在大家应该都明白什么是负载均衡了，为了让大家印象更加深刻，大家可以看一下下面的图，便于理解记忆。

![image-20211102142340960](https://i.loli.net/2021/11/02/CLyVxNp6hKqYRdz.png)

负载均衡

二、实现负载均衡的三种方式

1、HTTP重定向实现负载均衡

请求过程：

当用户向服务器发起请求时，请求首先被集群调度者（集群老大）截获；调度者根据某种分配策略，选择一台服务器（小弟），并将选中的服务器的IP地址封装在HTTP响应消息头部的Location字段中，并将响应消息的状态码设为302，最后将这个响应消息返回给浏览器。

当浏览器收到响应消息后，解析Location字段，并向该URL发起请求，然后指定的服务器处理该用户的请求，最后将结果返回给用户。

在使用HTTP重定向来实现服务器集群负载均衡的过程中，需要一台服务器作为请求调度者。用户的一项操作需要发起两次HTTP请求，一次向调度服务器发送请求，获取后端服务器的IP，第二次向后端服务器发送请求，获取处理结果。

![image-20211102142303966](https://i.loli.net/2021/11/02/LvehINFgw3rpDij.png)

HTTP重定向实现负载均衡

优点：采用HTTP重定向来实现服务器集群的负载均衡实现起来较为容易，逻辑比较简单。

缺点：在HTTP重定向方法中，调度服务器只在客户端第一次向网站发起请求的时候起作用。当调度服务器向浏览器返回响应信息后，客户端此后的操作都基于新的URL进行的(也就是后端服务器)，此后浏览器就不会与调度服务器产生关系，进而会产生如下几个问题：

由于不同用户的访问时间、访问页面深度有所不同，从而每个用户对各自的后端服务器所造成的压力也不同。而调度服务器在调度时，无法知道当前用户将会对服务器造成多大的压力，因此这种方式无法实现真正意义上的负载均衡，只不过是把请求次数平均分配给每台服务器罢了。
若分配给该用户的后端服务器出现故障，并且如果页面被浏览器缓存，那么当用户再次访问网站时，请求都会发给出现故障的服务器，从而导致访问失败。
2、DNS负载均衡

首先我们要了解一下什么是DNS?

DNS的全拼是Domain Name System，中文也叫做域名服务器，是负责将域名解析成IP地址的，例如将www.baidu.com这个域名解析成了115.239.211.112，我们访问www.baidu.com时其实访问的是115.239.211.112这台服务器。

请求过程：

当用户向我们的域名发起请求时，DNS服务器会自动地根据我们事先设定好的调度策略选一个合适的IP返回给用户，用户再向该IP发起请求。

![image-20211102142235734](https://i.loli.net/2021/11/02/9EBjKfLUidxhy2z.png)

DNS负载均衡

优点：

DNS负载均衡最大的优点就是配置简单。服务器集群的调度工作完全由DNS服务器承担，那么我们就可以把精力放在后端服务器上，保证他们的稳定性与吞吐量。而且完全不用担心DNS服务器的性能，即便是使用了轮询策略，它的吞吐率依然卓越。
DNS负载均衡具有较强了扩展性，你完全可以为一个域名解析较多的IP，而且不用担心性能问题。
缺点：

由于把集群调度权交给了DNS服务器，从而我们没办法随心所欲地控制调度者，没办法定制调度策略。
DNS服务器也没办法了解每台服务器的负载情况，因此没办法实现真正意义上的负载均衡。它和HTTP重定向一样，只不过把所有请求平均分配给后端服务器罢了。
当我们发现某一台后端服务器发生故障时，即使我们立即将该服务器从域名解析中去除，但由于DNS服务器会有缓存，该IP仍然会在DNS中保留一段时间，那么就会导致一部分用户无法正常访问网站（可以用动态 DNS来解决）。
3、反向代理负载均衡

请求过程：

用户发来的请求都首先要经过反向代理服务器，服务器根据用户的请求要么直接将结果返回给用户，要么将请求交给后端服务器处理，再返回给用户。

![image-20211102142222142](https://i.loli.net/2021/11/02/deM7HhNxywPI9El.png)

反向代理负载均衡

优点：

隐藏后端服务器。与HTTP重定向相比，反向代理能够隐藏后端服务器，所有浏览器都不会与后端服务器直接交互，从而能够确保调度者的控制权，提升集群的整体性能。
故障转移。与DNS负载均衡相比，反向代理能够更快速地移除故障结点。当监控程序发现某一后端服务器出现故障时，能够及时通知反向代理服务器，并立即将其删除。
合理分配任务 。HTTP重定向和DNS负载均衡都无法实现真正意义上的负载均衡，也就是调度服务器无法根据后端服务器的实际负载情况分配任务。但反向代理服务器支持手动设定每台后端服务器的权重。我们可以根据服务器的配置设置不同的权重，权重的不同会导致被调度者选中的概率的不同。
缺点：

调度者压力过大 。由于所有的请求都先由反向代理服务器处理，那么当请求量超过调度服务器的最大负载时，调度服务器的吞吐率降低会直接降低集群的整体性能。
制约扩展。当后端服务器也无法满足巨大的吞吐量时，就需要增加后端服务器的数量，可没办法无限量地增加，因为会受到调度服务器的最大吞吐量的制约。















### 分布式和微服务

原文链接：https://blog.csdn.net/zhonglunsheng/article/details/83153451



> **微服务是架构设计方式**，**分布式是系统部署方式**，两者概念不同









> **微服务是啥？**

简单来说微服务就是很小的服务，**小到一个服务只对应一个单一的功能，只做一件事**。这个服务**可以单独部署运行**，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。



> RPC：Remote Procedure Call 

​	即远程过程调用，远程过程调用其实对标的是本地过程调用，本地过程调用你熟悉吧？想想那青葱岁月，你在大学赶着期末大作业，正在攻克图书管理系统，你奋笔疾书疯狂地敲击键盘，实现了图书借阅、图书归还等等模块，你实现的一个个方法之间的调用就叫本地过程调用。

简单的说**本机上内部的方法调用都可以称为==本地过程调用==**，而**远程过程调用实际上就指的是你本地调用了远程机子上的某个方法**，这就是==**远程过程调用**==。

![image-20211111102259443](https://i.loli.net/2021/11/11/ltCkgwJRVXaLN24.png)



**RPC 对标的是本地过程调用**，至于 RPC 要如何调用远程的方法可以走 HTTP、也可以是基于 TCP 自定义协议。

所以说你讨论 RPC 和 HTTP 就不是一个层级的东西。

**而 RPC 框架就是要实现像那小助手一样的东西，目的就是让我们使用远程调用像本地调用一样简单方便，并且解决一些远程调用会发生的一些问题**，使用户用的无感知、舒心、放心、顺心，它好我也好，快乐没烦恼。



远程调用过程：

​		**调用者传递了方法名、参数类型和参数值，提供者接收到这样参数之后调用对于的方法返回结果就好了**！







> Dubbo

原文链接：https://blog.csdn.net/qq_35190492/article/details/108071612

服务化场景下随之而来的就是服务之间的通信问题，那服务间的通信脑海中想到的就是 RPC，说到 RPC 就离不开咱们的 Dubbo。

==**实现了面向接口的代理 RPC 调用，并且可以配合 ZooKeeper 等组件实现服务注册和发现功能，并且拥有负载均衡、容错机制等**==。

























> **微服务架构又是啥**？

在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求，如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。

















### 核心组件

Spring Cloud是一个全家桶式的技术栈，包含了很多组件

最核心的几个组件:**Eureka、Ribbon、Feign、Hystrix、Zuul**



#### 业务场景

先来给大家说一个业务场景，假设咱们现在开发一个电商网站，要实现支付订单的功能，流程如下：

- 创建一个订单后，如果用户立刻支付了这个订单，我们需要将订单状态更新为“已支付”
- 扣减相应的商品库存
- 通知仓储中心，进行发货
- 给用户的这次购物增加相应的积分

针对上述流程，**我们需要有订单服务、库存服务、仓储服务、积分服务**。整个流程的大体思路如下：

- 用户针对一个订单完成支付之后，就会去找订单服务，更新订单状态
- 订单服务调用库存服务，完成相应功能
- 订单服务调用仓储服务，完成相应功能
- 订单服务调用积分服务，完成相应功能

**至此，整个支付订单的业务流程结束**

下图这张图，清晰表明了各服务间的调用过程：

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC8xMS83LzE2NmViZmZiNDhjNDgxYTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ)

好！有了业务场景之后，咱们就一起来看看Spring Cloud微服务架构中，这几个组件如何相互协作，各自发挥的作用以及其背后的原理。









#### Eureka

Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。

**咱们来考虑第一个问题**：订单服务想要调用库存服务、仓储服务，或者积分服务，怎么调用？

- 订单服务压根儿就不知道人家库存服务在哪台机器上啊！他就算想要发起一个请求，**都不知道发送给谁**，有心无力！
- 这时候，就轮到Spring Cloud Eureka出场了。Eureka是微服务架构中的注册中心，专门负责服务的注册与发现。

![image-20211101130432709](https://i.loli.net/2021/11/01/ZicAoter72hH9pb.png)

如上图所示，库存服务、仓储服务、积分服务中都有一个**Eureka Client组件，这个组件专门负责将这个服务的信息注册到Eureka Server中**。说白了，就是告诉Eureka Server，自己在哪台机器上，监听着哪个端口。而**Eureka Server是一个注册中心，里面有一个注册表，保存了各服务所在的机器和端口号**

订单服务里也有一个Eureka Client组件，这个Eureka Client组件会找Eureka Server问一下：库存服务在哪台机器啊？监听着哪个端口啊？仓储服务呢？积分服务呢？然后就可以把这些相关信息从Eureka Server的**注册表中拉取到自己本地缓存起来**。



这时:

​	**如果订单服务想要调用库存服务;**

1. **可以找自己本地的Eureka Client问一下库存服务在哪台机器？监听哪个端口吗？**
2. **收到响应后，紧接着就可以发送一个请求过去，调用库存服务扣减库存的那个接口！**
3. 同理，如果订单服务要调用仓储服务、积分服务，也是如法炮制。



总结一下：

- **Eureka Client：**负责将这个服务的信息注册到Eureka Server中
- **Eureka Server：**注册中心，里面有一个注册表，保存了各个服务所在的机器和端口号

















#### Feign

现在订单服务确实知道库存服务、积分服务、仓库服务在哪里了，同时也监听着哪些端口号了。**但是新问题又来了：难道订单服务要自己写一大堆代码，跟其他服务建立网络连接，然后构造一个复杂的请求，接着发送请求过去，最后对返回的响应结果再写一大堆代码来处理吗？**

这是上述流程翻译的代码片段，咱们一起来看看，体会一下这种绝望而无助的感受！！！

**友情提示，前方高能：**

![](https://i.loli.net/2021/11/01/3ZbtIFkSKnEhXD9.png)

看完上面那一大段代码，有没有感到后背发凉、一身冷汗？实际上你进行服务间调用时，**如果每次都手写代码，代码量比上面那段要多至少几倍**，所以这个事压根儿就不是地球人能干的。

既然如此，那怎么办呢？别急，**Feign**早已为我们提供好了优雅的解决方案。来看看如果用Feign的话，你的订单服务调用库存服务的代码会变成啥样？

![image-20211101140348056](https://i.loli.net/2021/11/01/taFbG8ERghxokCn.png)

看完上面的代码什么感觉？是不是感觉整个世界都干净了，又找到了活下去的勇气！

>步骤

没有底层的建立连接、构造请求、解析响应的代码，直接就是**用注解定义一个 FeignClient接口，然后调用那个接口就可以了**。人家Feign Client会在底层根据你的注解，**跟你指定的服务建立连接、构造请求、发起靕求、获取响应、解析响应，等等**。这一系列脏活累活，人家Feign全给你干了。



那么问题来了，Feign是如何做到这么神奇的呢？很简单，**Feign的一个关键机制就是使用了动态代理**。咱们一起来看看下面的图，结合图来分析：

- 首先，如果你对某个接口定义了@FeignClient注解，Feign就会针对这个接口创建一个动态代理
- 接着你要是调用那个接口，**本质就是会调用 Feign创建的动态代理**，这是核心中的核心
- Feign的动态代理**会根据你在接口上的@RequestMapping等注解，来动态构造出你要请求的服务的地址**
- 最后**针对这个地址，发起请求、解析响应**

![image-20211101141027499](https://i.loli.net/2021/11/01/r6KERqo7UQPOfJB.png)















#### Ribbon

说完了Feign，还没完。现在新的问题又来了，如果人家库存服务部署在了5台机器上，如下所示：

- 192.168.169:9000
- 192.168.170:9000
- 192.168.171:9000
- 192.168.172:9000
- 192.168.173:9000

**这下麻烦了！人家Feign怎么知道该请求哪台机器呢？**

- 这时Spring Cloud Ribbon就派上用场了。Ribbon就是专门解决这个问题的。它的作用是**负载均衡**，会帮你在每次请求时选择一台机器，均匀的把请求分发到各个机器上
- Ribbon的负载均衡默认使用的最经典的**Round Robin轮询算法**。这是啥？简单来说，就是如果订单服务对库存服务发起10次请求，那就先让你请求第1台机器、然后是第2台机器、第3台机器、第4台机器、第5台机器，接着再来—个循环，第1台机器、第2台机器。。。以此类推。

**此外，Ribbon是和Feign以及Eureka紧密协作，完成工作的，具体如下：**

- **首先Ribbon会从 Eureka Client里获取到对应的服务注册表**，也就**知道了所有的服务都部署在了哪些机器上，在监听哪些端口号**。
- 然后Ribbon就可以使用默认的Round Robin算法，**从中选择一台**机器
- Feign就会针对这台机器，构造并发起请求。

对上述整个过程，再来一张图，帮助大家更深刻的理解：

![image-20211101143117255](https://i.loli.net/2021/11/01/AFIC2LrZSTm1OVX.png)











#### Hystrix



​	在微服务架构里，一个系统会有很多的服务。

**以本文的业务场景为例**：订单服务==**在一个业务流程里需要调用三个服务才可以完成**==。

​	现在假设订单服务自己最多只有100个线程可以处理请求，然后呢，积分服务不幸的挂了，每次订单服务调用积分服务的时候，都会卡住几秒钟，然后抛出—个超时异常。

**咱们一起来分析一下，这样会导致什么问题？**

1. 如果系统处于高并发的场景下，大量请求涌过来的时候，订单服务的100个线程都会卡在请求积分服务这块。导致订单服务没有一个线程可以处理请求
2. 然后就会导致别人请求订单服务的时候，发现订单服务也挂了，不响应任何请求了

上面这个，就是**微服务架构中恐怖的服务雪崩问题**，如下图所示：

![image-20211101143729023](https://i.loli.net/2021/11/01/t4pm7ai3QDhRekF.png)

如上图，**这么多服务互相调用，要是不做任何保护的话，某一个服务挂了，就会引起连锁反应，导致别的服务也挂。**

​	比如积分服务挂了，会导致订单服务的线程全部卡在请求积分服务这里，没有一个线程可以工作，瞬间导致订单服务也挂了，别人请求订单服务全部会卡住，无法响应。也就是



**但是我们思考一下，就算积分服务挂了，订单服务也可以不用挂啊！为什么？**

- 我们结合业务来看：支付订单的时候，只要把库存扣减了，然后通知仓库发货就OK了
- 如果积分服务挂了，大不了等他恢复之后，慢慢人肉手工恢复数据！为啥一定要因为一个积分服务挂了，就直接导致订单服务也挂了呢？不可以接受！



**现在问题分析完了，如何解决？**

这时就轮到Hystrix闪亮登场了。Hystrix是**隔离、熔断以及降级**的一个框架。啥意思呢？说白了，**Hystrix会搞很多个小小的线程池**

​	比如：

1. 订单服务请求库存服务是一个线程池
2. 请求仓储服务是一个线程池
3. 请求积分服务是一个线程池。
4. **==每个线程池里的线程就仅仅用于请求那个服务。==**



**打个比方：现在很不幸，积分服务挂了，会咋样？**

​		当然会导致订单服务里那个用来**调用积分服务的线程都卡死不能工作了**啊！但由于订单服务调用库存服务、仓储服务的这两个线程池都是正常工作的，所以**另外的这两个服务不会受到任何影响**。



​		这个时候如果别人请求订单服务，订单服务还是可以正常调用库存服务扣减库存，调用仓储服务通知发货。只不过调用积分服务的时候，每次都会报错。**但是==如果积分服务都挂了，每次调用都要去卡住几秒钟干啥呢？有意义吗？当然没有！==**所以我们==直接对积分服务熔断==不就得了。比如==在5分钟内请求积分服务直接就返回了，不要去走网络请求卡住几秒钟==，**这个过程，就是所谓的熔断！**

​	**那人家又说，兄弟，积分服务挂了你就熔断，好歹你干点儿什么啊！别啥都不干就直接返回啊？**没问题，咱们就来个降级：每次==调用积分服务，你就在数据库里记录一条消息，说给某某用户增加了多少积分，因为积分服务挂了，导致没增加成功！==这样等积分服务恢复了，你可以根据这些记录手工加一下积分。**这个过程，就是所谓的降级。**

为帮助大家更直观的理解，接下来用一张图，梳理一下Hystrix隔离、熔断和降级的全流程：

![image-20211101145401907](https://i.loli.net/2021/11/01/jQoRZGI7mFhMebv.png)













#### Zuul

说完了Hystrix，接着给大家说说最后一个组件：Zuul，也就是微服务网关。**这个组件是负责网络路由的。**不懂网络路由？行，那我给你说说，如果没有Zuul的日常工作会怎样？

假设你后台部署了几百个服务，现在有个前端兄弟，人家请求是直接从浏览器那儿发过来的。

**打个比方**：

1. 人家要请求一下库存服务，你难道还让人家记着这服务的名字叫做inventory-service？

2. 部署在5台机器上？

3. 就算人家肯记住这一个，你后台可有几百个服务的名称和地址呢？难不成人家请求一个，就得记住一个？你要这样玩儿，那真是友谊的小船，说翻就翻！

   

   上面这种情况，压根儿是不现实的。所以**一般微服务架构中都必然会设计一个网关在里面**，像android、ios、pc前端、微信小程序、H5等等，**不用去关心后端有几百个服务，就知道有一个网关，==所有请求都往网关走，网关会根据请求中的一些特征，将请求转发给后端的各个服务==**。

而且有一个网关之后，还有很多好处，比如可以做**统一的降级、限流、认证授权、安全**，等等。











#### 总结

最后再来总结一下，上述几个Spring Cloud核心组件，在微服务架构中，分别扮演的角色：

- **Eureka**：各个服务启动时，Eureka Client都会将服务注册到Eureka Server，并且Eureka Client还可以反过来从Eureka Server拉取注册表，从而**知道其他服务在哪里**
- **Ribbon**：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的**多台机器中选择**一台
- **Feign**：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，**发起请求**
- **Hystrix**：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了**不同服务调用的隔离**，避免了服务雪崩的问题
- **Zuul**：如果前端、移动端要调用后端系统，**统一从Zuul网关进入，由Zuul网关转发请求给对应的服务**

以上就是我们通过一个电商业务场景，阐述了Spring Cloud微服务架构几个核心组件的底层原理。



**文字总结还不够直观？没问题！**我们将Spring Cloud的5个核心组件通过一张图串联起来，再来直观的感受一下其底层的架构原理：

![image-20211101150844582](https://i.loli.net/2021/11/01/GBxlwEYVOHzL1Dd.png)



























### 微服务架构

微服务架构是一种架构模式，它提倡将单一应用程序划分为一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。

每个服务运行在其独立的进程中，服务与服务间采用轻量级的通信机制互相协作(通常是基于HTTP协议的RESTful API)。每个服务都围绕具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。另外，应当尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言工具对其进行构建。



![image-20211111104942214](https://i.loli.net/2021/11/11/2vUpJSGzPygfDQL.png)







> #### 分布式微服务架构体系



**微服务架构完整体系图**

![image-20211111110240024](https://i.loli.net/2021/11/11/GfI2sAF6yer7R9O.png)



>SpringCloud = **分布式微服务架构的一站式全解决方案**，是**多种微服务架构技术的集合体**，俗称微服务全家桶。



![image-20211111110407020](https://i.loli.net/2021/11/11/7QuSamZ52RPw1iO.png)





微服务的分布式特性带来了挑战，Spring可以缓解这些问题，有几个随时可以运行的云模式**，Spring cloud 可以帮助==发现服务、负载均衡、断路、分布式跟踪和监控，甚至可以充当API网关==。**

![image-20211111111302227](https://i.loli.net/2021/11/11/2b6T7LZiBDSnFth.png)







> ##### SpringCloud中集成了多个项目

![image-20211111130422800](https://i.loli.net/2021/11/11/NilSkPGrpoqF57E.png)





> ##### 微服务实际架构案例

1.20年京东架构

![image-20211111130733303](https://i.loli.net/2021/11/11/KJT7OqZD9NzUSLe.png)



2.20年阿里架构

![image-20211111130948967](https://i.loli.net/2021/11/11/jahes6LHgQFXMOW.png)







![image-20211111131331022](https://i.loli.net/2021/11/11/x1o6e743fklBLmU.png)













> ##### 这么多的功能SpringCloud都包含了吗？

![image-20211111131934772](https://i.loli.net/2021/11/11/NU3E1JSsTkgoxKR.png)



实际上大部分都是包含，有少部分是调用外部组件。









##### 功能落地

![image-20211111131756527](https://i.loli.net/2021/11/11/sZXe95CtG7Fcy6h.png)









##### 兼容性搭配选择

spring Cloud 和Spring Boot 版本的兼容性搭配选择



| Release Train                                                | Boot Version                          |
| :----------------------------------------------------------- | :------------------------------------ |
| [2020.0.x](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-2020.0-Release-Notes) aka Ilford | 2.4.x, 2.5.x (Starting with 2020.0.3) |
| [Hoxton](https://github.com/spring-cloud/spring-cloud-release/wiki/Spring-Cloud-Hoxton-Release-Notes) | 2.2.x, 2.3.x (Starting with SR5)      |
| [Greenwich](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Greenwich-Release-Notes) | 2.1.x                                 |
| [Finchley](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Finchley-Release-Notes) | 2.0.x                                 |
| [Edgware](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Edgware-Release-Notes) | 1.5.x                                 |
| [Dalston](https://github.com/spring-projects/spring-cloud/wiki/Spring-Cloud-Dalston-Release-Notes) | 1.5.x                                 |



其中Spring Cloud Dalston、Edgware、Finchley 和 Greenwich 都已达到生命周期终止状态，不再受支持。



知道上述兼容的类型知道了相关springcloud需要配的springboot的版本，接下来可以引入**随着发布版本自动更新**的maven依赖了。

```xml
<groupId>org.example</groupId>
<artifactId>springcloud</artifactId>
<version>1.0-SNAPSHOT</version>

<!--每次加载都会从官网自动下载最新的依赖,springcloud版本号命名根据伦敦地铁站名(A-z)来命名-->
<properties>
    <spring.cloud-version>Hoxton.SR8</spring.cloud-version>
</properties>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring.cloud-version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>

</project>
```



更加详细的版本对应选型访问官网将Json字符串转换为对应格式即可：

https://start.spring.io/actuator/info

```js
"codecentric-spring-boot-admin":{
"2.4.3":"Spring Boot >=2.3.0.M1 and <2.6.0-M1"
},
"solace-spring-boot":{
"1.1.0":"Spring Boot >=2.3.0.M1 and <2.6.0-M1"
},
"solace-spring-cloud":{
"1.1.1":"Spring Boot >=2.3.0.M1 and <2.4.0-M1",
"2.1.0":"Spring Boot >=2.4.0.M1 and <2.6.0-M1"
},
"spring-cloud":{
"Hoxton.SR12":"Spring Boot >=2.2.0.RELEASE and <2.4.0.M1",
"2020.0.4":"Spring Boot >=2.4.0.M1 and <2.5.7-SNAPSHOT",
"2020.0.5-SNAPSHOT":"Spring Boot >=2.5.7-SNAPSHOT and <2.6.0-M1",
"2021.0.0-M1":"Spring Boot >=2.6.0-M1 and <2.6.0-M3",
"2021.0.0-M3":"Spring Boot >=2.6.0-M3 and <2.6.0-RC1",
"2021.0.0-RC1":"Spring Boot >=2.6.0-RC1 and <2.6.0-SNAPSHOT",
"2021.0.0-SNAPSHOT":"Spring Boot >=2.6.0-SNAPSHOT"
},
"spring-cloud-gcp":{
"2.0.4":"Spring Boot >=2.4.0-M1 and <2.6.0-M1"
},
"spring-cloud-services":{
"2.3.0.RELEASE":"Spring Boot >=2.3.0.RELEASE and <2.4.0-M1",
"2.4.1":"Spring Boot >=2.4.0-M1 and <2.5.0-M1"
}
```

<img src="https://i.loli.net/2021/11/11/i4d1Ga9VS8Or7XF.png" alt="image-20211111141443468" style="zoom:50%;" />













如果想选对应的boot版本:

<img src="https://i.loli.net/2021/11/11/Wx5eLbdU1lYJmDE.png" alt="image-20211111142047481" style="zoom:80%;" />

​	**1.那就点开这个Doc查看**

​	**2.官方推荐的兼容boot的版本号，才是最合适的**





组件替换过程从上到下，依次迭代/包含。

![image-20211111144522545](https://i.loli.net/2021/11/11/PaNjFBm4r5WiZzv.png)

















整体聚合
---

**微服务cloud整体聚合**



前期环境一定要配好！



### 父工程Project



> dependencyManagement

Maven 使用dependencyManagement 元素来提供了一种管理依赖版本号的方式。
通常会在一个组织或者项目的最顶层的父POM 中看到dependencyManagement 元素。

使用pom.xml 中的dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。
Maven 会沿着父子层次向上走，直到找到一个拥有dependencyManagement 元素的项目，然后它就会使用这个
dependencyManagement 元素中指定的版本号。


这样做的好处就是：如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一个版本时，只需要在顶层父容器里更新，而不需要一个一个子项目的修改 ；另外如果某个子项目需要另外的一个版本，只需要声明version就可。

*     dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。

*   如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，
     才会从父项目中继承该项，并且version和scope都读取自父pom;

*     如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。

















> 新建子模块

1.new Maven项目

![image-20211112094440090](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111120944476.png)







2.建立对应的子模块目录,记住-会被idea自动清除，所以需要重新粘贴学一下名字。

![image-20211112094617411](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111120946640.png)





>建立子模块yml文件





```java
//要做到滚瓜烂熟
Controller ——> service ——>dao
```





> 编写案例

![image-20211112140509040](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111121405349.png)





























































共八步：

<img src="https://i.loli.net/2021/11/11/GIKuCgN89FHfsSZ.png" alt="image-20211111150334298" style="zoom:50%;" />



#### 1.new Project

建立maven项目，勾选创建新项目

<img src="https://i.loli.net/2021/11/11/kiS5Kz3vu2V97Qw.png" alt="image-20211111151029632" style="zoom:50%;" />

![image-20211111151052922](https://i.loli.net/2021/11/11/6CoVUMafSkXGrbP.png)



![image-20211111151157115](https://i.loli.net/2021/11/11/35mPWq1nYQHkyAi.png)

![image-20211111151303111](https://i.loli.net/2021/11/11/ZKPowEfiNXnHRjs.png)

















#### 2.字符环境

![image-20211111151839337](https://i.loli.net/2021/11/11/AyBj1qV5Ng4K8D7.png)









#### 3.注解生效激活

![image-20211111153236341](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111111557152.png)







#### 4.Java版本

![image-20211111153726121](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111111557514.png)









![image-20211111154329352](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111111557628.png)



























热部署Devtools
---



>#### 为什么要使用热部署？

在SpringBoot中，当我们的代码改动了之后，在没有配置热部署的情况下idea默认不会给我们重启生效改动后的代码，需要程序员人工手动去重启服务，当改动的地方和微服务多了的时候，这是一件比较耗精力的一件事情。热部署可以很好的解决这个问题，配置了热部署后，当代码改动了之后，idea会自动重启服务生效改动后的代码。





>#### 如何使用热部署？

1.Adding devtools to your project(添加热部署依赖到目的子项目pom文件中)

2.下段配置我们粘贴进聚合父类总工程的pom.xml里

```xml
1. <build>
       <finalName>你自己的工程名字</finalName>
       <plugins>
           <plugin>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-maven-plugin</artifactId>
               <configuration>
                   <fork>true</fork>
                   <addResources>true</addResources>
               </configuration>
           </plugin>
       </plugins>
   </build>
```



3.Enabling automatic build在IDEA中勾选配置

4.Update the value of勾选配置

5.重启测试







> #### 总结

​	实际应用场景更多的是在开发阶段，如果在生产阶段，并不知道自己改的是对是错更多的是调试琢磨的心态，所以就需要记得关闭热部署。











































## model





### model-01



#### **cloud-provider-payment8001**

![image-20211112205201846](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122052091.png)



http://localhost:8001/payment/get/31

http://localhost/consumer/payment/create?serial=农夫山泉

完成测试

![image-20211112204629322](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122046529.png)

![image-20211112205104268](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122051470.png)

这里上述只是一个微服务，后续随着微服务越来越多，慢慢体会微服务架构带来的魅力！



![image-20211112205419125](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111122054425.png)































### model-02



#### cloud-consumer-order80

微服务消费者订单Module模块









model-02中客户端用80端口调用model-01中的8001端口得service

的调用接口方式的封装











???

==问题：11.15时学习springcloud中12节时，当写到消费者的yml可以去server: port: 80去调用8081的时候无需定义其它数据库等相关配置，只需要定义一个server：port:80即可享有到微服务提供者的数据库配置。==

80端口是为[HTTP](https://baike.baidu.com/item/HTTP)（HyperText Transport Protocol)即[超文本传输协议](https://baike.baidu.com/item/超文本传输协议/8535513)开放的，此为上网冲浪使用次数最多的协议，主要用于WWW（World Wide Web）即万维网传输信息的协议。

可以通过HTTP地址（即常说的“网址”）加“: 80”来访问网站，因为浏览网页服务默认的[端口号](https://baike.baidu.com/item/端口号/10883658)都是80，因此只需输入网址即可，不用输入“: 80”了。



![image-20211115152950910](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111151529734.png)

==问题：如上此@RequestBody到底起了什么妙用？==





Run Dashboard

![image-20211115155412143](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111151554373.png)







### RestTemplate



> 是什么？

RestTemplate提供了多种便捷访问远程Http服务的方法， 
是一种简单便捷的访问restful服务模板类，是Spring提供的用于访问Rest服务的客户端模板工具集





 

> 官网地址



https://docs.spring.io/spring-framework/docs/5.2.2.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html



> 使用

使用restTemplate访问restful接口非常的简单粗暴无脑。
(url, requestMap, ResponseBean.class)这三个参数分别代表 
REST请求地址、请求参数、HTTP响应转换被转换成的对象类型。

 

 

 







![image-20211115130857845](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111151308254.png)

RestTemplate 是由 Spring 提供的一个 HTTP 请求工具。在上文的案例中，开发者也可以不使用 RestTemplate ，使用 Java 自带的 HttpUrlConnection 或者经典的网络访问框架 HttpClient 也可以完成上文的案例，只是在 Spring 项目中，使用 RestTemplate 显然更方便一些。在传统的项目架构中，因为不涉及到服务之间的调用，大家对 RestTemplate 的使用可能比较少



















项目重构
---

将结构优化，考虑代码的复用以及后续建立多个项目之后代码可以变的更加简洁一些。

![image-20211115161153425](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111151611622.png)

新建一个cloud-api-commons项目，此项目的作用就是包括冗余重复的每个项目所必须的实体类，以及后期所需的第三方接口，还有一些相关的工具类等。实现代码的复用，优化总体项目机构。











核心组件
---





### 服务注册中心





![image-20211115164256314](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111151642530.png)



>尽管Eureka已经过时，但是曾经它为什么可以担任cloud中这么重要的服务注册中心？





> 什么是服务治理?　　

​     Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理 ，在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间的依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。





什么是传统的`rpc远程调用`

RPC 是远程过程调用（Remote Procedure Call）的缩写形式。RPC 是指：

1. 计算机 A 上的进程，调用另外一台计算机 B 上的进程。
2. 其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行
3. 当值返回给 A 时，A进程继续执行。
4. **调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。**而这一过程，对于开发人员来说是透明的。





`单点故障`

- 通常分布式系统采用主从模式，**一个主机连接多个处理节点，主节点负责分发任务，而子节点负责处理业务，当主节点发生故障时，会导致整个系统发故障**，我们把这种故障叫做单点故障。

- 假设服务提供者并不使用集群，只使用一台机器非常容易出现单点故障















> 什么是服务注册与发现？

​	Eureka采用了**CS的设计架构**，Eureka Server 作为服务注册功能的服务器，**它是服务注册中心**。而系统中的**其它微服务，使用 Eureka的客户端==连接==到 Eureka Server并维持心跳连接**。这样系统的维护人员就可以通过 Eureka Server 来**==监控==**系统中各个微服务是否正常运行。
​	在服务注册与发现中，有一个**注册中心**。当服务器启动的时候：

1. 会把当前自己服务器的信息 比如 服务地址通讯地址等以别名方式注册到注册中心上。
2. 另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址
3. 然后再实现本地RPC调用RPC远程调用框架
4. 核心设计思想：在于**==注册中心==**，因为**使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何rpc远程框架中，都会有一个注册中心**(存放服务地址相关信息(接口地址))



​										下左图是Eureka系统架构，右图是Dubbo的架构，请对比

![image-20211115170711706](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111151707926.png)





`心跳连接`

​	两个进程之间如果要通信，很显然必须要建立一个连接，通过它来相互传输数据。在网络通信过程中，主机与主机之前一般情况下是通过通过TCP协议进行连接的，既然是连接，那么就会有连接时间的长短，长时间的连接称之为长连接，短时间的连接称之为短连接，在长连接的过程中，由于是长时间连接，所以对于服务器来说，需要去判断连接进来的客户端是不是还在连接的过程中，这里就涉及到心跳的问题。就像人的心跳一样，**每跳动一次，就发出一个消息，看看能不能得到回应，如果能得到回应，说明客户端还在连接的过程中，如果得不到回应，在一定的心跳次数下依然得不到回应，就判断长连接断开了**。







#### Eureka



> Eureka包含两个组件：Eureka Server和Eureka Client



- Eureka Server提供服务注册服务
  各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。

- EurekaClient通过注册中心进行访问

​	是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负 载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）

 

 



![image-20211122093924262](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111220939798.png)

生成eurekaServer端服务注册中心
类似物业公司







> Eureka2.0官方停止更新,2018年7月份



![image-20211122130244477](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111221302721.png)









##### 高可用





> Eureka集群原理说明

![image-20211122132501992](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111221325204.png)



1. 启动eureka注册中心
2. 启动服务提供者payment支付服务
3. 支付服务启动后会把自身信息(比如服务地址以别名方式地址注册进eureka)
4. 消费者order服务在需要调用接口时，使用刚服务别名去注册中心获取实际的RPC远程调用地址
5. 消费者的得到调用的地址后，底层实际上是利用HttpClien技术实现远程调用
6. 消费者获得服务地址后会缓存在本地JVM内存中默认间隔30s更新一次服务调用地址









> 问题：微服务RPC远程服务调用最核心的是什么 

​	高可用，试想你的注册中心只有一个only one， 它出故障了那就呵呵(￣▽￣)"了，会导致整个为服务环境不可用，所以　

　解决办法：搭建Eureka注册中心集群 ，**实现负载均衡+故障容错**





**互相注册，相互守望**，对外暴露出的是一个整体

![image-20211122140237418](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202111221402639.png)



注：每一个注册中心也必须除了自己本身已经存在注册的用户，还必须要有其它兄弟的相关信息







> 高可用

可用性度量与考核

​	原文链接：https://blog.csdn.net/andong154564667/article/details/80776956

　　首先，不得不说：要保证一个网站永远完全可用几乎是一件不可能完成的任务（Mission Impossible，是不是有点碟中谍的感觉）。

 　　（1）如何度量网站可用性？

　　一个神奇的数字—9！你有几个9，就代表了你的可用性。例如QQ可用性达到了4个9：99.99%

　　①2个9=基本可用　　

​		②3个9=较高可用　　

​		③4个9=具有自动恢复能力的高可用　　

​		④5个9=极高可用->理想状态

　　

那么，可用性的9又是怎么计算出来的呢：

　　①
$$
网站不可用时间=故障修复时间点-故障发现时间点
$$


　　②
$$
网站年度可用性指标=（1-网站不可用时间/年度总时间）*100%
$$


　　（2）如何考核网站可用性？

　　广泛采用故障分的，它是对网站故障进行分类加权计算故障责任的方法。一般会给每个分类的故障设置一个权重（例如事故级故障权重为100，A类为20等），其计算公式为：故障分=故障时间（分钟）*故障权重。公司对技术团队的考核一般会参考故障分，例如某团队今年发生了几个事故级故障，那么其绩效考核估计受到很大影响，年终奖什么的就悲剧了。



