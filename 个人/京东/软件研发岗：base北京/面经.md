以下为基于京东社招 Java 软件开发岗岗位要求的**高效备考计划**，包括算法典型题目、系统设计、源码原理与行为面等，应试计划表。

---

## 概述  
针对京东社招技术面试，算法题为必考环节，难度通常集中在 LeetCode Easy–Medium 级别，覆盖哈希表、滑动窗口、链表、栈/队列、树遍历、二分查找、动态规划、堆等常见题型 citeturn0search2。同时还需准备系统设计、高并发架构、JVM/Spring Boot 源码原理及团队协作等内容 citeturn0search3。  

---

## 面试模块拆解  
1. **算法与编码**：在线或白板编程题，重点考察数据结构与算法思维 citeturn0search5。  
2. **系统设计**：大规模系统、高并发方案、微服务拆分与演进 citeturn0search1。  
3. **源码原理**：深入理解 HotSpot GC、类加载、Spring Boot 自动配置与启动流程 citeturn4search3。  
4. **行为与团队**：基于 STAR 法则准备项目管理、技术落地、团队协作案例 citeturn0search3。  

---

## 算法题训练

>列表

| 题型       | LeetCode 题号与标题                                          | 难度   | 关键思路              |
| ---------- | ------------------------------------------------------------ | ------ | --------------------- |
| 哈希表     | [Two Sum](https://leetcode-cn.com/problems/two-sum/) (1)     | Easy   | 单次遍历 + 哈希存补数 |
| 滑动窗口   | [Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/) (3) | Medium | 左右指针动态维护窗口  |
| 链表       | [Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list/) (206) | Easy   | 前后指针就地翻转      |
| 栈/队列    | [Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/) (20) | Easy   | 利用栈匹配括号        |
| 二叉树遍历 | [Binary Tree Inorder Traversal](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) (94) | Medium | 递归或显式栈          |
| 二分查找   | [Binary Search](https://leetcode-cn.com/problems/binary-search/) (704) | Easy   | 折半区间收缩          |
| 动态规划   | [Climbing Stairs](https://leetcode-cn.com/problems/climbing-stairs/) (70) | Easy   | 斐波那契或滚动数组    |
| 堆         | [Top K Frequent Elements](https://leetcode-cn.com/problems/top-k-frequent-elements/) (347) | Medium | 哈希计数 + 小顶堆     |

---



### 1.[Two Sum](https://leetcode-cn.com/problems/two-sum/)

```java
import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;
 
/**
 * 思路:
 * 1.使用HashMap将nums中的元素所谓key,index作为value也就是<value,index>
 * 2.遍历nums,当map.get(target - nums[i]) && i <  map.get(target - nums[i])时成立
 */
public class Main{
    public static void main(String[] args){
        System.out.println("请输入参数数组,元素之间以 分隔：");
        Scanner scanner = new Scanner(System.in);
        String[] split = scanner.nextLine().split(" ");
        System.out.println("请输入target:");
        int target = scanner.nextInt();
        int[] nums = new int[split.length];
        Map<Integer,Integer> map = new HashMap<>();
        for (int i = 0; i < split.length; i++) {
            nums[i] = Integer.valueOf(split[i]);
            map.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            int num = target - nums[i];
            if (map.containsKey(num) && i < map.get(num)){
                System.out.println("结果为:" + nums[i] +"," + num);
            }
        }
    }
}
```



---



### 2.[Longest Substring Without Repeating Characters](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)



#### 尝试一：双指针遍历

```java
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;
/**
 * 思路:双指针:
 * 1.定义双指针left,right,Set,max作为最长字符串变量值
 * 2.初始left=0,right=1,right不断向右移动，right经过的所有不重复元素(使用set判断是否重复)均加入到Set中。
 * 3.遍历到重复的元素时,right - left最为本次最长无重复字符串长度。让Math.max(max,right - left)
 */
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入参数字符串:");
        String param = scanner.nextLine();
        int max = 0;
        Set<Character> set = new HashSet<>();
        for (int left = 0; left < param.length(); left++) {
            for (int right = left; right < param.length(); right++) {
                if (set.contains(param.charAt(right))) {
                    System.out.println("本次无重复遍历终止:" + set);
                    set.clear();
                    break;
                } else {
                    set.add(param.charAt(right));
                    max = Math.max(right - left + 1, max);
                }
            }
        }
        System.out.println(max);
    }
}
```



#### 尝试二(优化一次遍历)

```java
import java.util.HashSet;
import java.util.Scanner;
import java.util.Set;

/**
 * 38.50% + 50.03%
 * 滑动双指针(一次遍历):
 * 1.定义left,right滑动双指针,还有一个动态的滑动窗口set
 * 2.while(right < param.length()):动态维护无重复滑动set
 *      while(set中包含param.charAt(right))时:left++,set删除滑动窗口最起始的第一个元素
 *      反之:让set继续添加元素,right++,max = Math.max(max, right - left);
 *      
 * 时间复杂度：O(n)，其中n是字符串长度。虽然有嵌套的while循环，但右指针最多移动n次，左指针也最多移动n次，所以总操作次数不超过2n。
 * 空间复杂度：O(min(m,n))，其中m是字符集大小，n是字符串长度。HashSet最多存储min(m,n)个元素。
 */
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入参数字符串:");
        String param = scanner.nextLine();
        int max = 0;
        Set<Character> set = new HashSet<>();
        int left = 0, right = 0;
        while (right < param.length()) {
            char c = param.charAt(right);
            while (set.contains(c)) {
                set.remove(param.charAt(left));
                left++;
            }
            set.add(c);
            right++;
            if (max < right - left) {
                System.out.println("最新无重复字符串=" + set);
            }
            max = Math.max(max, right - left);
        }
        System.out.println("maxLength = " + max);
    }
}
```



---



### 3.[Reverse Linked List](https://leetcode-cn.com/problems/reverse-linked-list/)

```java
/**
 * 100% + 63.82%
 * 双指针反转:
 * 1.定义left,right双指针
 *      因链表尾部最后一个节点=null表示链表结束位故此：left = null
 *      right初始值 = head
 * 2.while(right != null)
 * 3.使用一个temp作为每次循环新建节点使得它每次指向的初始位置 = right.next保留下一次遍历位置
 * 4.right.next = left;反转节点,使得原本指向temp,反转指向left
 * 5.left = right;表示left继续移动到下一个位置
 * 6.right = temp;表示right继续移动到原本未反转的下一个位置
 * 由此完成一个反转,继续遍历可完成整个链表的反转,由于最后一次right = null,故此return left为有效链表开始的head节点
 */
public class Main {
    public static void main(String[] args) {
        ListNode reversedList = reverseList(getHead());
        System.out.println();
        System.out.println("反转后链表为：");
        while (reversedList != null) {
            System.out.print(reversedList.val + " ");
            reversedList = reversedList.next;
        }
    }

    /**
     * 反转链表
     *
     * @param head 请求参数
     * @return 反转后的链表
     */
    public static ListNode reverseList(ListNode head) {
        //无节点或者有且只有1个节点,直接返回无需反转
        if (head == null || head.next == null) {
            return head;
        }
        //其中null为尾节点,提前定义
        ListNode left = null, right = head;
        while (right != null) {
            ListNode temp = right.next;
            right.next = left;
            left = right;
            right = temp;
        }
        return left;
    }

    /**
     * 获取head参数链表
     *
     * @return 参数链表
     */
    public static ListNode getHead() {
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        System.out.println("原始参数待反转链表为：");
        ListNode temp = head;
        while (temp != null) {
            System.out.print(temp.val + " ");
            temp = temp.next;
        }
        return head;
    }
}

/**
 * 定义ListNode
 */
class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```



---



### 4.[Valid Parentheses](https://leetcode-cn.com/problems/valid-parentheses/)

```java
import java.util.Scanner;
import java.util.Stack;

/**
 * @author Hao Li
 * @program: alorithms
 * @Date 2025-05-01 16:38:47
 * @description: Thought process:有效的括号
 * 给定一个只包括'(',')','{','}','[',']'的字符串s，判断字符串是否有效。
 * 有效字符串需满足：
 * 1.左括号必须用相同类型的右括号闭合。
 * 2.左括号必须以正确的顺序闭合。
 * 3.每个右括号都有一个对应的相同类型的左括号。
 * <p>
 * 思路(栈)：
 * 每一个左括号都会有对应的相同的右括号，且顺序对应一致。
 * 1.前置判断:排除s.length() % 2 != 0的情况,因为只有必须闭合长度必须是偶数(s == null || s.length() == 0依旧为有效字符)。
 * 2.遍历每次字符c,
 * 如果当前c=左括号就让rightStack.push(对应的右括号)
 * 如果遍历到了右括号就判断当前rightStack.isEmpty() || rightStack.pop() != c ==>  false
 * 3.最终如果rightStack.isEmpty()时表示相对的括号都闭合了，返回true,反之返回false。
 */
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("请输入仅包含'(',')','{','}','[',']'的参数字符串:");
        String s = scanner.nextLine();
        System.out.println("输入的字符串=" + s);
        if (s == null || s.length() == 0) {
            System.out.println("有效字符串:true");
            return;
        }
        if (s.length() % 2 != 0) {
            System.out.println("false");
            return;
        }
        Stack<Character> rightStack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            switch (c) {
                case '(':
                    rightStack.push(')');
                    break;
                case '{':
                    rightStack.push('}');
                    break;
                case '[':
                    rightStack.push(']');
                    break;
                default:
                    if (rightStack.empty() || rightStack.pop() != c) {
                        System.out.println("false");
                        return;
                    }
            }
        }
        if (!rightStack.isEmpty()) {
            System.out.println("false");
            return;
        }
        System.out.println("true");
    }
}
```















## 系统设计 & 源码原理复习

- **系统设计流程**：需求→高层架构→组件拆分→数据模型→API 设计→扩展与容错 citeturn0search1。  
- **JVM & GC**：类加载流程、内存模型、ZGC/压缩指针、停顿控制等实战案例 citeturn0search10。  
- **Spring Boot 3.4.x**：自动配置 (@Conditional)、Starter 原理、嵌入式服务器启动流程 citeturn4search0。  

---

## 行为面 & 团队协作  
- **STAR 案例**：项目上线、性能优化、故障处理、技术分享，输出量化数据。  
- **价值观匹配**：客户为先、创新、拼搏、担当、感恩、诚信。  





## 准备计划表

| 时间       | 模块           | 具体任务                                                     |
| ---------- | -------------- | ------------------------------------------------------------ |
| -5 ~ -3 天 | 算法刷题       | 每日 3 道 LeetCode 题：<br>- Two Sum (1)<br>- Valid Parentheses (20)<br>- Binary Search (704)<br>- Reverse Linked List (206)<br>- Climbing Stairs (70)<br>- Top K Frequent Elements (347)（轮换练习） |
|            | 系统设计       | 模拟 2 次系统设计：<br>- 社交平台高并发设计<br>- 电商库存系统架构 |
|            | 源码原理       | 阅读并笔记：<br>- HotSpot GC & ZGC 调优案例<br>- Spring Boot 3.4.x 自动配置 & 启动流程 |
| -2 天      | 算法冲刺       | 高频题专项回顾：<br>- 滑动窗口 (3)<br>- 二叉树遍历 (94)<br>- Top K Frequent Elements (347) |
|            | Mock Interview | 1 次：在线编程 + 20 分钟系统设计 + 行为面试                  |
| -1 天      | 要点回顾       | - 自我介绍 & 职业规划<br>- STAR 案例 3 个<br>- 检查设备与环境 |
| 面试当日   | 状态调整       | - 早起浅运动<br>- 冥想或手写笔记，保证精神饱满               |

---

以上计划覆盖**算法、设计、源码、行为**四大模块，量化到每日任务，助你有条不紊、高效备考，预祝 5 月 6 日面试成功！

