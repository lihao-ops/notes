

```xml
        <!-- Guava（令牌桶限流） -->
        <dependency>
            <groupId>com.google.guava</groupId>
            <artifactId>guava</artifactId>
            <version>32.1.3-jre</version>
        </dependency>
```







```java
package cn.com.wind.wstock.datashareservice.common.utils;

import com.google.common.util.concurrent.RateLimiter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.concurrent.ConcurrentHashMap;

/**
 * 单实例限流器
 * 只用 Guava RateLimiter，无需 Redis
 */
@Slf4j
@Component
public class SimpleRateLimiter {
    
    // 存储每个接口的限流器
    private final ConcurrentHashMap<String, RateLimiter> limiters = new ConcurrentHashMap<>();
    
    /**
     * 尝试获取令牌
     * @param key 限流键（通常是接口路径）
     * @param qps 每秒允许的请求数
     * @return true=通过，false=限流
     */
    public boolean tryAcquire(String key, double qps) {
        RateLimiter limiter = limiters.computeIfAbsent(key, k -> {
            log.info("创建限流器: key={}, qps={}", k, qps);
            //创建的是一个 带最多 1 秒突发能力、支持平滑发放令牌的限流器，它保证平均 QPS 不超过设定值，但允许短暂的快速突发（burst）
            return RateLimiter.create(qps);
        });
        
        // 动态调整速率
        if (limiter.getRate() != qps) {
            limiter.setRate(qps);
        }
        //立刻拿令牌，不等待。如果当前没有令牌，立即返回 false。
        return limiter.tryAcquire();
    }
    
    /**
     * 获取当前速率
     */
    public double getRate(String key) {
        RateLimiter limiter = limiters.get(key);
        return limiter != null ? limiter.getRate() : 0;
    }
}
```



```java
package cn.com.wind.wstock.datashareservice.common.utils.limit;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 简单的压测工具
 */
@Slf4j
@Component
public class SimplePressureTester {

    private final RestTemplate restTemplate = new RestTemplate();

    /**
     * 压测单个接口
     *
     * @param url             接口URL
     * @param threadCount     并发线程数
     * @param durationSeconds 持续时间（秒）
     * @return 压测结果
     */
    public PressureTestResult pressTest(String url, String requestBody, int threadCount, int durationSeconds) {
        log.info("开始压测: url={}, threads={}, duration={}s", url, threadCount, durationSeconds);

        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger failCount = new AtomicInteger(0);
        AtomicInteger limitedCount = new AtomicInteger(0);

        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        long endTime = System.currentTimeMillis() + durationSeconds * 1000;
        CountDownLatch latch = new CountDownLatch(threadCount);

        // 新增这3行
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        HttpEntity<String> entity = new HttpEntity<>(requestBody, headers);

        // 启动压测线程
        for (int i = 0; i < threadCount; i++) {
            executor.submit(() -> {
                try {
                    while (System.currentTimeMillis() < endTime) {
                        try {
                            ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);

                            if (response.getStatusCodeValue() == 200) {
                                successCount.incrementAndGet();
                            } else if (response.getStatusCodeValue() == 429) {
                                limitedCount.incrementAndGet();
                            } else {
                                failCount.incrementAndGet();
                            }

                            // 短暂休眠，避免空转
                            Thread.sleep(10);

                        } catch (Exception e) {
                            if (e.getMessage() != null && e.getMessage().contains("429")) {
                                limitedCount.incrementAndGet();
                            } else {
                                failCount.incrementAndGet();
                            }
                        }
                    }
                } finally {
                    latch.countDown();
                }
            });
        }

        // 等待所有线程完成
        try {
            latch.await();
        } catch (InterruptedException e) {
            log.error("压测被中断", e);
        }

        executor.shutdown();

        // 计算结果
        int totalRequests = successCount.get() + failCount.get() + limitedCount.get();
        double qps = successCount.get() / (double) durationSeconds;
        double limitRate = limitedCount.get() * 100.0 / totalRequests;

        PressureTestResult result = new PressureTestResult();
        result.setUrl(url);
        result.setThreadCount(threadCount);
        result.setDurationSeconds(durationSeconds);
        result.setTotalRequests(totalRequests);
        result.setSuccessCount(successCount.get());
        result.setLimitedCount(limitedCount.get());
        result.setFailCount(failCount.get());
        result.setQps(qps);
        result.setLimitRate(limitRate);

        log.info("压测完成: {}", result);

        return result;
    }

    /**
     * 压测结果
     */
    public static class PressureTestResult {
        private String url;
        private int threadCount;
        private int durationSeconds;
        private int totalRequests;
        private int successCount;
        private int limitedCount;
        private int failCount;
        private double qps;
        private double limitRate;

        // Getters and Setters
        public String getUrl() {
            return url;
        }

        public void setUrl(String url) {
            this.url = url;
        }

        public int getThreadCount() {
            return threadCount;
        }

        public void setThreadCount(int threadCount) {
            this.threadCount = threadCount;
        }

        public int getDurationSeconds() {
            return durationSeconds;
        }

        public void setDurationSeconds(int durationSeconds) {
            this.durationSeconds = durationSeconds;
        }

        public int getTotalRequests() {
            return totalRequests;
        }

        public void setTotalRequests(int totalRequests) {
            this.totalRequests = totalRequests;
        }

        public int getSuccessCount() {
            return successCount;
        }

        public void setSuccessCount(int successCount) {
            this.successCount = successCount;
        }

        public int getLimitedCount() {
            return limitedCount;
        }

        public void setLimitedCount(int limitedCount) {
            this.limitedCount = limitedCount;
        }

        public int getFailCount() {
            return failCount;
        }

        public void setFailCount(int failCount) {
            this.failCount = failCount;
        }

        public double getQps() {
            return qps;
        }

        public void setQps(double qps) {
            this.qps = qps;
        }

        public double getLimitRate() {
            return limitRate;
        }

        public void setLimitRate(double limitRate) {
            this.limitRate = limitRate;
        }

        @Override
        public String toString() {
            return String.format(
                    "压测结果 [URL=%s, 线程=%d, 时长=%ds, 总请求=%d, 成功=%d, 限流=%d, 失败=%d, QPS=%.1f, 限流率=%.2f%%]",
                    url, threadCount, durationSeconds, totalRequests, successCount, limitedCount,
                    failCount, qps, limitRate
            );
        }
    }
}
```



```java
package cn.com.wind.wstock.datashareservice.common.annotation;

import java.lang.annotation.*;

/**
 * 接口限流注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface SimpleRateLimit {

    /**
     * 每秒允许的请求数（支持 ${property} 格式或直接数字）
     */
    String qps() default "100";
    
    /**
     * 限流提示
     */
    String message() default "请求过于频繁，请稍后重试";
}
```



```java
package cn.com.wind.wstock.datashareservice.common.aspect;


import cn.com.wind.wstock.datashareservice.common.annotation.SimpleRateLimit;
import cn.com.wind.wstock.datashareservice.common.utils.SimpleRateLimiter;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.env.Environment;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

/**
 * 限流切面
 */
@Slf4j
@Aspect
@Component
public class SimpleRateLimitAspect {

    @Autowired
    private Environment environment;

    @Autowired
    private SimpleRateLimiter rateLimiter;

    /**
     * 加载QPS阀值的信息只打印一次
     * 验证是否正常从yml加载对应阀值
     */
    private static volatile boolean LOG_QPS_FLAG = false;

    @Around("@annotation(limit)")
    public Object around(ProceedingJoinPoint point, SimpleRateLimit limit) throws Throwable {
        // 获取请求路径作为限流 key
        String key = getRequestUri();
        double qps = parseQps(limit.qps());
        // 尝试获取令牌
        boolean allowed = rateLimiter.tryAcquire(key, qps);
        if (!allowed) {
            log.warn("请求被限流:uri={},qps={}", key, qps);
            throw new RuntimeException(limit.message());
        }

        // 放行
        return point.proceed();
    }

    /**
     * 解析QPS值，支持 ${property} 格式和直接数字
     */
    private double parseQps(String qpsStr) {
        if (qpsStr.startsWith("${") && qpsStr.endsWith("}")) {
            String propertyName = qpsStr.substring(2, qpsStr.length() - 1);
            String value = environment.getProperty(propertyName);
            if (value != null) {
                try {
                    //此日志只打印一次,防止打印日志滥用
                    if (!LOG_QPS_FLAG) {
                        LOG_QPS_FLAG = true;
                        log.info("SimpleRateLimitAspect_parseQps={}", value);
                    }
                    return Double.parseDouble(value);
                } catch (NumberFormatException e) {
                    log.error("配置值无法解析为数字: {}={}", propertyName, value);
                    return 100.0;
                }
            }
            log.warn("未找到配置: {}, 使用默认值100", propertyName);
            return 100.0;
        }

        try {
            return Double.parseDouble(qpsStr);
        } catch (NumberFormatException e) {
            log.error("QPS值无法解析: {}, 使用默认值100", qpsStr);
            return 100.0;
        }
    }

    private String getRequestUri() {
        ServletRequestAttributes attributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attributes != null) {
            HttpServletRequest request = attributes.getRequest();
            return request.getRequestURI();
        }
        return "unknown";
    }
}
```





```java
package cn.com.wind.wstock.datashareservice.common.utils.limit;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * 简单限流压测
 */
@Slf4j
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class SimpleRateLimitTest {

    @LocalServerPort
    private int port;

    @Autowired
    private SimplePressureTester tester;

    private String getUrl(String path) {
        return "http://localhost:" + port + path;
    }

    @Test
    @Order(1)
    @DisplayName("测试简单接口限流 - QPS=1000")
    void testSimpleRateLimit() {
        String url = getUrl("/wstock_share/agent/message");
        String requestBody = "{\"jsonrpc\":\"2.0\",\"id\":\"agent-serverid 1\",\"method\":\"message/stream\",\"params\":{\"id\":\"1\",\"sessionId\":\"23648d87-dabe-4db4-a13a-52cec9481968\",\"agentLoginSessionId\":\"\",\"message\":{\"role\":\"user\",\"parts\":[{\"kind\":\"text\",\"text\":\"分析一下酒鬼酒今年后续交易日累计涨跌幅？\"},{\"kind\":\"data\",\"data\":\"\"}]}}}";

        SimplePressureTester.PressureTestResult result = tester.pressTest(url, requestBody, 100, 10);

        log.info("=== 简单接口压测结果 ===");
        log.info("总请求数: {}", result.getTotalRequests());
        log.info("成功数: {}", result.getSuccessCount());
        log.info("被限流数: {}", result.getLimitedCount());
        log.info("实际 QPS: {}", String.format("%.1f", result.getQps()));
        log.info("限流率: {}%", String.format("%.2f", result.getLimitRate()));

//        // 断言：实际 QPS 应该接近配置的 1000
//        assertThat(result.getQps()).isBetween(800.0, 1200.0);
        // 断言：实际 QPS 应该接近配置的 200
        assertThat(result.getQps()).isBetween(180.0, 220.0);

        // 断言：应该有大量请求被限流
        assertThat(result.getLimitedCount()).isGreaterThan(1000);
    }

//    @Test
//    @Order(2)
//    @DisplayName("测试中等接口限流 - QPS=5")
//    void testMediumRateLimit() {
//        String url = getUrl("/api/test/medium");
//
//        SimplePressureTester.PressureTestResult result =
//                tester.pressTest(url, 30, 10);
//
//        log.info("=== 中等接口压测结果 ===");
//        log.info("总请求数: {}", result.getTotalRequests());
//        log.info("成功数: {}", result.getSuccessCount());
//        log.info("被限流数: {}", result.getLimitedCount());
//        log.info("实际 QPS: {}", String.format("%.1f", result.getQps()));
//
//        // 断言：实际 QPS 应该接近 5
//        assertThat(result.getQps()).isBetween(4.0, 6.0);
//    }
//
//    @Test
//    @Order(3)
//    @DisplayName("测试重接口限流 - QPS=2")
//    void testHeavyRateLimit() {
//        String url = getUrl("/api/test/heavy");
//
//        SimplePressureTester.PressureTestResult result =
//                tester.pressTest(url, 20, 10);
//
//        log.info("=== 重接口压测结果 ===");
//        log.info("总请求数: {}", result.getTotalRequests());
//        log.info("成功数: {}", result.getSuccessCount());
//        log.info("被限流数: {}", result.getLimitedCount());
//        log.info("实际 QPS: {}", String.format("%.1f", result.getQps()));
//
//        // 断言：实际 QPS 应该接近 2
//        assertThat(result.getQps()).isBetween(1.5, 2.5);
//    }
//
//    @Test
//    @Order(4)
//    @DisplayName("测试无限流接口")
//    void testNoLimit() {
//        String url = getUrl("/api/test/no-limit");
//
//        SimplePressureTester.PressureTestResult result =
//                tester.pressTest(url, 50, 10);
//
//        log.info("=== 无限流接口压测结果 ===");
//        log.info("总请求数: {}", result.getTotalRequests());
//        log.info("成功数: {}", result.getSuccessCount());
//        log.info("实际 QPS: {}", String.format("%.1f", result.getQps()));
//
//        // 断言：应该没有被限流的请求
//        assertThat(result.getLimitedCount()).isEqualTo(0);
//
//        // 断言：QPS 应该很高（> 100）
//        assertThat(result.getQps()).isGreaterThan(100.0);
//    }
//
//    @Test
//    @Order(5)
//    @DisplayName("对比测试：有限流 vs 无限流")
//    void testComparison() {
//        log.info("=== 对比测试 ===");
//
//        // 有限流的接口
//        SimplePressureTester.PressureTestResult withLimit =
//                tester.pressTest(getUrl("/api/test/simple"), 100, 10);
//
//        // 等待一秒
//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//
//        // 无限流的接口
//        SimplePressureTester.PressureTestResult noLimit =
//                tester.pressTest(getUrl("/api/test/no-limit"), 100, 10);
//
//        log.info("有限流 QPS: {}", String.format("%.1f", withLimit.getQps()));
//        log.info("无限流 QPS: {}", String.format("%.1f", noLimit.getQps()));
//        log.info("QPS 差距: {}倍", String.format("%.1f", noLimit.getQps() / withLimit.getQps()));
//
//        // 断言：无限流的 QPS 应该远大于有限流的
//        assertThat(noLimit.getQps()).isGreaterThan(withLimit.getQps() * 5);
//    }
}
```



限流异常捕获

```java
@ExceptionHandler(RuntimeException.class)
    @ResponseStatus(HttpStatus.TOO_MANY_REQUESTS)
    public Map<String, Object> handleRateLimit(RuntimeException e) {
        Map<String, Object> result = new HashMap<>();
        result.put("code", 429);
        result.put("message", e.getMessage());
        result.put("timestamp", System.currentTimeMillis());
        return result;
    }
```



















# 这样的方案，如果有恶意请求并发调用，会导致令牌桶满了，正常用户的请求也被限制了吧？