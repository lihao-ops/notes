# 单机限流完整实现方案

## 一、POM 依赖

```xml
<!-- Spring Boot 基础 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

<!-- Spring Boot AOP (用于注解拦截) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>

<!-- Redis -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>

<!-- Nacos 配置中心 -->
<dependency>
    <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    <version>2022.0.0.0</version>
</dependency>

<!-- Guava (本地限流) -->
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>32.1.3-jre</version>
</dependency>

<!-- Micrometer + Prometheus (监控) -->
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>

<!-- Lombok (简化代码) -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>

<!-- Jackson (JSON 处理) -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
```

------

## 二、核心配置文件

### application.yml

```yaml
spring:
  application:
    name: quant-service
  
  # Redis 配置
  redis:
    host: localhost
    port: 6379
    timeout: 3000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 2
  
  # Nacos 配置中心
  cloud:
    nacos:
      config:
        server-addr: localhost:8848
        file-extension: yml
        namespace: dev
        group: RATE_LIMIT_GROUP
        refresh-enabled: true

# Actuator + Prometheus
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
```

### Nacos 配置 (rate-limit-config.yml)

```yaml
rate-limit:
  # 全局限流
  global:
    enabled: true
    qps: 2000
  
  # 接口级限流
  uri:
    /api/strategy/execute:
      qps: 500
      local-fallback-qps: 50
    /api/v1/stable-picks/daily:
      qps: 800
      local-fallback-qps: 100
  
  # 用户级限流
  user:
    default-qps: 50
    vip-qps: 200
  
  # 业务热点限流
  strategy:
    default-qps: 100
    dragonTwo: 50
  
  stock:
    default-qps: 200
  
  # Redis 降级配置
  redis:
    timeout-threshold-ms: 100
    failure-threshold: 3
    recovery-interval-sec: 60
```

------

## 三、核心限流注解

```java
package com.quant.common.ratelimit.annotation;

import java.lang.annotation.*;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RateLimit {
    
    /**
     * 限流维度
     */
    LimitDimension dimension() default LimitDimension.URI;
    
    /**
     * 业务键 (支持 SpEL 表达式)
     * 例如: #strategyId, #stockCode
     */
    String key() default "";
    
    /**
     * 限流阈值 (QPS)，-1 表示从配置中心读取
     */
    int qps() default -1;
    
    /**
     * 本地降级阈值
     */
    int fallbackQps() default 10;
    
    /**
     * 限流失败提示
     */
    String message() default "请求过于频繁，请稍后重试";
    
    /**
     * 限流维度枚举
     */
    enum LimitDimension {
        GLOBAL,      // 全局
        URI,         // 接口
        USER,        // 用户
        STRATEGY,    // 策略
        STOCK,       // 股票
        CUSTOM       // 自定义
    }
}
```

------

## 四、统一限流工具类

```java
package com.quant.common.ratelimit;

import com.google.common.util.concurrent.RateLimiter;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.scripting.support.ResourceScriptSource;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.util.Collections;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

@Slf4j
@Component
public class RateLimiterManager {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Autowired
    private RateLimitConfig config;
    
    @Autowired
    private MeterRegistry meterRegistry;
    
    // Redis Lua 脚本
    private DefaultRedisScript<Long> redisLimitScript;
    
    // 本地限流器缓存
    private final ConcurrentHashMap<String, RateLimiter> localLimiters = new ConcurrentHashMap<>();
    
    // Redis 降级状态
    private volatile boolean redisDegraded = false;
    private final AtomicInteger redisFailureCount = new AtomicInteger(0);
    private final AtomicLong lastRecoveryCheckTime = new AtomicLong(0);
    
    // Prometheus 指标
    private Counter requestsTotal;
    private Counter requestsBlocked;
    private Counter redisFailures;
    private Timer redisLatency;
    
    @PostConstruct
    public void init() {
        // 加载 Lua 脚本
        initRedisScript();
        
        // 初始化 Prometheus 指标
        initMetrics();
        
        log.info("RateLimiterManager 初始化完成");
    }
    
    /**
     * 核心限流方法
     */
    public boolean tryAcquire(String dimension, String key, int qps, int fallbackQps) {
        String redisKey = buildRedisKey(dimension, key);
        
        // 记录总请求数
        requestsTotal.increment();
        
        // 1. 尝试 Redis 集群限流
        if (!redisDegraded) {
            Boolean allowed = tryRedisLimit(redisKey, qps);
            if (allowed != null) {
                if (!allowed) {
                    requestsBlocked.increment();
                    recordBlockedMetric(dimension, key);
                }
                return allowed;
            }
            // Redis 调用失败，进入降级逻辑
        }
        
        // 2. Redis 降级：使用本地限流
        log.warn("Redis 限流降级，使用本地限流: key={}", redisKey);
        boolean allowed = tryLocalLimit(redisKey, fallbackQps);
        if (!allowed) {
            requestsBlocked.increment();
            recordBlockedMetric(dimension, key);
        }
        return allowed;
    }
    
    /**
     * Redis 集群限流
     */
    private Boolean tryRedisLimit(String key, int qps) {
        try {
            long startTime = System.nanoTime();
            
            Long result = redisTemplate.execute(
                redisLimitScript,
                Collections.singletonList(key),
                String.valueOf(qps),
                "1"  // 时间窗口 1 秒
            );
            
            // 记录 Redis 延迟
            long duration = System.nanoTime() - startTime;
            redisLatency.record(duration, TimeUnit.NANOSECONDS);
            
            // 检查是否超时
            if (duration > config.getRedisTimeoutThresholdMs() * 1_000_000) {
                log.warn("Redis 限流响应超时: {}ms", duration / 1_000_000);
                handleRedisFailure();
                return null;
            }
            
            // 重置失败计数
            resetRedisFailure();
            
            return result != null && result == 1;
            
        } catch (Exception e) {
            log.error("Redis 限流异常: key={}", key, e);
            redisFailures.increment();
            handleRedisFailure();
            return null;
        }
    }
    
    /**
     * 本地限流 (Guava RateLimiter)
     */
    private boolean tryLocalLimit(String key, int qps) {
        RateLimiter limiter = localLimiters.computeIfAbsent(key, k -> {
            log.info("创建本地限流器: key={}, qps={}", k, qps);
            return RateLimiter.create(qps);
        });
        
        // 动态调整速率
        if (limiter.getRate() != qps) {
            limiter.setRate(qps);
        }
        
        return limiter.tryAcquire();
    }
    
    /**
     * 处理 Redis 失败
     */
    private void handleRedisFailure() {
        int failures = redisFailureCount.incrementAndGet();
        
        if (failures >= config.getRedisFailureThreshold() && !redisDegraded) {
            log.error("Redis 连续失败 {} 次，开启降级模式", failures);
            redisDegraded = true;
            
            // 记录降级事件
            meterRegistry.counter("rate_limit.redis.degraded").increment();
        }
    }
    
    /**
     * 重置 Redis 失败状态
     */
    private void resetRedisFailure() {
        redisFailureCount.set(0);
        
        // 定期检查是否可以恢复
        if (redisDegraded) {
            long now = System.currentTimeMillis();
            long lastCheck = lastRecoveryCheckTime.get();
            
            if (now - lastCheck > config.getRedisRecoveryIntervalSec() * 1000) {
                if (lastRecoveryCheckTime.compareAndSet(lastCheck, now)) {
                    log.info("Redis 恢复正常，关闭降级模式");
                    redisDegraded = false;
                    meterRegistry.counter("rate_limit.redis.recovered").increment();
                }
            }
        }
    }
    
    /**
     * 构建 Redis Key
     */
    private String buildRedisKey(String dimension, String key) {
        return "rl:" + dimension.toLowerCase() + ":" + key;
    }
    
    /**
     * 初始化 Lua 脚本
     */
    private void initRedisScript() {
        redisLimitScript = new DefaultRedisScript<>();
        redisLimitScript.setScriptSource(new ResourceScriptSource(
            new ClassPathResource("lua/redis-rate-limit.lua")
        ));
        redisLimitScript.setResultType(Long.class);
    }
    
    /**
     * 初始化 Prometheus 指标
     */
    private void initMetrics() {
        requestsTotal = Counter.builder("rate_limit.requests.total")
            .description("总请求数")
            .register(meterRegistry);
        
        requestsBlocked = Counter.builder("rate_limit.requests.blocked.total")
            .description("被限流的请求数")
            .register(meterRegistry);
        
        redisFailures = Counter.builder("rate_limit.redis.failures.total")
            .description("Redis 失败次数")
            .register(meterRegistry);
        
        redisLatency = Timer.builder("rate_limit.redis.latency")
            .description("Redis 限流延迟")
            .register(meterRegistry);
    }
    
    /**
     * 记录被限流的详细指标
     */
    private void recordBlockedMetric(String dimension, String key) {
        meterRegistry.counter("rate_limit.blocked", 
            "dimension", dimension,
            "key", key
        ).increment();
    }
    
    /**
     * 获取当前降级状态
     */
    public boolean isRedisDegraded() {
        return redisDegraded;
    }
}
```

------

## 五、配置类

```java
package com.quant.common.ratelimit;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Data
@Component
@RefreshScope
@ConfigurationProperties(prefix = "rate-limit")
public class RateLimitConfig {
    
    // 全局限流
    private GlobalConfig global = new GlobalConfig();
    
    // 接口级限流
    private Map<String, UriConfig> uri = new HashMap<>();
    
    // 用户级限流
    private UserConfig user = new UserConfig();
    
    // 策略限流
    private Map<String, Integer> strategy = new HashMap<>();
    
    // 股票限流
    private StockConfig stock = new StockConfig();
    
    // Redis 降级配置
    private RedisConfig redis = new RedisConfig();
    
    @Data
    public static class GlobalConfig {
        private boolean enabled = true;
        private int qps = 2000;
    }
    
    @Data
    public static class UriConfig {
        private int qps;
        private int localFallbackQps;
    }
    
    @Data
    public static class UserConfig {
        private int defaultQps = 50;
        private int vipQps = 200;
    }
    
    @Data
    public static class StockConfig {
        private int defaultQps = 200;
    }
    
    @Data
    public static class RedisConfig {
        private int timeoutThresholdMs = 100;
        private int failureThreshold = 3;
        private int recoveryIntervalSec = 60;
    }
    
    // 便捷方法
    public int getUriQps(String uri) {
        UriConfig config = this.uri.get(uri);
        return config != null ? config.getQps() : 100;
    }
    
    public int getUriFallbackQps(String uri) {
        UriConfig config = this.uri.get(uri);
        return config != null ? config.getLocalFallbackQps() : 10;
    }
    
    public int getStrategyQps(String strategyId) {
        return strategy.getOrDefault(strategyId, strategy.getOrDefault("default-qps", 100));
    }
    
    public int getRedisTimeoutThresholdMs() {
        return redis.getTimeoutThresholdMs();
    }
    
    public int getRedisFailureThreshold() {
        return redis.getFailureThreshold();
    }
    
    public int getRedisRecoveryIntervalSec() {
        return redis.getRecoveryIntervalSec();
    }
}
```

------

## 六、AOP 拦截器

```java
package com.quant.common.ratelimit.aspect;

import com.quant.common.ratelimit.RateLimiterManager;
import com.quant.common.ratelimit.RateLimitConfig;
import com.quant.common.ratelimit.annotation.RateLimit;
import com.quant.common.ratelimit.exception.RateLimitException;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.DefaultParameterNameDiscoverer;
import org.springframework.expression.EvaluationContext;
import org.springframework.expression.Expression;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;

@Slf4j
@Aspect
@Component
public class RateLimitAspect {
    
    @Autowired
    private RateLimiterManager rateLimiterManager;
    
    @Autowired
    private RateLimitConfig config;
    
    private final ExpressionParser parser = new SpelExpressionParser();
    private final DefaultParameterNameDiscoverer discoverer = new DefaultParameterNameDiscoverer();
    
    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        
        // 1. 解析限流维度和 Key
        String dimension = rateLimit.dimension().name();
        String key = parseKey(joinPoint, rateLimit);
        
        // 2. 获取限流阈值
        int qps = getQps(rateLimit, dimension, key);
        int fallbackQps = getFallbackQps(rateLimit, dimension, key);
        
        // 3. 执行限流判断
        boolean allowed = rateLimiterManager.tryAcquire(dimension, key, qps, fallbackQps);
        
        if (!allowed) {
            log.warn("请求被限流: dimension={}, key={}, qps={}", dimension, key, qps);
            throw new RateLimitException(rateLimit.message());
        }
        
        // 4. 放行请求
        return joinPoint.proceed();
    }
    
    /**
     * 解析限流 Key (支持 SpEL)
     */
    private String parseKey(ProceedingJoinPoint joinPoint, RateLimit rateLimit) {
        String keyExpression = rateLimit.key();
        
        // 如果没有指定 key，根据维度自动生成
        if (keyExpression.isEmpty()) {
            return generateDefaultKey(joinPoint, rateLimit.dimension());
        }
        
        // 解析 SpEL 表达式
        if (keyExpression.startsWith("#")) {
            return parseSpEL(joinPoint, keyExpression);
        }
        
        return keyExpression;
    }
    
    /**
     * 生成默认 Key
     */
    private String generateDefaultKey(ProceedingJoinPoint joinPoint, RateLimit.LimitDimension dimension) {
        switch (dimension) {
            case GLOBAL:
                return "global";
            
            case URI:
                HttpServletRequest request = getRequest();
                return request != null ? request.getRequestURI() : "unknown";
            
            case USER:
                return getUserId();
            
            default:
                return "default";
        }
    }
    
    /**
     * 解析 SpEL 表达式
     */
    private String parseSpEL(ProceedingJoinPoint joinPoint, String keyExpression) {
        try {
            MethodSignature signature = (MethodSignature) joinPoint.getSignature();
            String[] paramNames = discoverer.getParameterNames(signature.getMethod());
            Object[] args = joinPoint.getArgs();
            
            EvaluationContext context = new StandardEvaluationContext();
            if (paramNames != null) {
                for (int i = 0; i < paramNames.length; i++) {
                    context.setVariable(paramNames[i], args[i]);
                }
            }
            
            Expression expression = parser.parseExpression(keyExpression);
            Object value = expression.getValue(context);
            return value != null ? value.toString() : "null";
            
        } catch (Exception e) {
            log.error("SpEL 解析失败: {}", keyExpression, e);
            return "parse-error";
        }
    }
    
    /**
     * 获取 QPS 阈值
     */
    private int getQps(RateLimit rateLimit, String dimension, String key) {
        // 注解指定的优先
        if (rateLimit.qps() > 0) {
            return rateLimit.qps();
        }
        
        // 从配置中心读取
        switch (RateLimit.LimitDimension.valueOf(dimension)) {
            case GLOBAL:
                return config.getGlobal().getQps();
            
            case URI:
                return config.getUriQps(key);
            
            case USER:
                return config.getUser().getDefaultQps();
            
            case STRATEGY:
                return config.getStrategyQps(key);
            
            case STOCK:
                return config.getStock().getDefaultQps();
            
            default:
                return 100;
        }
    }
    
    /**
     * 获取本地降级 QPS
     */
    private int getFallbackQps(RateLimit rateLimit, String dimension, String key) {
        if (rateLimit.fallbackQps() > 0) {
            return rateLimit.fallbackQps();
        }
        
        if ("URI".equals(dimension)) {
            return config.getUriFallbackQps(key);
        }
        
        return Math.max(getQps(rateLimit, dimension, key) / 10, 10);
    }
    
    /**
     * 获取当前请求
     */
    private HttpServletRequest getRequest() {
        ServletRequestAttributes attributes = 
            (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        return attributes != null ? attributes.getRequest() : null;
    }
    
    /**
     * 获取用户 ID (从请求头或 Session)
     */
    private String getUserId() {
        HttpServletRequest request = getRequest();
        if (request != null) {
            String userId = request.getHeader("X-User-Id");
            if (userId != null) {
                return userId;
            }
        }
        return "anonymous";
    }
}
```

------

## 七、自定义异常

```java
package com.quant.common.ratelimit.exception;

public class RateLimitException extends RuntimeException {
    
    public RateLimitException(String message) {
        super(message);
    }
}
```

------

## 八、全局异常处理

```java
package com.quant.common.exception;

import com.quant.common.ratelimit.exception.RateLimitException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(RateLimitException.class)
    @ResponseStatus(HttpStatus.TOO_MANY_REQUESTS)
    public Map<String, Object> handleRateLimit(RateLimitException e) {
        log.warn("限流异常: {}", e.getMessage());
        
        Map<String, Object> result = new HashMap<>();
        result.put("code", 429);
        result.put("message", e.getMessage());
        result.put("timestamp", System.currentTimeMillis());
        return result;
    }
}
```

------

## 九、Redis Lua 脚本

创建文件：`src/main/resources/lua/redis-rate-limit.lua`

```lua
-- 固定窗口限流
local key = KEYS[1]
local limit = tonumber(ARGV[1])
local window = tonumber(ARGV[2])

-- 增加计数
local current = redis.call('INCR', key)

-- 首次请求设置过期时间
if current == 1 then
    redis.call('EXPIRE', key, window)
end

-- 判断是否超限
if current > limit then
    return 0  -- 拒绝
else
    return 1  -- 允许
end
```

------

## 十、Controller 使用示例

```java
package com.quant.controller;

import com.quant.common.ratelimit.annotation.RateLimit;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/strategy")
public class StrategyController {
    
    /**
     * 接口级限流
     */
    @RateLimit(dimension = RateLimit.LimitDimension.URI)
    @GetMapping("/execute")
    public String executeStrategy() {
        return "策略执行成功";
    }
    
    /**
     * 策略级限流 (SpEL 表达式)
     */
    @RateLimit(
        dimension = RateLimit.LimitDimension.STRATEGY,
        key = "#strategyId",
        message = "该策略访问过于频繁"
    )
    @GetMapping("/detail/{strategyId}")
    public String getStrategyDetail(@PathVariable String strategyId) {
        return "策略详情: " + strategyId;
    }
    
    /**
     * 用户级限流
     */
    @RateLimit(
        dimension = RateLimit.LimitDimension.USER,
        qps = 10,
        fallbackQps = 2
    )
    @PostMapping("/backtest")
    public String backtest(@RequestBody Object request) {
        return "回测完成";
    }
    
    /**
     * 股票级限流
     */
    @RateLimit(
        dimension = RateLimit.LimitDimension.STOCK,
        key = "#stockCode"
    )
    @GetMapping("/stock/{stockCode}")
    public String getStockInfo(@PathVariable String stockCode) {
        return "股票信息: " + stockCode;
    }
}
```

------

## 十一、Prometheus 监控端点

访问：`http://localhost:8080/actuator/prometheus`

**关键指标**：

```
# 总请求数
rate_limit_requests_total

# 被限流的请求数
rate_limit_requests_blocked_total

# Redis 失败次数
rate_limit_redis_failures_total

# Redis 延迟
rate_limit_redis_latency_seconds

# 分维度限流统计
rate_limit_blocked{dimension="STRATEGY",key="dragonTwo"}
```

------

## 十二、监控看板配置

### Prometheus 查询示例

```promql
# 限流率
rate(rate_limit_requests_blocked_total[1m]) / rate(rate_limit_requests_total[1m]) * 100

# Redis P99 延迟
histogram_quantile(0.99, rate(rate_limit_redis_latency_seconds_bucket[5m]))

# 降级状态
rate_limit_redis_degraded

# 热点策略 TOP 5
topk(5, rate(rate_limit_blocked{dimension="STRATEGY"}[5m]))
```

### Grafana 面板建议

1. **限流概览**：总请求、被限流数、限流率曲线
2. **Redis 健康度**：延迟分布、失败率、降级次数
3. **热点分析**：按维度分组的限流 TOP 排行
4. **告警规则**：限流率 > 20%、Redis 降级

------

## 使用说明

### 1. 启动顺序

```bash
# 启动 Nacos
docker run -d -p 8848:8848 nacos/nacos-server

# 启动 Redis
docker run -d -p 6379:6379 redis

# 启动应用
mvn spring-boot:run
```

### 2. 在 Nacos 中配置

- Data ID: `rate-limit-config.yml`
- Group: `RATE_LIMIT_GROUP`
- 内容：参考上面的 Nacos 配置

### 3. 验证限流

```bash
# 压测接口
ab -n 1000 -c 10 http://localhost:8080/api/strategy/execute

# 查看监控
curl http://localhost:8080/actuator/prometheus | grep rate_limit
```

### 4. 模拟 Redis 故障

```bash
# 停止 Redis
docker stop redis

# 观察日志，应该看到降级提示
# 本地限流器会自动接管
```

------

**这套方案的核心优势**：

1. ✅ 统一工具类 `RateLimiterManager`，一处管理所有限流逻辑
2. ✅ 注解驱动 `@RateLimit`，业务代码零侵入
3. ✅ Redis 故障自动降级，永不裸奔
4. ✅ Nacos 配置实时生效（@RefreshScope）
5. ✅ Prometheus 全方位监控，可观测性拉满

需要我继续补充 **集群限流（Redis + Lua）** 或 **网关层限流** 的实现吗?