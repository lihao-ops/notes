# 简化版限流测试类

## 单个测试类搞定所有场景

```java
package com.quant.ratelimit;

import com.quant.common.ratelimit.RateLimiterManager;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import redis.embedded.RedisServer;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;

@Slf4j
@SpringBootTest
@AutoConfigureMockMvc
@ActiveProfiles("test")
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class SimpleRateLimitTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private RateLimiterManager rateLimiterManager;
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    private static RedisServer redisServer;
    
    @BeforeAll
    static void startRedis() throws Exception {
        redisServer = new RedisServer(6370);
        redisServer.start();
        log.info("✓ Redis 启动成功");
    }
    
    @AfterAll
    static void stopRedis() {
        if (redisServer != null) {
            redisServer.stop();
            log.info("✓ Redis 已停止");
        }
    }
    
    @BeforeEach
    void setUp() {
        redisTemplate.keys("rl:*").forEach(key -> redisTemplate.delete(key));
        log.info("清理 Redis 限流数据");
    }
    
    // ==================== 1. 单机限流测试 ====================
    
    @Test
    @Order(1)
    @DisplayName("【单机限流】基础功能测试 - QPS=10")
    void test01_LocalRateLimit() {
        int qps = 10;
        int successCount = 0;
        
        for (int i = 0; i < 20; i++) {
            if (rateLimiterManager.tryAcquire("LOCAL", "test-key", qps, 2)) {
                successCount++;
            }
        }
        
        log.info("单机限流结果: 成功={}/20, 预期≤{}", successCount, qps);
        assertThat(successCount).isLessThanOrEqualTo(qps + 2);
    }
    
    @Test
    @Order(2)
    @DisplayName("【单机限流】并发压测 - 100线程")
    void test02_LocalConcurrentTest() throws Exception {
        int threadCount = 100;
        int qps = 10;
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);
        AtomicInteger successCount = new AtomicInteger(0);
        
        for (int i = 0; i < threadCount; i++) {
            executor.submit(() -> {
                try {
                    latch.countDown();
                    latch.await(); // 所有线程同时发起
                    
                    if (rateLimiterManager.tryAcquire("CONCURRENT", "test", qps, 2)) {
                        successCount.incrementAndGet();
                    }
                } catch (Exception e) {
                    log.error("并发测试异常", e);
                }
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
        
        log.info("并发限流结果: 成功={}/{}, 预期≤{}", successCount.get(), threadCount, qps + 3);
        assertThat(successCount.get()).isLessThanOrEqualTo(qps + 3);
    }
    
    // ==================== 2. 接口限流测试 ====================
    
    @Test
    @Order(3)
    @DisplayName("【接口限流】简单接口 QPS=10")
    void test03_UriRateLimit() throws Exception {
        int qpsLimit = 10;
        int successCount = 0;
        int blockedCount = 0;
        
        for (int i = 0; i < 25; i++) {
            MvcResult result = mockMvc.perform(get("/api/test/simple"))
                .andReturn();
            
            if (result.getResponse().getStatus() == 200) {
                successCount++;
            } else if (result.getResponse().getStatus() == 429) {
                blockedCount++;
            }
        }
        
        log.info("接口限流结果: 成功={}, 被限流={}, 预期成功≤{}", 
            successCount, blockedCount, qpsLimit);
        assertThat(successCount).isLessThanOrEqualTo(qpsLimit + 2);
        assertThat(blockedCount).isGreaterThan(10);
    }
    
    @Test
    @Order(4)
    @DisplayName("【接口限流】高并发压测 - 50线程 x 2秒")
    void test04_UriConcurrentStress() throws Exception {
        int threadCount = 50;
        int durationSeconds = 2;
        AtomicInteger totalRequests = new AtomicInteger(0);
        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger blockedCount = new AtomicInteger(0);
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        long endTime = System.currentTimeMillis() + durationSeconds * 1000;
        
        for (int i = 0; i < threadCount; i++) {
            executor.submit(() -> {
                while (System.currentTimeMillis() < endTime) {
                    try {
                        totalRequests.incrementAndGet();
                        MvcResult result = mockMvc.perform(get("/api/test/high-qps"))
                            .andReturn();
                        
                        if (result.getResponse().getStatus() == 200) {
                            successCount.incrementAndGet();
                        } else if (result.getResponse().getStatus() == 429) {
                            blockedCount.incrementAndGet();
                        }
                        
                        Thread.sleep(20); // 避免空转
                    } catch (Exception e) {
                        log.debug("压测异常", e);
                    }
                }
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(10, TimeUnit.SECONDS);
        
        double actualQps = successCount.get() / (double) durationSeconds;
        double rejectRate = blockedCount.get() * 100.0 / totalRequests.get();
        
        log.info("=== 接口压测报告 ===");
        log.info("总请求: {}", totalRequests.get());
        log.info("成功: {} (QPS: {})", successCount.get(), String.format("%.1f", actualQps));
        log.info("被限流: {} (拒绝率: {}%)", blockedCount.get(), String.format("%.1f", rejectRate));
        
        // 配置的 high-qps 接口 QPS=50
        assertThat(actualQps).isBetween(40.0, 55.0);
    }
    
    // ==================== 3. 策略限流测试 ====================
    
    @Test
    @Order(5)
    @DisplayName("【策略限流】单个策略 QPS=3")
    void test05_StrategyRateLimit() throws Exception {
        int successCount = 0;
        int blockedCount = 0;
        
        // testStrategy 配置 qps=3
        for (int i = 0; i < 10; i++) {
            MvcResult result = mockMvc.perform(
                get("/api/test/strategy/testStrategy")
            ).andReturn();
            
            if (result.getResponse().getStatus() == 200) {
                successCount++;
            } else if (result.getResponse().getStatus() == 429) {
                blockedCount++;
            }
        }
        
        log.info("策略限流结果: testStrategy 成功={}, 被限流={}", successCount, blockedCount);
        assertThat(successCount).isLessThanOrEqualTo(4);
        assertThat(blockedCount).isGreaterThan(5);
    }
    
    @Test
    @Order(6)
    @DisplayName("【策略限流】多个策略独立限流")
    void test06_MultiStrategyIndependent() throws Exception {
        // 策略A: testStrategy (qps=3)
        int strategyASuccess = 0;
        for (int i = 0; i < 8; i++) {
            MvcResult result = mockMvc.perform(
                get("/api/test/strategy/testStrategy")
            ).andReturn();
            if (result.getResponse().getStatus() == 200) {
                strategyASuccess++;
            }
        }
        
        // 策略B: otherStrategy (default qps=20)
        int strategyBSuccess = 0;
        for (int i = 0; i < 25; i++) {
            MvcResult result = mockMvc.perform(
                get("/api/test/strategy/otherStrategy")
            ).andReturn();
            if (result.getResponse().getStatus() == 200) {
                strategyBSuccess++;
            }
        }
        
        log.info("多策略限流结果:");
        log.info("  testStrategy: 成功={}/8, 预期≤4", strategyASuccess);
        log.info("  otherStrategy: 成功={}/25, 预期≤22", strategyBSuccess);
        
        assertThat(strategyASuccess).isLessThanOrEqualTo(4);
        assertThat(strategyBSuccess).isLessThanOrEqualTo(22);
        assertThat(strategyBSuccess).isGreaterThan(strategyASuccess); // B 的限制更宽松
    }
    
    // ==================== 4. Redis 集群限流测试 ====================
    
    @Test
    @Order(7)
    @DisplayName("【Redis限流】验证 Redis 计数器工作")
    void test07_RedisLimiterWorks() throws Exception {
        String redisKey = "rl:uri:/api/test/simple";
        
        // 清空计数
        redisTemplate.delete(redisKey);
        
        // 发送5个请求
        for (int i = 0; i < 5; i++) {
            mockMvc.perform(get("/api/test/simple"));
        }
        
        // 验证 Redis 中有计数
        String count = redisTemplate.opsForValue().get(redisKey);
        log.info("Redis 计数器: key={}, value={}", redisKey, count);
        
        assertThat(count).isNotNull();
        assertThat(Integer.parseInt(count)).isGreaterThanOrEqualTo(5);
        
        // 验证 TTL
        Long ttl = redisTemplate.getExpire(redisKey, TimeUnit.SECONDS);
        log.info("Redis TTL: {}s", ttl);
        assertThat(ttl).isGreaterThan(0);
    }
    
    @Test
    @Order(8)
    @DisplayName("【Redis限流】时间窗口重置测试")
    void test08_RedisWindowReset() throws Exception {
        // 第一轮：打满限流
        int round1Success = 0;
        for (int i = 0; i < 15; i++) {
            MvcResult result = mockMvc.perform(get("/api/test/simple")).andReturn();
            if (result.getResponse().getStatus() == 200) {
                round1Success++;
            }
        }
        
        log.info("第一轮: 成功={}", round1Success);
        assertThat(round1Success).isLessThanOrEqualTo(11);
        
        // 等待时间窗口重置
        log.info("等待 1.5 秒，让时间窗口重置...");
        Thread.sleep(1500);
        
        // 第二轮：应该恢复
        int round2Success = 0;
        for (int i = 0; i < 15; i++) {
            MvcResult result = mockMvc.perform(get("/api/test/simple")).andReturn();
            if (result.getResponse().getStatus() == 200) {
                round2Success++;
            }
        }
        
        log.info("第二轮: 成功={}", round2Success);
        assertThat(round2Success).isLessThanOrEqualTo(11);
        assertThat(round2Success).isGreaterThan(5); // 确保恢复了
    }
    
    // ==================== 5. Redis 降级测试 ====================
    
    @Test
    @Order(9)
    @DisplayName("【降级测试】Redis 故障自动降级到本地限流")
    void test09_RedisDegradation() throws Exception {
        // 1. 验证 Redis 正常工作
        mockMvc.perform(get("/api/test/simple"))
            .andExpect(org.springframework.test.web.servlet.result.MockMvcResultMatchers.status().isOk());
        
        assertThat(rateLimiterManager.isRedisDegraded()).isFalse();
        log.info("✓ Redis 正常工作");
        
        // 2. 停止 Redis
        redisServer.stop();
        log.warn("⚠ Redis 已停止");
        
        // 3. 继续请求，触发降级
        Thread.sleep(500);
        for (int i = 0; i < 5; i++) {
            try {
                mockMvc.perform(get("/api/test/simple"));
            } catch (Exception e) {
                log.debug("降级触发中...", e);
            }
        }
        
        // 4. 验证降级状态
        Thread.sleep(1000);
        assertThat(rateLimiterManager.isRedisDegraded()).isTrue();
        log.info("✓ 已降级到本地限流");
        
        // 5. 验证本地限流生效 (fallbackQps=2)
        int localSuccess = 0;
        for (int i = 0; i < 10; i++) {
            try {
                MvcResult result = mockMvc.perform(get("/api/test/simple"))
                    .andReturn();
                if (result.getResponse().getStatus() == 200) {
                    localSuccess++;
                }
            } catch (Exception ignored) {}
        }
        
        log.info("本地限流结果: 成功={}/10, 预期≤4", localSuccess);
        assertThat(localSuccess).isLessThanOrEqualTo(4); // fallbackQps=2
        
        // 6. 重启 Redis
        redisServer.start();
        log.info("✓ Redis 已重启");
        
        // 7. 等待恢复
        Thread.sleep(6000); // 恢复间隔 5 秒
        
        for (int i = 0; i < 3; i++) {
            mockMvc.perform(get("/api/test/simple"));
        }
        
        Thread.sleep(1000);
        assertThat(rateLimiterManager.isRedisDegraded()).isFalse();
        log.info("✓ 已恢复到 Redis 集群限流");
    }
    
    // ==================== 6. 综合压测 ====================
    
    @Test
    @Order(10)
    @DisplayName("【综合压测】多接口混合压测 - 30秒")
    void test10_MixedStressTest() throws Exception {
        int threadCount = 30;
        int durationSeconds = 10; // 改成10秒，快一点
        
        AtomicInteger simpleSuccess = new AtomicInteger(0);
        AtomicInteger strategySuccess = new AtomicInteger(0);
        AtomicInteger stockSuccess = new AtomicInteger(0);
        AtomicInteger totalBlocked = new AtomicInteger(0);
        
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        long endTime = System.currentTimeMillis() + durationSeconds * 1000;
        
        // 10个线程打 simple 接口
        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                while (System.currentTimeMillis() < endTime) {
                    try {
                        MvcResult result = mockMvc.perform(get("/api/test/simple"))
                            .andReturn();
                        if (result.getResponse().getStatus() == 200) {
                            simpleSuccess.incrementAndGet();
                        } else {
                            totalBlocked.incrementAndGet();
                        }
                        Thread.sleep(50);
                    } catch (Exception ignored) {}
                }
            });
        }
        
        // 10个线程打 strategy 接口
        for (int i = 0; i < 10; i++) {
            executor.submit(() -> {
                while (System.currentTimeMillis() < endTime) {
                    try {
                        MvcResult result = mockMvc.perform(
                            get("/api/test/strategy/testStrategy")
                        ).andReturn();
                        if (result.getResponse().getStatus() == 200) {
                            strategySuccess.incrementAndGet();
                        } else {
                            totalBlocked.incrementAndGet();
                        }
                        Thread.sleep(100);
                    } catch (Exception ignored) {}
                }
            });
        }
        
        // 10个线程打 stock 接口
        for (int i = 0; i < 10; i++) {
            final int stockId = i % 3; // 轮询3个股票
            executor.submit(() -> {
                while (System.currentTimeMillis() < endTime) {
                    try {
                        MvcResult result = mockMvc.perform(
                            get("/api/test/stock/60051" + stockId)
                        ).andReturn();
                        if (result.getResponse().getStatus() == 200) {
                            stockSuccess.incrementAndGet();
                        } else {
                            totalBlocked.incrementAndGet();
                        }
                        Thread.sleep(80);
                    } catch (Exception ignored) {}
                }
            });
        }
        
        executor.shutdown();
        executor.awaitTermination(durationSeconds + 5, TimeUnit.SECONDS);
        
        log.info("================ 综合压测报告 ================");
        log.info("测试时长: {}s", durationSeconds);
        log.info("simple 接口: 成功={} (QPS={})", 
            simpleSuccess.get(), 
            simpleSuccess.get() / durationSeconds);
        log.info("strategy 接口: 成功={} (QPS={})", 
            strategySuccess.get(), 
            strategySuccess.get() / durationSeconds);
        log.info("stock 接口: 成功={} (QPS={})", 
            stockSuccess.get(), 
            stockSuccess.get() / durationSeconds);
        log.info("总被限流: {}", totalBlocked.get());
        log.info("============================================");
        
        // 简单验证各接口都有流量通过
        assertThat(simpleSuccess.get()).isGreaterThan(50);
        assertThat(strategySuccess.get()).isGreaterThan(10);
        assertThat(stockSuccess.get()).isGreaterThan(50);
    }
}
```

------

## 运行说明

### 1. 直接运行测试

```bash
# Maven
mvn test -Dtest=SimpleRateLimitTest

# IDEA
右键点击类名 -> Run 'SimpleRateLimitTest'
```

### 2. 测试输出示例

```
✓ Redis 启动成功
清理 Redis 限流数据

【单机限流】基础功能测试
单机限流结果: 成功=10/20, 预期≤10 ✓

【单机限流】并发压测
并发限流结果: 成功=11/100, 预期≤13 ✓

【接口限流】简单接口
接口限流结果: 成功=10, 被限流=15 ✓

【接口限流】高并发压测
=== 接口压测报告 ===
总请求: 1523
成功: 102 (QPS: 51.0)
被限流: 1421 (拒绝率: 93.3%)
✓

【策略限流】单个策略
策略限流结果: testStrategy 成功=3, 被限流=7 ✓

【策略限流】多个策略独立
多策略限流结果:
  testStrategy: 成功=3/8 ✓
  otherStrategy: 成功=20/25 ✓

【Redis限流】验证计数器
Redis 计数器: key=rl:uri:/api/test/simple, value=5
Redis TTL: 1s ✓

【Redis限流】时间窗口重置
第一轮: 成功=10
等待 1.5 秒...
第二轮: 成功=10 ✓

【降级测试】Redis 故障
✓ Redis 正常工作
⚠ Redis 已停止
✓ 已降级到本地限流
本地限流结果: 成功=2/10
✓ Redis 已重启
✓ 已恢复到 Redis 集群限流

【综合压测】多接口混合
================ 综合压测报告 ================
测试时长: 10s
simple 接口: 成功=98 (QPS=9.8)
strategy 接口: 成功=29 (QPS=2.9)
stock 接口: 成功=122 (QPS=12.2)
总被限流: 456
============================================

✓ Redis 已停止
```

------

## 关键测试点总结

| 测试项         | 覆盖点                   | 验证指标         |
| -------------- | ------------------------ | ---------------- |
| **单机限流**   | 基础功能、并发安全       | QPS 准确性       |
| **接口限流**   | URI 维度、高并发         | 实际 QPS vs 配置 |
| **策略限流**   | SpEL 解析、独立计数      | 多策略隔离       |
| **Redis 限流** | 计数器、TTL、窗口重置    | Redis 正确性     |
| **降级测试**   | 故障检测、自动切换、恢复 | 降级状态切换     |
| **综合压测**   | 多接口混合、长时间稳定性 | 整体 QPS         |

------

**一个类搞定所有场景！** 需要调整测试参数或增加测试点吗？