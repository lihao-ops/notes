# 量化选股系统——面试精简手稿

说明：这是为京东面试准备的精简版手稿，按“可快速复述 + 可被追问”的结构组织。每段尽量 30–60 秒说完，关键数字和结论优先。

---

## 1. 项目总览（30s）
- 系统：量化选股系统，包含数据采集与存储、因子计算、选股、策略回测、风控、Base 公共模块、微服务治理。
- 技术栈：
  - 数据与消息：Kafka、MySQL、Redis
  - 微服务：Nacos、Feign、Sentinel
- 我负责：数据模块 + 回测模块（性能提升与稳定性治理）。

---

## 2. 我的职责与成果（30–45s）
- 数据模块难点：行情数据量大、查询频繁、冷热明显。
  - 方案：MySQL+Redis 分层；热点进 Redis，布隆过滤器防穿透；分布式锁避免重复任务。
  - 收益：核心查询从约 2.5s 优化至约 60ms；缓存命中稳定，高并发下数据库压力显著下降。
- 回测模块难点：单策略回测耗时长，影响并发。
  - 方案：行情预加载内存、数组列式存储、批量/向量化计算、多线程分片并行。
  - 收益：系统吞吐量提升约 1.8×（TPS 5000→9000），平均延迟降低约 40%（500ms→300ms）。

---

## 3. 架构与数据流（45s）
- 数据采集：行情网关接入 → Kafka 批量异步生产，优化 batch.size + linger.ms。
- 数据消费：策略/风控订阅 Kafka → 并发 + 分区消费 → 计算结果回写 MySQL/Redis。
- 落库策略：收盘后批量落库（避免交易时段写入影响读性能）；历史表分表/分区 + 覆盖索引；热点 Redis。
- 微服务治理：Nacos 注册配置信息，Feign 调用，Sentinel 做限流/熔断，Kafka 削峰填谷。

---

## 4. 关键优化点与量化指标（30s）
- 缓存与防穿透：Redis 集群 + 布隆过滤器。
- 幂等与资源保护：分布式锁控制重复任务执行，保证唯一写入。
- 查询优化：覆盖索引 + 按月分表，单股整月查询 2.5s→60ms。
- 消息吞吐：Kafka 生产端批量异步；消费端分区并发；保证幂等、不丢、不积压。
- 回测引擎：数组列式存储、批量计算、减少 GC；多线程并行。
- 总体收益：吞吐约 +1.8×，延迟约 -40%。

---

## 5. MySQL 历史行情表优化（45s）
- 痛点：单表 >1 亿条，查询慢、回表多、IO 高。
- 方案：
  1) 按月分表，单表控制 ~3000 万；
  2) 去冗余索引，建立联合主键/唯一 `(wind_code, trade_date)`；
  3) 建覆盖索引 `(wind_code, trade_date, latest_price, total_volume, average_price)`，避免回表；
  4) 规划冷热分离：近三个月留 MySQL，历史归档到 ClickHouse/ES。
- 效果：单股整月查询约 203ms→60–65ms，约 3.3× 提升；回表率接近 0。

可选答法（读写权衡）：
- 读多写少：联合主键 `(wind_code, trade_date)` 更优（范围扫描，无回表）。
- 写入很高：自增 `id` 主键 + 唯一索引 `(wind_code, trade_date)` + 覆盖索引，提升插入吞吐，查询性能接近。

---

## 6. Redis 与分布式锁（30s）
- 场景：回测/因子任务可能被重复触发。
- 方案：Redis 分布式锁（SET NX EX），锁值唯一（UUID）；心跳续租（Lua校验 value 后续租）；释放锁用 Lua 保证原子性；写入结果做幂等（SET NX 或 DB 唯一约束）。
- 收益：重复执行率显著下降，节约计算资源，避免结果冲突。

---

## 7. Kafka 可靠性与削峰（30–45s）
- 生产端：批量异步（batch.size + linger.ms）；acks=all；enable-idempotence=true；合理线程池。
- 消费端：并发 + 分区消费；消费组扩展吞吐；处理幂等与重试。
- 积压治理：Topic 级 retention.ms 配置（按可用存储/日均数据量计算保留天数）；监控磁盘与消费速率；错峰落库（收盘后）。
- 目标：不丢、不重、不积压；实时链路稳定，离线任务不扰动线上。

---

## 8. 回测引擎性能优化（45s）
- 设计原则：少 new、少装箱、多数组；批量/向量化；预分配缓冲；线程隔离；降低 GC。
- 具体手段：
  - 行情数据列式数组：time[], open[], high[], low[], close[], volume[]。
  - 批量指标计算（EMA/SMA 滑窗），一次扫数组，结果预分配 out[]。
  - 策略循环用下标访问，避免对象创建；如需事件对象，ThreadLocal 池化。
  - 并行：多策略/分片并行，避免共享可变状态。
- JVM 参数（示例）：
  - G1GC：-XX:+UseG1GC -XX:MaxGCPauseMillis=100 -Xms8g -Xmx8g -XX:+AlwaysPreTouch
  - 日志：-Xlog:gc*,safepoint:file=./gc.log:time,uptime,level,tags
- 效果：对象分配率下降、GC 次数与停顿减少、CPU cache 命中率提升、吞吐与延迟稳定性提升。

---

## 9. 流控与熔断（Sentinel）（30s）
- 限流（FlowRule）：按资源名 QPS/并发限流；控制行为（快速失败/预热/排队）；入口链路限流保护。
- 熔断（DegradeRule）：RT/异常比例/异常次数策略；timeWindow 半开恢复；minRequestAmount 防误判。
- 配合策略：入口先限流稳定流量；下游异常时熔断降级，避免级联雪崩。

---

## 10. 监控与验证（30s）
- 压测与度量：TPS、平均/ P95/P99 延迟、错误率。
- GC/JVM：GC 日志（次数、停顿时间）、JFR（分配率、Hot Methods）、对象直方图（装箱类减少）。
- 业务：Kafka lag、MySQL 慢查询、Redis 命中率；锁获取/释放与失败率。
- 数据指标对比：
  - TPS：5000→9000（+80%）
  - 延迟：500ms→300ms（-40%）
  - 查询：2.5s→60ms（核心路径）

---

## 11. 高频问答（速答版）
- 联合索引 vs 覆盖索引？
  - 联合索引是结构；覆盖索引是效果。查询字段完全被索引包含时触发覆盖索引，避免回表。
- 为什么数组比集合快？
  - 连续内存 + 原始类型 → CPU 缓存命中高、无装箱/拆箱、对象更少、GC 压力更低。
- 什么是 Full GC 抖动？
  - 运行期间突发 Full GC 导致长停顿，响应时间曲线出现尖刺，表现为延迟不稳定。用固定堆、降低触发阈值、减少大对象分配等避免。
- 为什么选择联合主键 `(wind_code, trade_date)`？
  - 读多写少、范围查询主路径，联合主键范围扫描更优且避免回表；写入极高场景用自增主键 + 唯一索引折中。
- 为什么批量落库要错峰？
  - 交易时段写入占用 IO/事务资源易影响线上读；收盘后批量写入更稳，且索引维护成本更低。

---

## 12. 一句话亮点总结（10–15s）
通过缓存分层、索引与表结构优化、Kafka 并行与削峰、回测引擎内存与并行优化，以及限流熔断治理，我把系统在高并发场景下的吞吐提升到原来的约 1.8 倍，平均延迟降低约 40%，核心查询从 2.5 秒优化到 60 毫秒，同时保证消息与任务的幂等、稳定与不丢失，兼顾工程可扩展性和运维可观测性。





















