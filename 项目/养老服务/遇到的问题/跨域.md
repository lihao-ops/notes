跨域
===



一、是什么?
---

想象一下你在玩一个迷宫游戏，你只能在自己的房间里做事情，但是不能去邻居的房间。同样的道理，网页也是如此，一个网页通常只能和同一个地方（同一个域名）的信息交流，而不能和其他域名的网页直接交流。



跨域（Cross-Origin）是指在Web开发中，**当一个页面的资源（比如脚本、样式表、图片等）来自于不同的域（domain）时，浏览器为了安全考虑会限制页面对这些资源的访问**。域指的是网站的主机部分，比如 `example.com` 是一个域，`subdomain.example.com` 是另一个域，甚至 `example.com` 和 `example.net` 也是不同的域。

跨域问题通常是指在浏览器环境下，一个网页通过 XMLHttpRequest 或 Fetch API 等方式去请求另一个域下的资源时出现的限制。这种限制是由**同源策略（Same-Origin Policy）**引起的，**同源策略要求浏览器只允许在同一个源（即协议、域名、端口号都相同）下的页面间进行相互交互，而不同源的页面间则不允许直接交互**。





> 1.为什么会有跨域问题？

这是为了保护你的信息安全。想象一下，如果你在一个购物网站输入了密码和信用卡信息，这些信息应该只能被那个网站访问到，而不是其他不相关的网站。





>2.为什么指的主要是在Web开发中出现的？

跨域问题主要存在Web开发中是因为Web应用是基于浏览器的客户端/服务器架构，而浏览器实施了同源策略来确保安全性。

**同源策略**：**限制了一个网页或者一个脚本只能从同一个源加载资源，这个源由：协议(protocol)、域名(domain)和端口号(port)组成**。

跨域问题在其它环境下可能也存在，但是主要在Web开发中引起，因为**Web应用的前端代码通常在浏览器中运行**，而**浏览器严格实施了同源策略**。这意味着，如果一个网页尝试加载来自不同源的资源，例如通过XMLHttpRequest、Fetch API或者动态创建`<script>`标签等方式，浏览器将会拒绝这些请求，从而导致跨域问题。

其它环境如移动应用开发、桌面应用开发等在网络请求时也可能遇到类似的跨域问题，但它们通常不受同源策略的限制，因为**它们的网络请求通常由应用程序自己处理，而不是通过浏览器**。因此，跨域问题在这些环境下可能并不是如此突出和普遍。







二、怎么解决
---

为了解决跨域问题，通常有以下几种方法：

1. CORS（Cross-Origin Resource Sharing）：服务端允许跨域请求，通过在响应头中添加 CORS 相关的字段，来告知浏览器该资源允许哪些来源的跨域访问。
2. JSONP（JSON with Padding）：利用 `<script>` 标签的跨域特性，通过动态添加 `<script>` 标签来获取跨域资源。
3. 代理：在同源的服务器端发起请求，然后将结果返回给客户端，从而绕过了浏览器的跨域限制。
4. WebSocket：使用 WebSocket 协议建立客户端和服务器端的双向通信，WebSocket 不受同源策略的限制。
5. 使用跨域资源共享的相关技术，例如在服务器端设置 CORS 头部，或者使用专门的反向代理服务器。





如果你在 Java 中开发网站，并且需要处理跨域问题，可以使用 CORS（跨域资源共享）来解决。就好像是你和邻居商量好了可以去对方家玩一会儿。

在 Java 中，你可以使用 Spring 框架提供的 `@CrossOrigin` 注解或者配置 CORS 过滤器来允许特定的域名访问你的网站资源。这就像是**给邻居一个通行证，让他们可以来你家玩一下**，但其他人不行。









三、实际应用
---

跨域问题是为了保护网站上的信息安全而设置的规则。通过合理地配置 CORS，我们可以允许某些特定的网站与我们的网站进行交流，这样可以更安全地处理跨域请求。就像是你和邻居商量好了互相可以来彼此家玩耍一样。





#### 案例一、在浏览器请求一直403

但是单独调用接口直接访问却没有出现这样的情况。



##### 1.产生的原因

发现浏览器页面中更新一直显示无权限，但接口调试无异常，直接显示403。

>页面调试图

![image-20240106193258992](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202401061932079.png)



>后台服务日志信息

![image-20240106193212871](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202401061932129.png)









##### 2.发现过程

最终重复在前端页面调试对比出现的日志中发现

![image-20240106193415295](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20240106193415295.png)



在网络请求中，OPTIONS 是一种预检请求，用于确定对特定资源所支持的请求方法。当浏览器或客户端尝试与服务器进行跨域资源共享（CORS）时，**会发出 OPTIONS 请求来检查服务器是否允许特定的请求**。

在你提到的情况中，可能存在跨域请求或者客户端发送了一个 OPTIONS 请求以确定是否能够发送一个真正的请求（例如，POST、GET 等）。请求原本为 pat（可能是某种请求方法，例如 PATCH），但实际发送的请求却是 OPTIONS。

这可能是因为浏览器在发送实际请求之前首先发送了一个 OPTIONS 预检请求，以确认服务器是否允许使用 pat 这种请求方法。如果服务器允许该请求方法，则浏览器会随后发送实际的 pat 请求。









##### 3.处理解决

> 确定为跨域问题后，查看服务关于跨域配置如下：

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    /**
     * 跨域配置
     */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOriginPatterns("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE")
                .allowCredentials(true);
    }
}
```

其中发现并不支持options请求跨域请求，那么在这里加上即可

`.allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")` 这样的配置用于设置 CORS（跨域资源共享）策略，允许服务器接受特定的请求方法。通过将 OPTIONS 添加到 `.allowedMethods()` 中，表明服务器允许接受 OPTIONS 请求方法，从而支持跨域请求的预检。

这样的设置告诉浏览器，服务器支持这些请求方法，包括 OPTIONS。这对于跨域请求的处理非常重要，因为浏览器在发起跨域请求时会先发送 OPTIONS 请求，检查服务器是否允许实际的请求方法。

当浏览器发出 OPTIONS 预检请求时，服务器若配置了 `.allowedMethods("OPTIONS")` 或包含 OPTIONS 在内的其他请求方法列表，就可以正确响应跨域请求，并允许浏览器发送实际的请求。

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    /**
     * 跨域配置
     */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOriginPatterns("*")
            //如果不指定 .allowedMethods()，默认情况下，Spring 将只允许 GET、HEAD 和 POST 方法的跨域请求。因此，通过 .allowedMethods() 方法可以自定义允许的跨域请求方法，使得服务器可以处理更多种类的跨域请求。
                .allowedMethods("GET", "POST", "PUT", "DELETE","OPTIONS")
                .allowCredentials(true);
    }
}
```





>随后部署再调试

发现问题已经圆满解决了









